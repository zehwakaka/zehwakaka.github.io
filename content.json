{"meta":{"title":"Alice's blog","subtitle":"郑","description":null,"author":"John Doe","url":"http://zehwakaka.github.io"},"pages":[],"posts":[{"title":"算法","slug":"算法","date":"2021-07-15T11:34:21.000Z","updated":"2021-07-15T11:34:22.000Z","comments":true,"path":"2021/07/15/算法/","link":"","permalink":"http://zehwakaka.github.io/2021/07/15/算法/","excerpt":"","text":"","raw":null,"content":null,"categories":[],"tags":[]},{"title":"SQL代码练习","slug":"SQL代码练习","date":"2021-07-15T06:22:33.000Z","updated":"2021-07-26T16:06:02.000Z","comments":true,"path":"2021/07/15/SQL代码练习/","link":"","permalink":"http://zehwakaka.github.io/2021/07/15/SQL代码练习/","excerpt":"","text":"自学SQL网1. lesson 1 select title from movies; select director from movies; select title,director from movies; select title,year from movies; select * from movies; select title,id,length_minutes from movies; 2. lesson 2 select * from movies where id = 6; select * from movies where year between 2000 and 2010; select * from movies where year not between 2000 and 2010; select * from movies where id &lt;=5; select * from movies where year &gt;= 2010 and length_minutes &lt; 120; 3.lesson 3 SELECT * FROM movies where title like “%Toy Story%”; SELECT * FROM movies where director like “john lasseter”; SELECT * FROM movies where director not like “john lasseter”; SELECT * FROM movies where title like “wall-%” SELECT * FROM movies where year=”1998”; 4.lesson 4 select distinct director from movies order by director asc; select * from movies order by year desc limit 4; select * from movies order by title asc limit 5; select * from movies order by title asc limit 5 offset 5; select title from movies where director = “John Lasseter” order by length_minutes asc limit 1 offset 2; 5.lesson 5","raw":null,"content":null,"categories":[],"tags":[{"name":"刷题","slug":"刷题","permalink":"http://zehwakaka.github.io/tags/刷题/"}]},{"title":"Java面试题","slug":"Java面试题","date":"2021-07-13T15:42:12.000Z","updated":"2021-07-26T16:06:06.000Z","comments":true,"path":"2021/07/13/Java面试题/","link":"","permalink":"http://zehwakaka.github.io/2021/07/13/Java面试题/","excerpt":"","text":"抄自程序员囧辉公众号 Java 基础1.面向对象的三个基本特征？面向对象的三个基本特征是：封装、继承和多态 继承：让某个类型的对象获得另一个类型的对象的属性的方法。继承就是子类继承父类的特征和行为，使得子类对象(实例)具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。 封装：隐藏部分对象的属性和实现细节，对数据的访问只能通过对外公开的接口。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。 多态：对于同一个行为，不同的子类对象具有不同的表现形式。多台存在的3个条件：1）继承 2）重写 3）父类引用指向子类对象。 举个简单的例子：英雄联盟里面我们按下Q键这个动作： 对于亚索，就是斩钢闪 对于提莫，就是致盲吹箭 对于剑圣，就是阿尔法突袭 同一个事件发生在不同的对象上会产生不同的结果。 我再举一个简单的例子帮助大家理解，这个例子可能不是完全准确，但是我认为是有利于理解的。 1234567891011121314151617181920public class Animal&#123; //动物 public void sleep()&#123; System.out.println(\"躺着睡\"); &#125;&#125;class Horse extends Animal&#123;//马 是一种动物 public void sleep()&#123; System.out.println(\"站着睡\"); &#125;&#125;class Cat extends Animal&#123; private int age; public int getAge()&#123; return age + 1; &#125; @Override public void sleep()&#123; System.out.println(\"四脚朝天的睡\"); &#125;&#125; House 和 Cat 都是 Animal，所以他们都继承了Animal,同时也从Animal继承了sleep这个行为。 但是针对sleep这个行为，House和Cat进行了重写，有了不同的表现形式(实现)，这个我们称为多态。 在Cat里，将age属性定义为private，外界无法直接访问，要获取Cat的age信息只能通过getAge方法，从而对外隐藏了age属性，这个就叫封装。当然，这边age只是个例子，实际使用中可能是一个复杂很多的对象。 2、访问修饰符public，private，protected，以及不写时的区别？ 修饰符 当前类 同包 子类 其他包 public √ √ √ √ protected √ √ √ × 不写 √ √ × × private √ × × × 3.下面两个代码块能正常编译和执行吗？1234//代码块1short s1 = 1;s1 = s1 + 1;//代码块2short s1 = 1; s1 += 1;","raw":null,"content":null,"categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"http://zehwakaka.github.io/tags/面试/"}]},{"title":"经验","slug":"经验","date":"2021-07-13T15:27:58.000Z","updated":"2021-07-13T15:30:36.000Z","comments":true,"path":"2021/07/13/经验/","link":"","permalink":"http://zehwakaka.github.io/2021/07/13/经验/","excerpt":"","text":"经验面试了兴业数金，发现自己太菜了，痛下决心好好学习。 字节跳动收了我的简历十分高兴！！！","raw":null,"content":null,"categories":[],"tags":[{"name":"经验","slug":"经验","permalink":"http://zehwakaka.github.io/tags/经验/"}]},{"title":"Java常用类","slug":"Java常用类","date":"2021-05-01T17:29:11.000Z","updated":"2021-05-02T13:43:20.000Z","comments":true,"path":"2021/05/02/Java常用类/","link":"","permalink":"http://zehwakaka.github.io/2021/05/02/Java常用类/","excerpt":"","text":"一、内部类概念：在一个类的内部再定义一个完整的类。 特点： 编译之后可生成独立的字节码文件。 内部类可直接访问外部类的私有成员，而不破坏封装。 可为外部类提供必要的内部功能组件。 1.成员内部类 再类的内部定义，与实例变量、实例方法同级别的类。 外部类的一个实例部分，创建内部类对象时，必须依赖外部类对象。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Outer&#123; //实例变量 private String name = \"张三\"; private int age = 20; //内部类 class Inner&#123; private String address = \"北京\"; private String phone = \"110\"; //内部属性和外部类的属性名字相同，Outer.this private String name = \"李四\"; //private static final String country = \"中国\"; //方法 public void show()&#123; //打印外部类的属性 System.out.println(Outer.this.name); System.out.println(Outer.this.age); //打印内部类中的属性 System.out.println(address); System.out.println(phone); &#125; &#125;&#125;//testpublic class TestOuter&#123; public static void main(String[] args)&#123; //1创建外部类对象 // Outer outer = new Outer(); //2创建内部类对象 // Inner inner = outer.new Inner(); //一步到位 Inner inner = new Outer().new Inner(); inner.show(); &#125;&#125; 在类的内部定义，与实例变量、实例方法同级别的类。 外部类的一个实例部分，创建内部类对象时，必须依赖外部类对象。 Outer out = new Outer(); Inner in = out.new Inner(); 当外部类、内部类存在重名属性时，会优先访问内部类属性。 成员内部类不能定义静态成员 2.静态内部类 不依赖外部类对象，可直接创建或通过类名访问，可声明静态成员。 Outer.Inner inner = new Outer.Inner(); Outer.Inner.show(); 123456789101112131415161718192021222324252627282930313233343536373839//外部类public class Outer&#123; private String name = \"xxx\"; private int age = 18; //静态内部类: 和外部类相同 static class Inner&#123; private String address = \"上海\"; private String phone = \"111\"; //静态成员 private static int count = 1000; public void show()&#123; //调用外部类的属性呢 //1先创建外部类对象 Outer outer = new Outer(); //2调用外部类对象的属性 System.out.println(outer.name); System.out.println(outer.age); //调用静态内部类的属性和方法 System.out.println(address); System.out.println(phone); //调用静态内部类的静态属性 System.out.println(Inner.count); &#125; &#125;&#125;//testpublic class TestOuter&#123; public static void main(String[] args)&#123; //直接创建静态内部类对象 Outer.Inner inner = new Outer.Inner(); //调用方法 inner.show(); &#125;&#125; 3.局部内部类 定义在外部类方法中，作用范围和创建对象范围仅限于当前方法。 局部内部类访问外部类当前方法中的局部变量时，因无法保障变量的生命周期与自身相同，变量必须修饰为final。 限制类的使用范围。 123456789101112131415161718192021222324252627282930313233343536373839//外部类public class Outer&#123; private String name = \"刘德华\"; private int age = 35; public void show()&#123; //定义局部变量 String address = \"深圳\"; //局部内部类：注意不能加任何访问修饰符 class Inner&#123; private String phone=\"15888888\"; private String email=\"luidehau@qq.com\"; //private final static int count = 2000; public void show2()&#123; //访问外部类的属性 System.out.println(Outer.this.name); System.out.println(Outer.this.age); //访问内部类的属性 System.out.println(this.phone); System.out.println(this.email); //访问局部变量,jdk1.7要求：变量必须要是常量final，jdk1.8自动添加final System.out.println(address); &#125; &#125; //创建局部内部类对象 Inner inner = new Inner(); inner.show2(); &#125;&#125;//testpublic class TestOuter&#123; public static void main(String[] ags)&#123; Outer outer = new Outer(); outer.show(); &#125;&#125; 4.匿名内部类 没有类名的局部内部类（一切特征都与局部内部类相同）。 必须继承一个父类或者实现一个接口。 定义类、实现类、创建对象的语法合并，只能创建一个该类的对象。 优点：减少代码量。 缺点：可读性较差。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public interface Usb&#123; //服务 void service();&#125;public class TestUsb&#123; public static void main(String[] args)&#123; //创建接口类型的变量 /* Usb usb = new Mouse(); usb.service(); */ //局部内部类 5 class Fan implements Usb&#123; @Override public void service()&#123; System.out.println(\"连接电脑成功，风扇开始工作了。。。\"); &#125; &#125; //使用局部内部类创建对象 Usb usb = new Fan(); usb.service(); //使用匿名内部类优化(相当于创建了一个局部内部类) Usb usb = new Usb&#123; @Override public void service()&#123; System.out.println(\"连接电脑成功，风扇开始工作了。。。\"); &#125; &#125;; usb.service(); &#125;&#125;public class Mouse implements Usb&#123; @Override public void service()&#123; System.out.println(\"连接电脑成功，鼠标开始工作了。。。\"); &#125;&#125; 二、Object类 超类、基类，所有类的直接或间接父类，位于继承树的最顶层。 任何类，如没有书写extends显示继承某个类，都默认直接继承Object类，否则为间接继承。 Object类中所定义的方法，是所有对象都具备的方法。 Object类型可以存储任何对象。 作为参数，可接受任何对象。 作为返回值，可返回任何对象。 getClass（）方法 public final Class&lt;?&gt; getClass(){} 返回引用中存储的实际对象类型。 应用：通常用于判断两个引用中实际存储对象类型是否一致。 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class Student&#123; private String name; private int age; public Student()&#123; // TODO Auto-generated constructor stub &#125; public Student(String name,int age)&#123; super(); this.name = name; this.age = age; &#125; public String getName()&#123; return name; &#125; public void setName()&#123; this.name = name; &#125; public int getAge()&#123; return age; &#125; public void setAge(int age)&#123; this.age = age; &#125;&#125;public class TestStudent&#123; public static void main(String[] args)&#123; Student s1 = new Student(\"aaa\",20); Student s2 = new Student(\"bbb\",22); //判断s1和s2是不是同一个类型 Class class1 = s1.getClass(); Class class2 = s2.getClass(); if(class1==class2)&#123; System.out.println(\"s1和s2属于同一个类型\"); &#125;else&#123; System.out.println(\"s1和s2不属于同一个类型\"); &#125; &#125; &#125; hashCode()方法 public int hashCode(){} 返回该对象的哈希码值。 哈希值根据对象的地址或字符串或数字使用hash算法计算出来的int类型的数值。 一般情况下相同对象返回相同哈希码。 1234567891011121314151617181920212223public class TestStudent&#123; public static void main(String[] args)&#123; Student s1 = new Student(\"aaa\",20); Student s2 = new Student(\"bbb\",22); //判断s1和s2是不是同一个类型 Class class1 = s1.getClass(); Class class2 = s2.getClass(); if(class1==class2)&#123; System.out.println(\"s1和s2属于同一个类型\"); &#125;else&#123; System.out.println(\"s1和s2不属于同一个类型\"); &#125; //hashCode方法 System.out.println(s1.hashCode()); System.out.println(s2.hashCode()); Student s3 = s1; System.out.println(s3.hashCode()); &#125; &#125; toString方法 public String toString(){} 返回该对象的字符串表示（表现形式）。 可以根据程序需求覆盖该方法，如：展示对象各个属性值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class Student&#123; private String name; private int age; public Student()&#123; // TODO Auto-generated constructor stub &#125; public Student(String name,int age)&#123; super(); this.name = name; this.age = age; &#125; public String getName()&#123; return name; &#125; public void setName()&#123; this.name = name; &#125; public int getAge()&#123; return age; &#125; public void setAge(int age)&#123; this.age = age; &#125; public String toString()&#123; return name+\":\"+age; &#125; &#125;public class TestStudent&#123; public static void main(String[] args)&#123; //1getClass方法 System.out.println(\"------------1getClass---------------\"); Student s1 = new Student(\"aaa\",20); Student s2 = new Student(\"bbb\",22); //判断s1和s2是不是同一个类型 Class class1 = s1.getClass(); Class class2 = s2.getClass(); if(class1==class2)&#123; System.out.println(\"s1和s2属于同一个类型\"); &#125;else&#123; System.out.println(\"s1和s2不属于同一个类型\"); &#125; System.out.println(\"------------2hashCode---------------\"); //2hashCode方法 System.out.println(s1.hashCode()); System.out.println(s2.hashCode()); Student s3 = s1; System.out.println(s3.hashCode()); System.out.println(\"------------3toString---------------\"); //3toString方法 System.out.println(s1.toString()); System.out.println(s2.toString()); &#125; &#125; equals()方法 public boolean equals(Object obj){} 默认实现为（this == obj），比较两个对象地址是否相同。 可进行覆盖，比较两个对象的内容是否相同。 123456789101112131415161718192021222324252627282930313233343536373839public class TestStudent&#123; public static void main(String[] args)&#123; //1getClass方法 System.out.println(\"------------1getClass---------------\"); Student s1 = new Student(\"aaa\",20); Student s2 = new Student(\"bbb\",22); //判断s1和s2是不是同一个类型 Class class1 = s1.getClass(); Class class2 = s2.getClass(); if(class1==class2)&#123; System.out.println(\"s1和s2属于同一个类型\"); &#125;else&#123; System.out.println(\"s1和s2不属于同一个类型\"); &#125; System.out.println(\"------------2hashCode---------------\"); //2hashCode方法 System.out.println(s1.hashCode()); System.out.println(s2.hashCode()); Student s3 = s1; System.out.println(s3.hashCode()); System.out.println(\"------------3toString---------------\"); //3toString方法 System.out.println(s1.toString()); System.out.println(s2.toString()); //4equals方法，判断两个对象是否相等 System.out.println(\"--------------4equals----------------\"); System.out.println(s1.equal(s2)); Student s4=new Student(\"小明\"，17); Student s5=new Student(\"小明\"，17); System.out.println(s4.equals(s5)); &#125; &#125; equals()方法覆盖步骤 比较两个引用是否指向同一个对象。 判断obj是否为null。 判断两个引用指向的实际对象类型是否一致。 强制类型转换。 依次比较各个属性值是否相同。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public class Student&#123; private String name; private int age; public Student()&#123; // TODO Auto-generated constructor stub &#125; public Student(String name,int age)&#123; super(); this.name = name; this.age = age; &#125; public String getName()&#123; return name; &#125; public void setName()&#123; this.name = name; &#125; public int getAge()&#123; return age; &#125; public void setAge(int age)&#123; this.age = age; &#125; public String toString()&#123; return name+\":\"+age; &#125; @Override public boolean equals(Object obj)&#123; //1判断两个对象是否同一个引用 if(this==obj)&#123; return true; &#125; //2判断obj是否为null if(obj==null)&#123; return false; &#125; //3判断是否同一个类型 //if(this.getClass()==obj.getClass())&#123; //&#125; //instanceof 判断对象是否是某种类型 if(obj instanceof Student)&#123; //4强制类型转换 Student s=(Student)obj; //5比较属性 if(this.name.equals(s.getName())&amp;&amp;this.age==s.getAge())&#123; return true; &#125; &#125; return false; &#125; &#125; finalize()方法 当对象被判定为垃圾对象时，由JVM自动调用此方法，用以标记垃圾对象，进入回收队列。 垃圾对象：没有有效引用指向此对象时，为垃圾对象。 垃圾回收：由GC销毁垃圾对象，释放数据存储空间。 自动回收机制：JVM的内存耗尽，一次性回收所有垃圾对象。 手动回收机制：使用System.gc();通知JVM执行垃圾回收。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899public class Student&#123; private String name; private int age; public Student()&#123; // TODO Auto-generated constructor stub &#125; public Student(String name,int age)&#123; super(); this.name = name; this.age = age; &#125; public String getName()&#123; return name; &#125; public void setName()&#123; this.name = name; &#125; public int getAge()&#123; return age; &#125; public void setAge(int age)&#123; this.age = age; &#125; public String toString()&#123; return name+\":\"+age; &#125; @Override public boolean equals(Object obj)&#123; //1判断两个对象是否同一个引用 if(this==obj)&#123; return true; &#125; //2判断obj是否为null if(obj==null)&#123; return false; &#125; //3判断是否同一个类型 //if(this.getClass()==obj.getClass())&#123; //&#125; //instanceof 判断对象是否是某种类型 if(obj instanceof Student)&#123; //4强制类型转换 Student s=(Student)obj; //5比较属性 if(this.name.equals(s.getName())&amp;&amp;this.age==s.getAge())&#123; return true; &#125; &#125; return false; &#125; @Override protected void finalize() throws Throwable&#123; System.out.println(this.name+\"对象被回收了\"); &#125; &#125;public class TestStudent2&#123; public static void main(String[] args)&#123; //Student s1 = new Student(\"aaa\",20); //Student s2 = new Student(\"bbb\",20); //Student s3 = new Student(\"ccc\",20); //Student s4 = new Student(\"ddd\",20); //Student s5 = new Student(\"eee\",20); new Student(\"aaa\",20); new Student(\"bbb\",20); new Student(\"ccc\",20); new Student(\"ddd\",20); new Student(\"eee\",20); //回收垃圾 System.gc(); System.out.println(\"回收垃圾\"); &#125;&#125;/*打印：回收垃圾ccc对象被回收了aaa对象被回收了eee对象被回收了ddd对象被回收了bbb对象被回收了*/ 包装类 基本数据类型所对应的引用数据类型。 Object可统一所有数据，包装类的默认值是null 基本数据类型 包装类型 byte Byte short Short int Integer long Long float Float double Double boolean Boolean char Character 123public static void main(String[] args)&#123; &#125; 类型转换与装箱、拆箱","raw":null,"content":null,"categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://zehwakaka.github.io/tags/Java/"}]},{"title":"云计算","slug":"云计算","date":"2021-04-20T13:41:51.000Z","updated":"2021-07-13T15:31:28.000Z","comments":true,"path":"2021/04/20/云计算/","link":"","permalink":"http://zehwakaka.github.io/2021/04/20/云计算/","excerpt":"","text":"课件版权所有 第一章 绪论云计算是提供服务的一种形式。 第二章 案例研究背景 ATN——一家全球性公司，向电信业提供网络设备。 ATN基本情况： 电信网络设备提供商 产品范围广泛 通过收购快速成长 ATN问题： 市场压力剧增 产品市场价格 内部成本 技术发展 ATN需求： 改善IT基础设施环境，提高整合度并降低成本； 拟通过外包、云计算·达成目标； 需要解决一些关键问题。 IT架构优化以实现长期成本降低； 提高灵活性、可扩展性、可靠性，提示商业价值； 建立技术标准，适应长期和全面需求； 安全问题，数据失控。 ATN解决方案： 雇佣专业公司； 从多因素评估现有应用，如复杂性、重要性、使用频率、用户量等，然后按评估结果进行排序，选出使用云技术的应用； 用专用工具对选出的应用进行详细评估； 开发目标应用架构，实现应用与云及旧有系统集成； 记录分析成本和实现的简便程度； 开发实验性应用迁移详细计划。 DTGOV——一家公共组织机构，主要向公共领域组织提供IT基础设施和技术服务。 DTGOV基本情况 上市公司 为社会保障部提供IT运维支持 300多个分支机构 3个数据中心，有大型主机和低端平台 DTGOV的问题 客户扩展：服务更多领域客户 业务扩展：主机托管、应用开发运维 客户单独定制服务，没有标准 DTGOV的需求 标准客户服务、软硬件平台、采购、收购 拟采用云计算技术，但要明确业务收益、服务范围、技术挑战、定价、服务质量等 DTGOV解决方案 对客户进行调查访问，确定IaaS服务模型 雇佣专业云计算技术公司提供咨询服务 建立新的更可靠环境 进行3个试点项目，定义合同条件、定价和服务等级策略模型 6个月试点项目后，评价项目，然后推广 Innovartus——一家开发儿童虚拟玩具和教育娱乐产品的中型公司。 Innovatus基本情况 主营虚拟玩具和儿童教育娱乐 支持PC和移动设备 有社交网络环境支持协作和商品交换 家长可参与和监控跟踪 支持自然接口 基于云，采用PaaS平台开发 Innovartus问题 云平台技术局限影响用户接口编程框架特征 Innovartus需求 支持办公自动化等 支持国际化 Isnnovartus解决方案 改进云环境以支持不可预测的用户云交互 改进服务等级避免服务中断 降低成本 迁移风险、技术和经济分析 新与服务提供商选择标准 目前提供商特有服务分析评估 小结 本章介绍3个代表性公司的云计算案例，展示云计算的服务领域、使用范围、实施过程与方案等。 第三章 理解云计算3.1.2 定义 定义：云计算是分布式计算的一种特殊形式，它引入效用模型来远程供给可扩展和可测量的资源。 3.1.3 商业驱动力 容量规划 容量规划是确定和满足一个组织未来对IT资源、产品和服务需求的过程。这里的“容量”是指在一段给定时间内，一个IT资源能够提供的最大工作量. 容量规划策略分为如下三种类型： 领先策略——根据预期增加IT资源的容量 滞后策略——当IT资源达到其最大容量时增加资源容量 匹配策略——当需求增加时，小幅增加IT资源容量 降低成本 IT成本与业务性能之间的恰好平衡是很难保持的。 PPT内容 3.1 起源3.1.1 简要历史 1969，ARPANET(Advanced Reserch Project Agency Network) 1990s,Internet 2000,Grid Computing 2006,Cloud Computing 3.1.2 定义 “……一种计算方式，能通过Internet技术将可扩展的和弹性的IT能力作为服务交付给外部用户。” “……一种标准化的IT性能(服务、软件或者基础设施)，以按使用付费和自助服务方式，通过Internet技术进行交付。” “云计算是一种模型，可以实现随时随地、便捷的、按需地从可配置计算资源共享池中获取所需的资源(例如，网络、服务器、存储、应用程序及服务)，资源可以快速供给和释放，使管理的工作量和服务提供者的介入降低至最少。这种云模型由五个基本特征、三种服务模型和四种部署模型构成。” “云计算是分布式计算的一种特殊形式，它引入效用模型来远程供给可扩展和可测量的资源。” 3.1.3 商业驱动力 动态满足IT资源需求发展需要； 降低IT资源使用成本； IT资源灵活适应组织变化需要。 3.1.4 技术创新 集群 网格计算 虚拟化 其他 宽带互联网 数据中心 Web Service 多租户 3.2 基本概念与术语3.2.1 云 云代表Internet 云计算中的”云”表示独特的IT环境，其设计目的是远程提供可扩展和可测量的IT资源。 3.2.2 IT资源 IT资源指硬件或软件(包括数据)，可以是物理(实体)的，也可以是虚拟(模拟)的。 抽象符号 3.2.3 企业内部的 企业内部的(on-premise) 指企业边界内的IT资源 具有可控性 内外部可以访问、调用、互操作 内外部可以互相迁移 可以冗余部署在内外部 3.2.4 云用户与云提供者 云提供者 以云计算形式提供IT资源的一方(Cloud provider) 云用户 使用云资源的一方(Cloud consumer) 3.2.5 可扩展性 水平扩展(horizontal scaling) 分配资源，向外扩展(scaling out) 释放资源，向内扩展(scaling in) 垂直扩展(vertical scaling) 向上扩展，用更大容量资源替代(scaling up) 向下扩展，用更小容量资源替代(scaling down) 水平扩展 垂直扩展 更便宜(使用商品化的硬件组件) 更昂贵(专用服务器) IT资源立即可用 IT资源通常为立即可用 资源复制和自动扩展 通常需要额外设置 需要额外IT资源 不需要额外IT资源 不受硬件容量限制 受限于硬件最大容量 3.2.6 云服务 云服务(cloud service)指任何可以远程访问的云端IT资源。 云服务：可远程访问的Web服务 云服务：可远程访问的虚拟服务器 3.2.7 云服务用户 云服务用户(cloud service consumer)是一个运行时角色，由访问云服务的软件程序担任。 类型 软件程序、服务 工作站、便携机、移动设备 3.3 目标与收益 减低的投资与成比例的成本 提高的可扩展性 提高的可用性和可靠性 3.4 风险与挑战 增加的安全漏洞 降低的运营管控 云提供者间有限的可移植性 多地区合规问题 小结 互联网发展提供了良好的网络基础设施，网格计算促进了虚拟化和服务计算技术发展，为云计算发展奠定了基础； 云计算包括云服务、云用户、云服务用户等组成成分，云服务可以部署在企业外部或内部； 云计算可降低成本，提高扩展性、可用性和可靠性； 云计算会带来安全、管控、合规等风险和挑战。 第四章 基本概念与模型4.1 角色与边界4.1.1 云提供者 云提供者(cloud provider) 以云计算形式提供IT资源的组织机构 责任 提供符合SLA(Service-Level Agreement)的云服务 管理职责，保障合规 4.1.2 云用户 云用户(cloud consumer) 与云提供者签订合同使用其提供的IT资源的个人或机构 云用户使用云服务用户来访问云服务 4.1.3 云服务拥有者 云服务拥有者(cloud service owner) 云用户 云提供者(自有云服务) 4.1.4 云资源管理者 云资源管理者 是负责管理基于云的IT资源(包括云服务)的人或者组织。云资源管理者可以是(或者说属于)云服务所属的云的云用户或云提者。还一种可能性是，云资源管理者可以是(或者说属于)签订了合约来管理基于云的IT资源的第三方组织。 4.1.5 其他角色 云审计者(Cloud Auditor)——对云环境进行独立评估的第三方(通常是通过认证的)，承担的是云审计者的角色。这个角色的典型责任包括安全控制评估、隐私影响以及性能评估。云审计者这一角色的主要目的是提供对云环境的公平评价(和可能的背书)，帮助加强云用户和云提供者之间的信任关系。 云代理(Cloud Broker)——这个角色要承担管理和协商云用户和云提供者之间云服务使用的责任。云代理提供的仲裁服务包括服务调解、聚合和仲裁。 云运营商(Cloud Carrier)——负责提供云用户和云提供者之间的线路级连接。这个角色通常由网络和电信提供商担任。 4.1.6 组织边界 组织边界(organizational boundary)是一个物理范围，包括由一家组织拥有和管理的IT资源的集合。组织边界不表示组织实际的边界，只是该组织的IT资产和IT资源。类似地，云也有组织边界。 4.1.7 信任边界 信任边界(trust boundary)是一个逻辑范围，通常会跨越物理边界，表明IT资源受信任的程度。在分析云环境的时候，信任边界最常与作为云用户的组织发出的信任关联到一切。 4.2 云特征4.2.1 按需使用4.2.2 泛在接入4.2.3 多租户(和资源池)4.2.4 弹性4.2.5 可测量的使用4.2.6 可恢复性4.3 云交付模型4.3.1 基础设施作为服务(IaaS) IaaS 提供以基础设施为中心的IT资源(CPU、内存、硬盘、网络等) 通过基于云服务的接口或工具访问资源 资源是虚拟化的 云用户对资源完全控制，自主管理 4.3.2 平台作为服务(PaaS) PaaS 已经配置好的IT资源，是就绪可用(ready-to-use)环境。 包括全生命周期工具。 特点 免去维护裸设备的负担 云用户的控制级别较低 4.3.3 软件作为服务(SaaS) SaaS 以云服务形式提供软件程序 作为产品或通用工具提供 特点 云用户管理权限非常有限 可能是嵌套的云计算环境 4.3.4 云交付模型比较 4.3.5 云交付模型组合 IaaS + PaaS IaaS + PaaS + SaaS 4.4 云部署模型4.4.1 公有云 公有云(public cloud) 由第三方云提供者拥有的可公共访问的云环境。 4.4.2 社区云 社区云 类似公有云，但对其的访问限制在特定的云用户社区。 4.4.3 私有云 由一家组织单独拥有 属于企业内部的，具有高可管控性 一些安全问题和挑战不存在 4.4.4 混合云 由多个不同云部署模型组合而成 4.4.5 其他云部署模型 虚拟私有云(virtual private cloud)dedicated cloud,hosted cloud,托管专用云环境。 互联云(inter-cloud) 多个云连接组成 小结 云计算环境中的角色主要包括云提供者、云用户、云服务拥有者、云管理者； 云具有按需使用、多租户、弹性、可测量的特点； 云主要的交付模型有IaaS、PaaS、SaaS； 云的部署模型主要有公有云、社区云和私有云。 第五章 云使能技术5.1 宽带网络和Internet架构5.1.1 Internet服务提供者(ISP)5.1.2 无连接分组交换(数据报网络)5.1.3 基于路由器的互联5.1.4 技术和商业考量5.2 数据中心技术5.2.1 虚拟化 5.2.2 标准化与模块化 标准化商用硬件 模块化结构设计 可扩展 容易更换 经济性 5.2.3 自动化 配置自动化 监控自动化 升级自动化 恢复自动化 5.2.4 远程操作与管理 远程桌面 SSH 远程维护管理系统 5.2.5 高可用性 冗余 电源 布线 环控 集群 数据冗余 计算冗余 负载均衡 5.2.6 安全感知的设计、操作和管理 安全要求高 访问控制严 5.2.7 配套设施 电源 布线 环控 消防 专门系统 包括计算、存储网络等 5.2.8 计算硬件 机架式服务器 不同架构处理器X86、RISC 高密度处理单元 冗余热插拔组件 5.2.9 存储硬件 磁盘阵列 I/O高速缓存 热插拔硬盘 快速数据复制 存储虚拟化 NAS(Network Attached Storage) SAN(Storage Area Network) 5.2.10 网络硬件 外网 负载均衡网络 LAN光网络 SAN光网络 NAS网关 5.2.11 其他考量 异构设备混合复杂 安全关键性 单点故障 5.3 虚拟化技术5.3.1 硬件无关性 虚拟要对硬件进行： 转换 仿真 5.3.2 服务器整合 多台虚拟机整合、共享一台硬件服务器 提供硬件利用率 提供灵活性 是云计算的基础 5.3.3 资源复制 通过复制文件来复制机器 创建标准虚拟机 迁移部署灵活 支持回滚 高效备份恢复 5.3.4 基于操作系统的虚拟化 在一个操作系统管理下，通过虚拟化软件实现虚拟化。 虚拟机以普通应用的形式运行在宿主机操作系统之上。 优点：可以使用宿主机操作系统的一些功能。 缺点：多层结构的性能损失。 5.3.5 基于硬件的虚拟化 虚拟化软件(虚拟机管理程序Hypervisor)直接安装在物理机上。 优点：性能高 缺点：兼容性问题 5.3.6 虚拟化管理 虚拟化基础设施管理VIM(Virtualization Infrastructure Management) 集中统一管理 5.3.7 其他考量 虚拟化会增肌开销，不是所有情况都适合虚拟化 硬件兼容性问题存在 移植兼容问题存在 5.4 Web技术5.4.1 基本Web技术 组成 URL(Uniform Resource Locator) HTTP(Hypertext Transfer Protocol) HTML(Hypertext Markup Language) 组件 Httpd，CGI/JSP/ASP/PHP等 Browser，插件/控件/Javascript等 Tcp/ip网络 5.4.2 Web应用 5.5 多租户技术要解决好共享与隔离的问题。 共享 公共程序 公共模型 公共配置 公共数据 隔离 用户自定义配置 用户数据 用户行为 计费 5.6 服务技术SOA SOA(Service Oriented Architecture)是一个组件模型，它将应用程序的不同功能单元(称为服务)进行拆分，并通过这些服务之间定义良好的接口和协议联系起来。 接口是采用中立的方式进行定义的，它应该独立于实现服务的硬件平台、操作系统和编程语言。这使得构件在个各种各样的系统中的服务可以以一种统一和通用的方式进行交互。 CORBA、Web Service等是SOA的实例。 CORBA CORBA(Common Object Request Broker Architecture)是由OMG组织制订的一种标准的面向对象应用程序体系规范。或者说CORBA体系结构是OMG为解决分布式处理环境(DCE)中，硬件和软件系统的互连而提出的一种解决方案。 对象管理组织OMG是一个国际性的非盈利组织，其职责是为应用开发提供一个公共框架，制订工业指南和对象管理规范，加快对象技术的发展。 5.6.1 Web服务 包括 WSDL(Web Service Description Language) XML模式描述语言(XML schema definition language) SOAP(Simple Object Access Protocol) UDDI(Universal Description,Discovery and Integration) 5.6.2 REST服务 REST(Representational State Transfer)是一种软件架构风格，是一种针对网络应用的设计和开发方式，可以降低开发的复杂性，提高系统的可伸缩性。 REST是一组架构约束条件和原则，满足这些约束条件和原则的应用程序或设计就是RESTful。 在RESTful HTTP方式中，通过组成HTTP应用协议的通用接口访问服务程序，也就是使用标准的GET、PUT、POST和DELETE方法。 RESTful http://localhost:8080/myweb/getDogs –&gt; GET/rest/api/dogs 获取所有小狗狗 http://localhost:8080/myweb/addDogs –&gt; GET/rest/api/dogs 添加所有小狗狗 http://localhost:8080/myweb/updateDogs/:dog_id –&gt; PUT /rest/api/dogs/:dog_id 修改一个小狗狗 http://localhost:8080/myweb/deleteDogs/:dog_id –&gt; DELETE/rest/api/dogs/:dog_id 删除一个小狗狗 5.6.3 服务代理 拦截消息并处理 分类 主动代理 被动代理 5.6.4 服务中间件 MOM(Message Oriented Middleware) ESB(Enterprise Service Bus) 必备功能 路由 协议桥接 消息转换 服务代理托管 ESB扩展功能 资源适配器 可靠的消息传递 事件处理 交易的完整性管理 消息格式调解 负载均衡 消息验证 能力调解 小结 Internet是云计算的必要条件之一，宽带网络为云计算的集中模式提供了网络访问保障； 数据中心技术为云计算的集中模式提供了基础设施保障； 虚拟化技术为云计算的服务整合和资源复制提供了技术基础； Web及服务技术为云计算的互操作与普适访问提供了技术基础； 多租户技术使云计算的管理和经济效益得以实现。 第六章 基本云安全6.1 基本术语和概念6.1.1 保密性6.1.2 完整性6.1.3 真实性6.1.4 可用性6.1.5 威胁6.1.6 漏洞6.1.7 风险6.1.8 安全控制6.1.9 安全机制6.1.10 安全策略6.2 威胁作用者6.2.1 匿名攻击者6.2.2 恶意服务作用者6.2.3 授信的攻击者6.2.4 恶意的内部人员6.3 云安全威胁6.3.1 流量窃听6.3.2 恶意媒介6.3.3 拒绝服务6.3.4 授权不足(Insufficient Authorization)6.3.5 虚拟化攻击6.3.6 信任边界重叠6.4 其他考量6.4.1 有缺陷的实现6.4.2 安全策略不一致 云服务提供者的安全策略和机制与云用户的要求可能不一致，不兼容。 云服务提供者是真正的安全控制者 安全第三方问题 6.4.3 合约6.4.4 风险管理小结 机密、完整、可用(CIA)是云安全的基本要求。 威胁是伴随云资源价值的客观存在，云计算的漏洞将使云计算在安全威胁下面临安全风险，威胁方利用漏洞即可实施攻击。 安全策略定义安全规则；安全机制是具体的安全技术和措施，实现安全规则。 云计算的攻击者可能是内部人员、授信人员、恶意用户、匿名者。 云计算的安全威胁包括流量窃听、恶意媒介(数据篡改)、拒绝服务、授权不足(控制不足)、虚拟化攻击、信任边界重叠等。 使用云计算要做好风险管理。","raw":null,"content":null,"categories":[],"tags":[{"name":"复习","slug":"复习","permalink":"http://zehwakaka.github.io/tags/复习/"}]},{"title":"termux玩转","slug":"termux玩转","date":"2021-03-20T11:32:08.000Z","updated":"2021-03-20T11:32:10.000Z","comments":true,"path":"2021/03/20/termux玩转/","link":"","permalink":"http://zehwakaka.github.io/2021/03/20/termux玩转/","excerpt":"","text":"","raw":null,"content":null,"categories":[],"tags":[]},{"title":"人月神话阅读","slug":"人月神话阅读","date":"2021-03-20T11:29:24.000Z","updated":"2021-03-22T04:39:32.000Z","comments":true,"path":"2021/03/20/人月神话阅读/","link":"","permalink":"http://zehwakaka.github.io/2021/03/20/人月神话阅读/","excerpt":"","text":"第一章 焦油坑","raw":null,"content":null,"categories":[],"tags":[{"name":"阅读","slug":"阅读","permalink":"http://zehwakaka.github.io/tags/阅读/"}]},{"title":"欲买桂花同载酒","slug":"欲买桂花同载酒","date":"2021-03-17T17:01:10.000Z","updated":"2021-03-17T17:12:44.000Z","comments":true,"path":"2021/03/18/欲买桂花同载酒/","link":"","permalink":"http://zehwakaka.github.io/2021/03/18/欲买桂花同载酒/","excerpt":"","text":"欲买桂花同载酒，终不似，少年游。","raw":null,"content":null,"categories":[],"tags":[{"name":"感悟","slug":"感悟","permalink":"http://zehwakaka.github.io/tags/感悟/"}]},{"title":"图形学","slug":"图形学","date":"2021-03-15T01:44:01.000Z","updated":"2021-03-22T04:39:38.000Z","comments":true,"path":"2021/03/15/图形学/","link":"","permalink":"http://zehwakaka.github.io/2021/03/15/图形学/","excerpt":"","text":"李陶深老师课件，版权所有 第一章 计算机图形学基本概念 纲要 计算机图形学的基本概念 计算机图形学研究对象与内容 计算机图形学的发展历史 计算机图形学的应用与研究动态 1.1 计算机图形学的基本概念 —定义 wiki百科和百度百科的定义 计算机图形学（CG）是一种使用数学算法把二维或三维图形转化为计算机显示器的栅格形式的科学。简单地说，计算机图形学的主要研究内容就是研究如何在计算机中表示图形、以及利用计算机进行图形的计算、处理和显示的相关原理与算法。 IEEE的定义 计算机图形学就是在计算机的帮助下生成图形图像的一门科学或艺术 123456789101112//用计算机表示图形（合适的数据结构）//点：Point3D&#123; double x; double y; double z;&#125;//长方体：cuboid&#123; LCS3D local; double x; double y; double z;&#125; 用计算机生成图形： 将上述数据结构实例化（交互手段。。。） 用计算机处理图形： 图形变换、变形（位置，形状） 图形A-&gt;图形B 用计算机显示图形：将计算机内容存放的图形转化为人眼能否感知的数字图像。 图像： 绘制、摄影或印制的形象。 图形在媒介上的投影。 照片：镜子中的形象，屏幕上的形象 什么是计算机中的图形？ 计算机中的图形是指： 物体的轮廓、形状或外部的界限； 客观存在的物体（桌、椅、山、水、人） 是指由点、线、面、体等几何要素和明暗、灰度（亮度）、色彩等非几何要素构成的，从现实世界中抽象出来的带有灰度、色彩及形状的图或形。 1.1 计算机图形学的基本概念-目标 目标 核心目标：利用计算机绘画出具有真实感的图形。即实现视觉交流，通过图形或几何的方式来表示或展示一些问题或信息。 视觉交流的过程 观察-&gt;问题：通过观察、思考，明确问题或要传达的信息； 问题-&gt;几何：通过建立几何模型表达问题； 几何-&gt;图像：由几何模型生成图像，将问题或信息可视化。 1.1 计算机图形学的基本概念-任务 基本任务 表示：将客观世界用二维或三维的方式表示。 绘制：如何将计算机中的对象用一种直观形象的图形图像方式表现出来。 交互：通过计算机输入、输出设备，以有效的方式实现表示与绘制的技术。 1.1 计算机图形学的基本概念-相关学科 计算机图形学（CG）试图从非图像形式的数据描述来生成（逼真的）图像。 数字图像处理旨在对图像进行各种加工以改善图像的视觉效果。主要研究对客观世界中已经存在的物体映像处理成新的数字化图像，如医学图像处理、卫星遥感图像处理、照相图像处理等。 模式识别：主要研究如何分析和识别各种图像，找出其中图形数据蕴含的内在联系或构建图像的抽象模型。如高速公路上的车辆拍照的识别、人脸部的识别、数字水印等。 计算几何：研究几何模型和数据处理的学科，探讨几何形体的计算机表示、分析和综合。 1.2 计算机图形学研究对象与内容-研究对象 图形的要素： 几何要素和非几何要素 计算机图形学中所研究的图形 从客观世界物体中抽象出来的带有颜色及形状信息的图和形。 1.2 计算机图形学研究对象与内容-图形表示 点阵法是用具有颜色信息的点阵来表示图形的一种方法，它强调图形由哪些点组成，并具有什么灰度或色彩。 参数法是以计算机中所记录图形的形状参数与属性参数来表示图形的一种方法。 通常把参数法描述的图形叫做图形 把点阵法描述的图形叫做图像 Pixels（像素）：像素是计算机屏幕用来显示图象的最小单位 Resolution：分辨率 分辨率指屏幕或打印的图像上的点的目睹，分辨率越高，图越清晰。 分辨率用DPI度量 Pixel Depth（像素位数，颜色位数，颜色深度） —Pixel Depth（Color Depth）每个像素点的bit数 Pixel Depth越大，每个像素点的颜色越丰富 彩色图像的效果取决于分辨率 Pixel Depth越大，图像文件越大 用计算机显示图形： 计算机：图形————————————————–&gt;图像 ​ 显示 Display，rendering 本质： 图像：颜色值（RGB），没有物体的概念。 图形：物体（形状、外表属性、。。。。。） 客观世界：物体———————————————-&gt;视觉形像 ​ 光线刺激视网膜-&gt;神经感知 基本点：用计算机表示、生成、处理和显示图形。 1.2 计算机图形学研究对象与内容-内容体系 基础模块 软、硬件基础知识：常见图形API如OpenGL、Direct3D等，图形输出设备与输出技术的简单基础知识，如光栅显示器基本原理、颜色处理与颜色模型等。 数学基础： 微积分、线性代数、矩阵计算、微分几何、数值计算和分析、计算方法、偏微分方程、微分方程数值解、最优化、概率、统计、计算几何等。其中重要的：向量、矩阵、齐次坐标和几何变换等。 “数学不是没有用，而是不够用！” 对数学的学习和应用将是“活到老，学到老”。 建模与表示模块 概念：研究如何用图形方式表示现实或虚拟世界中的对象与信息。 表示：模型在外部显示上通常以点、线、面、体等各种几何元素及它们的组合来表现，而在计算机内部则是通过坐标、连接关系所对应的几何信息与拓扑信息来表示。 绘制模块 概念：将计算机中对象的数字几何模型转换为直观形象的图形或图像形式，是数字几何模型的视觉可视化过程。 绘制过程: 应用程序（获得图元信息） 几何处理（裁剪，坐标变换） 像素处理 交互模块 概念：针对图形对象，研究合适的输入方法、操作方法，也即友好的人机界面。 交互技术 典型的人机交互技术：定位技术、菜单技术、拾取技术、定值技术、橡皮筋技术、拖拽技术、网格与捕捉技术等 图形用户界面：window窗口，icon图标，menu菜单，pointers指标 CG的主要研究内容有：建模、渲染、动画和人机交互 建模（modeling） 要在计算机中表示一个三维物体，首先要有它的几何模型表达。因此，三维模型的建模是计算机图形学的基础，是其他内容的前提。表达一个几何物体可以是用数学上的样条函数或隐式函数来表达；也可以是用光滑曲面上的采样点及其连接关系所表达的三角网格来表达（即连续曲面的分片线性逼近）。 常用的三维建模方法有：NURBS（非均匀有理B-样条、Bezier曲线曲面）方法（已成为CAD工业领域的标准）、细分曲面造型方法、利用软件的直接手工建模的方法、基于笔划或草图交互方式的三维建模方法、基于语法及规则的过程式建模方法、基于图像或视频的建模方法、基于扫描点云（深度图像如Kinect、结构光扫描、激光扫描、LiDAR扫描等）的建模方法、基于现有模型来合成建模的方法，等等。 渲染 有了三维模型或场景，怎么把这些三维几何模型画出来，产生令人赏心悦目的真实感图像？这就是传统的计算机图形学的核心任务。现在的渲染技术已经能够将各种物体，包括皮肤、树木、花草、水、烟雾、毛发等渲染得非常逼真。一些商业化软件也提供了强大的真实感渲染功能。 人机交互 人机交互是指人与计算机之间以一定的交互方式或交互界面，来完成确定任务的人与计算机之间的信息交换过程。简单来讲，就是人如何通过一定的交互方式告诉计算机来完成他所希望完成的任务。 近年来，以用户为中心的系统设计思想，增进人机交互的自然性，提高人机交互的效率是用户界面的主要研究方向。陆续提出了多通道用户界面的思想，它包括语言、姿势输入、头部跟踪、视觉跟踪、立体显示、三维交互技术、感觉反馈及自然语言界面等。 1.3 计算机图形学的发展历史 20世纪50年代（酝酿期） 1950年，美国麻省理工学院（MIT）的旋风1号计算机配备了阴极射线管（CRT）来显示一些简单的图形。 20世纪60年代（萌芽期） 1962年，MIT林肯实验室的I.E.Sutherland发表了一篇题为“Sketchpad：一个人机交互通信的图形系统”的博士论文 1962年，雷诺汽车公司的工程师Pierre Bezier提出Bezier曲线、曲面的理论 1964年MIT的教授Steven A.Coons提出了超限插值的新思想，通过插值四条任意的边界曲线来构造曲面。 20世纪70年代（发展期） 光栅图形学迅速发展 区域填充、裁剪、消隐等基本图形概念、及其相应算法纷纷诞生 图形软件标准化 1974年，ACM SIGGRAPH的“与机器无关的图形技术”的工作会议 ACM成立图形标准化委员会，制定“核心图形系统”（Core Graphics System） ISO发布CGI、CGM、GKS、PHIGS 20世纪70年代（发展期） 真实感图形学 1970年，Bouknight提出了第一个光反射模型 1971年Gourand提出了“漫反射模型+插值”的思想，被称为Gourand明暗处理 1975年，Phong提出了著名的简单光照模型-Phong模型 实体造型技术 英国剑桥大小CAD小组的Build系统 美国罗切斯特大学的PADL-1系统 20世纪80年代（普及期） 1980年Whitted提出了一个光透视模型-Whitted模型，并第一次给出光线跟踪算法的范例，实现Whitted模型 1984年，美国Cornell大学和日本广岛大小的学者分别将热辐射工程中的辐射度方法引入到计算机图形学中 图形硬件和各个分支均在这个时期飞速发展 10世纪90年代（提高增强期） 标准化、集成化、智能化方向发展。 近二十年中，国际标准化组织ISO已经批准和正在讨论的与计算机图形有关的标准有： GKS、GKS-3D、PHIGS、CGM、CGI、IGES、STEP 事实标准： SGI的OpenGL,微软的Direct X，Adobe的Postscript等。 技术发展历程 诞生：1950—1960 线框图形学：1960—1970 光栅图形学：1970—1980 真实感图形学：1980—1990 实时图形学：1990—至今 1.4 计算机图形学应用与研究动态-应用 （1）计算机辅助设计与制造（CAD/CAM） CAD/CAM是计算机图形学在工业界最广泛、最活跃的应用领域。 二维图形（AutoCAD）-&gt;三维造型（CAE、CAM） 应用CAD系统进行设计：1）获得产品的精确表示和显示结果，2）在计算机中建立对象的数据模型，3）进行各种性能分析计算，4）对设计做修改，5）制造过程和设计结果联系起来，设计结果直接传送至后续工艺进行加工。 计算机辅助设计（CAD）已广泛应用于飞机、汽车、船舶的外形设计、电路设计，以及建筑、服装、印染、玩具设计等领域。CAD技术使得工程、产品设计和施工涂兆不必再由人工绘制，可大大缩短设计周期。 （2）计算机动画与艺术 动画Animation：利用图像序列，产生物体运动的视觉效果的一种技术。动画片大闹天宫、哪吒脑海、龙猫。 动画大师John Halas所讲的，运动是动画的要素。 视觉暂留原理：人的眼睛看到一幅画或一个物体后，在0.34秒内不会消失。 利用视觉暂留原理，在一幅画还没有消失前播放下一副画，就会给人造成一种流畅的视觉变化效果。 计算机动画中的运动 景物大小和形状的变化 景物位置、方向的变化 景物表面纹理、色彩的变化 虚拟摄像机的运动 （3）计算机艺术 利用图像序列，产生物体运动的视觉效果的一种技术。 （4）可视化 科学计算可视化：科学计算可视化就是利用计算机图形生成技术，将科学及工程计算中的计算数据和测量数据等以图形的形式显示出来，使人们能观察到用常规手段难以观察到的自然规律和自然现象。 分析计算可视化 既可用二维曲线图表和三维模型，也有彩色高维几何表示 医学可视化 （5）虚拟现实Virtual reality：是指由计算机实时生成一个虚拟的三维空间。用户可在其中自由的运动，随意观察周围的景物，通过一些特殊的设备与虚拟物体进行交互操作。在此环境中，用户看到的是全立体彩色景象，听到的是虚拟环境中的声响，手或脚可以感受到虚拟环境所反馈给它的作用了，从而使用户产生一种身临其境的感觉。 虚拟现实的技术要点： 沉浸（Immersion）：全方位投入，使用户产生身临其境的感觉。 交互（Interaction）：相应用户的各种输入手势、语言命令以及身体动作。 构想（Imaginnation）：生动形象地反映设计者的思想。 虚拟现实的关键技术： 能以实时的速度生成有逼真感的景物图形。 能高精度的跟踪用户的头和手。 头戴显示器能产生高分辨率图象和较大的视角。 能对用户的动作产生力反馈。 虚拟现实—沉浸式系统CAVE （5）虚拟现实Virtual reality：飞行等模拟训练 虚拟现实Virtual reality：虚拟装配。 （5）计算机模拟与仿真 计算机模拟和仿真是利用计算机产生真实（虚拟）场景，模拟场景中对象随时间变化的行为和规律。通过虚拟对象的行为和规律，研究液体流动、热流、核反应、结构有负载时的变形、复杂产品的加工过程和大工程的完工后的效果等。 （6）游戏：目前图形硬件发展的动力所在。 游戏引擎是指一些已编写好的可编辑计算机游戏系统或者一些交互式实时图像应用程序的核心组件。 为游戏设计者提供各种编写游戏所需的各种工具，其目的在于让游戏设计者能容易和快速地做出有效程式而不用由零开始。 渲染引擎（即“渲染器”，含二维图像引擎和三维图像引擎）、物理引擎、碰撞检测系统、音效、脚本引擎、电脑动画、人工智能、网络引擎以及场景管理 游戏引擎的一些功能。 光影效果：场景中的光源对处于其中的人和物的影响方式 动画：骨骼动画系统和模型动画系统 物理系统：使物体的运动遵循固定的规律 碰撞检测是物理系统的核心部分，它可以探测游戏中各物体的物理边缘 渲染：把模型、动画、光影、特效等所有效果实时计算出来并展示在屏幕上 交互 （7）用户图像界面：图文形式相结合的用户图形界面，大大改善了计算机交互操作的用户界面，开辟了计算机应用的很多新领域。 1.4 计算机图形学应用与研究动态-研究热点 真实感图形实时绘制 物体网格模型的面片简化：对网格面片表示的模型，在一定误差的精度范围内，删除带你、边、面，从而简化所绘制场景的复杂层度，加快图形绘制速度 基于图象的绘制：完全掘弃传统的先建模，然后确定光源的绘制的方法。它直接从一系列已知的图象中生成未知视角的图象，适用于野外极其复杂场景的生成和漫游 野外自然景物的模拟 野外场景远远复杂于室内场景，绘制难度更大，方法更趋多样化。 主要绘制山、水、云、树、草、火等等。 绘制火的粒子系统，基于生理模型的绘制植物的方法，绘制云的细胞自动机方法等 第二章 计算机图形系统简介纲要 计算机图形系统功能结构 图形硬件系统 图形软件系统 OpenGL简介（自学） 2.1 计算机图形系统功能结构 一个计算机图形系统至少应具有计算、存储、输入、输出和交互等基本功能，各功能之间的关系。 计算功能 （1）图形的描述、分析和设计 （2）点、线（包括直线和曲线）、面（包括平面和曲面）的表示及其求交、分类（用于图形的集合运算）； （3）图形的平移、旋转、投影、透视等几何变换； （4）曲线、曲面的生成； （5）图形的交点、交线、交面的计算； （6）光、色模型的建立和计算 （7）图形之间相互关系的检测等。 存储功能 在计算机的内存、外存中能存放各种图形数据，尤其是各种图形的几何数据及图形之间的相互关系以及各种属性信息，并可基于设计人员的要求快速方便地实现对有关信息的实时检索和对图形的删除、增加、修改等操作。 输入功能 通过图形输入设备将基本的图形数据（如点、线等），图形的形状、尺寸，必要的参数和各种绘图命令输入到计算机中，从而构造更复杂的几何图形。其中约束条件、属性参数都是必不可少的。 输出功能 图形系统应具有文字、图形、图像信息的输出功能，以方便长期保存分析计算的结果或交互需要的图形和非图形信息。根据对输出结果的精度、形式和时间等的不同要求，相应的有多种不同的输出设备。 交互功能 设计人员可通过显示器或其他人机交互设备直接进行人机通信，通过观察屏幕上显示的计算结果和图形，利用旋转、定位等手段对不满意的部分进行修改。另外，可以由系统追溯到以前的工作步骤，跟踪检索出出错的地方，同时对设计者或操作员输入的错误给以必要的提示和帮助。 2.2 图形硬件系统-输入设备 常用的图形输入设备：鼠标、键盘、光笔、触摸屏、操纵杆、跟踪球和空间求、数据手套、数字化仪、扫描仪、音视频系统等。 键盘 图形系统的字母数字键盘是原始的文本串输入工具， 可以进行屏幕坐标的输入、菜单选择和图形功能选择。 键盘设备最重要的功能特征是它产生一个和按下的键唯一对应的码（如ASCII）。 通用键盘都包含光标控制键和功能键。前者用来选择被显示的对象或通过定位屏幕光标来确定坐标位置，后者允许用户以单一击键的方式输入常用的操作。 键盘中还常常包含数字键盒，用来快速输入数字数据。 鼠标 鼠标是给屏幕光标定位的小型手持设备，它在平面上的相对移动可以测量出来。 鼠标通常有一个、两个或三个按钮，用来给出某些操作的执行信号。 机械鼠标底部滑轮的移动被转换成用于确定移动方向和数量的数字值。光学鼠标在专门的鼠标衬板上交替着亮线和暗线的网格，鼠标移动时，每次穿过安县，反射光线都会被中断，产生的脉冲数量和穿过的暗线数量相等，用来向计算机报告鼠标的移动。 鼠标是相对设备，可以在某一位置拿起，移动，然后再在另一位置放下，而不改变所报告的位置，因而鼠标可用作屏幕光标位置的相对变化。 光笔 光笔的笔尖处开有一个圆孔，荧光屏的光通过这个孔进入光笔。光笔的头部有一个透镜组，把所收集的光聚集至光导纤维的一个端面上，光导纤维再把光引至光笔另一端的光电倍增管，从而将光信号转换成电信号，经过整形后输出一个有合适信噪比的逻辑电平，并作为中断信号送给计算机和显示器的显示控制器。 数字化仪 是一种再物体上绘画、着色或交互选择坐标位置的常用设备，可用来输入二维或三维空间的坐标值，是一种把图形转变为计算机能接受的数字形式的专用设备。 数字化仪工作原理：采用电磁感应技术。在一块布满金属栅格的绝缘平面板上放置一个可移动的定位设备，当电流通过该定位设备上的电感线圈时，会产生相应的磁场，使其正下方的金属栅格上产生相应的感应电流。根据已产生电流的金属栅格的位置，判断出定位设备当前所处的坐标位置。这种位置信息传送给计算机，就实现了图形的数字化。 手写输入板：是一种最常见的定位设备。可以和CRT图形显示器一起使用，也可以单独使用，后者中的输入板就是通常所说的数字化仪。 手写输入板工作原理：输入板由一平板和一支触笔或游标组成，出版用来失去输入板表面的位置坐标。通常，触笔对输入板的接近也可以感知到。当和CRT一起使用时，CRT的反馈是一个称为光标的小跟踪符号，它能跟随触笔在输入板上的运动而运动。当单独作为数字化仪使用时，反馈信息就是读出的数字。 输入板一般给出二维坐标信息。返回的坐标是以输入板坐标的形式给出的，再由软件将输入板坐标转换成用户坐标系或世界坐标系的坐标。 手写输入板多用于交互设计，使用时大多划出一个图形区，其余部分放置菜单，称为菜单区。图形区与显示屏之间存在着一种映射关系，这种映射关系是用专门软件一次性自动建立起来的。一旦建立了这种关系，屏幕光标将随触笔或游标的移动而移动，如果移出了图形区范围，屏幕光标将随之消失。 扫描仪：是直接把图形（如工程图纸）和图像（如照片、广告画等）扫描并输入到计算机中，以像素信息进行存储表示的设备。 按采用的固体器件分类，可分为电荷耦合器件（CCD）扫描仪MOS电路扫描仪、紧贴型（CIS）扫描仪三种。、 触摸屏：触摸屏允许用手指触摸屏幕显示的物体或位置来实现选择操作。一般有一个与屏幕尺寸相仿的框架，在水平和垂直边框上安装了许多发光器和光检测器。任何东西，如手指，只要隔断了两根垂直光线就会产生一对X、Y坐标。 真实物体的三维信息的输入：在实际的产生过程中许多零件和样板要进行大规模的生产就必须在计算机中生成三维实体模型，优势这个模型要通过已有的实物零件得到，这时候就需要一种设备来采集实物表面各个点的位置信息。一般的方法是通过激光扫描来实现。这项技术的一个应用就是扫描保存古代名贵的雕塑和其它艺术品的三维信息（右图为美国Marc Levoy小组的扫描雕塑作品的工作现场）。 新的输入设备——数字墨水：作为一种新的人机界面技术，是自鼠标问世以来最重大的人机交流模式的转变。它充分利用了书写的自然性和墨水丰富的表达能力，将个人计算机强大的计算和处理能力以及纸的易用性结合起来，成为一种以人为中心的技术。 新的输入设备——数字手套：数据手套可以测量手指的三维位置和运动，并传送给计算机，复杂的数据手套还可以测量肘和腕的运动。数据手套可包含控制按钮，可作为输出设备，能够指向、握紧或推动物体，可用在虚拟现实系统中。 新的输入设备——三维鼠标：三维鼠标（3D Mouse）属于三维输入设备，是三维空间控制器的一种。它可以拾取一个对象，使之旋转并按任意方向移动，或者通过三维场景来控制观察位置和方向。 三维鼠标产生的空间位置是相对的，多用于虚拟现实系统、CAD和动画中。 新的输入设备——声音系统：声音系统在图形工作站中用于图形操作的初始化或输入数据，工作原理是使输入与预先定义的字和词组的词典相匹配。 词典是为特定的操作员建立的，通过由该操作员讲述该系统所用命令来建立。 声音一般通过麦克风输入，它可将周围其它背景声音的输入将为最小。 若不同的操作员使用该系统，则必须按照新操作员的声音模式重建字典。 声音系统的优点在于输入命令时，操作员的注意力不必从一个设备切换到另一个设备。 图形输出包括图形的显示和图形的绘制。 图形显示指的是在屏幕上输出图形； 图形绘制通常指把图形画在纸上，也称硬拷贝，打印机和绘图仪是两种最常用的硬拷贝设备。 CRT：CRT显示器主要由阴极、电平控制器（即控制极）、聚焦系统、加速系统、偏转系统和阳极荧光粉涂层组成，这6部分都在真空管内。 工作原理：高速的电子束由电子枪发出，经过聚焦系统、加速系统和磁偏转系统就会到达荧光屏的特定位置。荧光物质在高速电子的轰击下发出荧光，屏幕上的那一点就会亮了。 阴极被灯丝加热后，会发出电子（带负电荷）并形成发散的电子云（由于电子带同种电荷相互排斥而形成）。在CRT表面的内侧是阳极（实际上是与加速极连通的CRT屏幕内测的石墨粉涂层）的吸引轰击荧光粉涂层时，将漫射整个荧光屏，形成明亮的白光。但是在聚焦系统的作用下，电子云会聚焦成很细的电子束，在荧光屏的中心形成一个单一的亮点。亮点持续发光的时间一般在毫秒或微秒数量级之间，所以要保持显示一幅稳定的画面，必须不断地发射电子束。 电平控制器用来控制电子束的强弱，加正电压时，电子束会大量通过，在屏幕上形成较亮的点，加负电压时，依据所加电压的大小，电子束被部分或全部阻截，通过的电子很少，屏幕上的点也就比较暗。所以改变阴极和控制电平之间的电位差，就可调节电子束的电流密度，改变所形成亮点的明暗程度。 聚焦后的电子束通过加速系统达到轰击荧光屏应有的速度后，利用偏转系统（包括水平方向和垂直方向的偏转板）可将电子束精确定位在屏幕的任意位置上。到达屏幕最边缘的偏转角度被称为最大偏转交。屏幕越大，要求的最大偏转角度就越大。但是磁偏转系统的最大偏转角度有限，为达到大屏幕的要求，只能将显像管加长。 必须不断地发射电子束，才能保持荧光屏上由稳定的图像。 刷新一次指电子束从上到下将荧光屏扫描一次。 刷新频率高到一定值后，图像才能稳定显示。大约达到每秒60帧即60Hz时，人眼才能感觉到屏幕不闪烁。 要有85Hz以上的刷新频率。 每一帧分为两个场显示，每个场只包含一半画面。两个场是交错的，一个场包含所有的奇数扫描行，另一个场包含所有的偶数扫描行，两个场以1/60秒的时间间隔交替显示。 扫描从奇数场左上角开始，每一行的扫描方向都是自左向右。电子束在横向扫描的同时以一个较低的速率向下移动，当电子束到达屏幕右端时，就将其隐去并迅速返回屏幕左端，这个过程称为水平回扫。接着下一奇数行重复这一过程。 接着进行偶数场扫描，偶数场扫描结束于屏幕右下角，垂直回扫后电子束返回屏幕左上角。 彩色CRT的显示原理 彩色CRT显示器的荧光屏上涂有三种荧光物质，分别能发红、绿、蓝三种颜色的光，而三个电子枪（每个电子枪都由一个加热器、一个金属阴极和一个电平控制器组成）也发出三束电子束来激发这三种物质。电子枪通常成三角形排列，与CRT屏幕上的三角形红、绿、蓝荧光点相对应。 荫罩式显示器 电子枪和对应的荧光点必须在一条直线上。为保证每个电子枪都能击中对应颜色的荧光点，在电子枪和荧光屏之间放置一个有孔的金属控制网格（即荫罩）。控制网格与荧光点排列成相同的三角形或直线型。调整彩色电子枪的排布方式可让三个电子束都汇聚于荫罩上。这样，某颜色的电子束通过荫罩后，就可避免和另外两种颜色的荧光点相交，而只与自己对应颜色的荧光点相交。 荫栅式显示器 荫栅式显象管的红、绿、蓝三色荧光点在屏幕上呈垂直条形排列，并将荫罩网改为条状荫栅由固定在一个拉力极大的铁框中的互相平行的垂直铁线阵列组成，且整个栅栏从屏幕顶一直通到屏幕底。电子枪发出的三个电子束穿过栅条打在荧光条上使其发光。 荫罩式与荫栅式的区别 从原理来说，荫罩式显示器和荫栅栏式显示器只是射线的选择方式和荧光点的排列不同而已。 从显示效果来说，荫栅式显示器和荫栅可以透过更多的光线，从而可以达到更高的亮度和对比度，令图像色彩更加鲜艳、逼真和自然；另外，其栅距经过长时间使用也不会改变，就算使用多年也不会出现画质的下降。 CRT固有的物理结构限制了它向更广的显示领域发展。 屏幕的加大必然导致显象管的加长，显示器的体积必然要加大，在使用时候就会受到空间的限制。 CRT显示器是利用电子枪发射电子束来产生图像，容易受电磁波干扰。 长期电磁辐射会对人们健康产生不良影响。 2.2 图形硬件系统-液晶显示器 20世纪80年代中期产生了平板显示器，如液晶显示器和等离子显示器等。 液晶即液态晶体，是一种介于固态和液态之间，具有线状结晶结构的分子及规则性分子排列的有机化合物，可像液体那样流动。 液晶分子的排列柔软易变形，受电场、磁场、温度和应力等外部条件作用时会重新排列。 液晶显示器（LCD）的原理是利用液晶的物理特性，通电时导通，晶体在电场作用下，排列变得有秩序，通过它的光折射角度会发生变化，使光线容易通过；不通电时，晶体排列变得混乱，光被遮挡，不能通过。 将液晶置于两片导电玻璃之间，靠两个电极间电场的驱动，引起液晶分子扭曲的电场效应，以控制光源投射或遮蔽功能，在电源开关之间产生明暗而将影像显示出来，若加上彩色滤光片，则可显示彩色影像。 LCD显示器的工作原理 液晶是一种介于液体和固体之间的特殊物质，它具有液体的流态性质和固体的光学性质。当液晶受到电压的影响时，就会改变它的物理性质而发生形变，此时通过它的光的折射角度就会发生变化，而产生色彩 液晶屏幕后面有一个背光，这个光源先穿过第一层偏光板，再来到液晶体上，而当光线透过液晶体时，就会产生光线的色泽改变，从液晶体射出来的光线，还得必须经过一块色彩滤光片以及第二块偏光板。 LDC显示器有主动式和被动式两种、 被动式液晶屏幕有STN和DSTN等。最流行的主动式液晶屏幕是TFT 主动式液晶显示器使用了FET场效晶体管以及共通电极，这样可以让液晶体在下一次的电压改变前一直保持电位状态。这样主动式液晶显示器就不会产生在被动式液晶显示器中常见的鬼影、或是画面延迟的残像等 LDC显示器的主要指标 可视角度：视线与屏幕中心法向成一定角度时，人们就不能清晰地看到屏幕图象，而那个能看到清晰图象的最大角度被我们称为可视角度是指左右两边的最大角度相加。工业上有CR10、CR5两种标准来判断液晶显示器的可视角度 点矩与分辨率：液晶屏幕的点矩就是两个液晶颗粒（光电）之间的距离，一般0.28~0.32mm就能得到较好的显示效果。通常所说的液晶显示器的分辨率是指其真实分辨率，表示水平方向的像素点数与垂直方向的像素点数的乘积。 LCD显示器的优点：工作电压地、功耗小；无辐射，对人体健康无损害，且利于信息保密；完全平面，无闪烁、无失真，可视面积大，又薄又轻，能大量节省空间，适应更多的应用领域；易于色彩化，因为在色谱上可以非常准确的复现；抗干扰能力也比CRT显示器强得多。 LCD显示器的缺点：视角太小、亮度和对比度不够大。可视角是指站在始于屏幕法线的某个角度的位置时仍可清晰看见屏幕图像所构成的最大角度，对显示器来说，可视角愈大愈好。 等离子显示器的原理 等离子显示器是一种利用气体放电的显示装置，由晶格矩阵（光栅）组成，每个晶格充有低压气体。 在高压电作用下，气体会电离解，即电子从原子中游离出来。电离解后的气体称为等离子体，所以将这种显示器称为等离子显示器。当电子又重新与原子结合在一起时，能量就会以光子的形式释放出来，这时气体就会释放出具有特征的橙红色辉光。 等离子显示器类型：交流（AC）激发的、直流（DC）激发的、交直流（AC/DC）混合激发的。 要点亮某个地址的气泡，开始要在相应行上加较高的电压，等该气泡点亮后，可用电压维持气泡的亮度。要关掉某个气泡，只需将相应的电压降低。 交流激发的等离子显示器 电介质层夹在导体和气体中间，气体和导体之间的点耦合是电容性的，要用交流电压离解气体。 使用双稳态存储器，无须连续刷新屏幕。 混合式等离子显示器 用交流电激活像素前先用直流电压激活气体，这样气体更容易被交流电压激活。 省去了驱动电路，使制造大尺寸高分辨率的等离子显示器成为可能。 等离子显示器的特点 优点：重量较轻、完全无X射线辐射；屏幕亮度非常均匀，不存在明显的亮区和暗区；对比度高，可达到500:1;各个发光单元的结构完全相同，不会出现某些区域聚焦不良或因使用时间过长出现散焦的毛病；屏幕更平展，图像无扭曲变形；具有良好的防电磁干扰功能；散热性能浩，无噪音困扰；具有超宽视角，可达到60英寸。 缺点：价格较高，显示屏上的玻璃较薄，屏幕较脆弱。 2.2 图形硬件系统-未来显示器 发光聚合物技术，坚不可摧；柔韧性浩，可以卷起来（柔性显示屏，石墨烯显示屏） 2.2 图形硬件系统- 三维显示器 显示具立体感的视图 利用不同的刷新周期交替地显示两视图； 将屏幕分半； 使用头盔式结构。 2.2 图形硬件系统- 三维观察设备 IO2公司的“Heliodisplay”气体投影系统 2.2 图形硬件系统-图形显示子系统 光栅扫描式的图形显示器 是画点设备，可看成一个点阵单元发生器，并可控制每个点阵单元的亮度。 发出的电子束的偏转方式是固定的，自上而下，从左到右扫描在荧光屏上形成光栅形状。 图形是通过电子束扫描到光栅上的图形像素点时呈现的亮度或颜色与光栅背景的亮度或颜色不同而衬托出的，可形成多级灰度或颜色的实面积自然图像。 由于图像是由像素阵列组成，显示一幅图像所需的时间等于显示整个光栅所需的时间，而与图像的复杂程度无关。 点矩： 荫栅式显示器：也称栅距，是指显示器平行的光栅之间的距离，一般都在0.25mm以下 荫罩式显示器：指屏幕上两个相邻的相同颜色荧光点之间的对角线距离（或水平距离），称为对角点距（或水平点距）。 屏幕大小一定的前提下，点（栅）距越小，则屏幕上的像素就越清晰细腻。显然，荫栅式显象管比荫罩式的要精细的多。 光栅扫描式的图形显示器 是画点设备，可看成一个点阵单元发生器，并可控制每个点阵单元的亮度。 发出的电子束偏转方式是固定的，至上而下，从左到右扫描在荧光屏上形成光栅形状。 图形是通过电子束扫描到光栅上的图形像素点时呈现的亮度或颜色与光栅背景的亮度或颜色不同而衬托出的，可形成多级灰度或颜色的实面积自然图像。 由于图像是像素阵列组成，显示一幅图像所需的时间等于显示整个光栅所需的时间，而与图像的复杂程度无关。 光栅扫描式的图形显示器 一般在像素矩阵中不能直接从一个点到另一个点（或一个像素到另一个像素）画一条笔直的直线，但可以用一系列的点（或像素）来近似地表示这条直线。显然，只有画水平、垂直或正方形的对角线时，才能用点或像素画出一条真正的直线，其他情况下的直线均呈阶梯状，这种现象称为走样或锯齿。 光栅扫描式的图形显示器——帧缓冲存储器（帧缓存） 实现光栅CRT图形显示器的最常见方法是使用帧缓存。 帧缓存是一块连续的存储空间。 光栅中的每个像素在帧缓存中至少要有1位（bit），每个像素1位的存储容量称为位面（bit plane）。画面就是由帧缓存中的这些位信息组成的。 图形在计算机中是一位一位产生的，每一个存储位只有0或1两个状态，则一个位面的帧缓存只能产生黑白图形。 光栅扫描式的图形显示器——帧缓冲存储器（帧缓存） 帧缓存是数字设备，光栅显示器是模拟设备，要把帧缓冲中的信息在光栅显示器屏幕上输出，必须进过数字/模拟转换，这个工作由DAC（数/模转换器）完成。 如果增加帧缓存的位面数，光栅显示器可以表示彩色或不同的灰度等级。 显示器上每个像素的亮度由它在各个位面中对应额值共同决定，把各个位面上与当前像素对应的0，1值读入寄存器相应的位，最终得到的二进制数就是像素的灰度等级，其范围在0—2的n次方-1之间。 为避免帧缓存的增加，可使用颜色查找表来获得更多的灰度的级别，下表是三个帧缓存位面对应的颜色表。从帧缓存位面中读出的数是颜色查找表的索引，通过该索引值从颜色表中取得真正的颜色值。 颜色查找表必须有2N项，每一项具有W位字宽。当W大于N时，可以有2W个灰度等级，但一次只能同时使用其中的2N个。如果要使用2N种以外的灰度等级，需要改变颜色查找表中的内容。下图中，W=4，N=3，通过设置颜色查找表可以产生16种灰度。 由于只有三种原色，所以可以用三个位面实现一个简单的彩色帧缓冲存储器。下图为简单的彩色帧缓冲存储器。下图为简单的彩色光栅显示器，由分别对应红（R）、绿（G）、蓝（B）三原色的三个位面的帧缓存、DAC，三个电子枪和CRT光栅组成。 可通过增加每个颜色的电子枪所对应的帧缓存位面，来提高颜色种类的灰度等级。如下图，每种原色电子枪有8个位面的帧缓存和8位的DAC，每种原色有29种灰度等级，三种原色的组合有224种颜色。这种显示器称为全色光栅扫描图形显示器，其帧缓存称为全色缓存。 若各组位面存放的不是直接的颜色值而是颜色查找表的地址索引，则全色帧缓存的颜色还可进一步丰富。 光栅扫描式的图形显示器——主要性能参数 分辨率：指显示器在屏幕水平（垂直）方向可显示多少像素。分辨率越高，显示的字符或图像越清晰。 刷新频率：即屏幕刷新的速度。刷新频率越低，图像闪烁和抖动的就越厉害，眼睛疲劳的就越快。过低的刷新频率，会产生令人难受的频闪效应。 水平扫描频率：又称为行频，是指电子枪每秒在屏幕上扫描过的水平点数，以KHz为单位。行频越大越好，至少要达到50KHz。 亮度等级数目和色彩：亮度等级数目主要指单种颜色亮度可变化的数目，亮度等级范围的提升可以使图像看上去更加柔和自然。色彩包括可选择显示颜色的数目以及一帧画面可同时显示的颜色数，与荧光屏的质量有关，并受显示存储器VRAM大小的影响。 点矩：指同一像素中两个颜色相近的荧光体间的距离，与图像分辨率有关。点矩越小，显示出来的图像越细腻，当然其成本也越高。 显示速度：显示字母、图像，特别是动态图像的速度，与显示器的分辨率及扫描频率有关。可用最大带宽（即水平像素数*垂直像素数*最大刷新频率）来表示。 喷墨打印机 是一种光栅设备，特别适合于低开销的彩色打印输出，基本原理是将小墨点喷射到介质上，形成文字和图形。 分为连续喷墨和即用即喷两种类型。前者的墨汁是连续喷射的，射速较快，但需要墨水泵和墨水回收装置，结构比较复杂。后者只有在需要写点的时候才喷射墨汁，射速较低，不需墨水瓶和墨水回收装置。 激光打印机 激光打印机是一种光栅扫描设备，即可用于打印字符又可用于绘图。 主要由感光鼓、粉盒、打底电晕丝、清洁器和高温溶凝部件等组成。 笔式绘图仪 笔式绘图机是矢量型设备，绘图笔相对纸作随意移动。 笔式绘图机分为滚筒式和平板式两种。 滚筒式绘图仪结构简单，价格便宜，但绘图精度比平板式绘图机低，而且所绘的图形卷在滚筒上面，绘图过程不易看清，并对纸张的大小有一定的要求。 平板式绘图仪又分为机械传动绘图仪和平面电机驱动绘图仪。前者速度低、精度低、寿命短，但价格相对便宜。后者精度高，但体积大、笨重、不灵活且价格较昂贵。 2.3 图形软件系统-图形支撑软件 图形支撑软件：可分为三个层次： 第一层次面向系统 第二层既面向系统又面向用户，如CGI 第三层次面向用户，如OpenGL，DirectX 功能子程序是图形支撑软件第三层次的重要部分 图形应用接口API：图形库 OpenGL：由若干个函数库组成，提供了数百条图形命令，包括基本图形元素的生成，封闭边界内的填色、纹理、反走样等；基本图形元素的几何变换、投影变换、窗口裁剪等；自由曲线、曲面处理、隐藏线、隐藏面消除以及具有光照颜色效果的真实图形显示；自然界效果（如云彩、薄雾、烟霭）的景象生成等。 DirectX：是一种图形应用程序接口API，包含DirectDraw，Direct3D，DirectSound，DirectInput，DirectPlay等多个组件。 一组低级“应用程序编程接口（API）”，可为Windows程序提供高性能硬件加速多媒体支持。 DirectX直接访问显卡与声卡功能，确保多媒体程序能够充分利用高性能硬件，从而提供逼真的三维图形与声音效果 DirectX由很多API组成，可以分为四大部分，显示、声音、输入和网络部分DirectDraw，Direct3D，DirectSound，Direct Input，DirectPlay OpenGL与DirectX的比较 OpenGL是跨平台标准，且有各个平台实现；DirectX仅应用于Windows，由Microsoft独立开发。 OpenGL仅提供图形绘制功能，甚至没有交互功能；DirectX则提供了多媒体程序开发所需的全部API。 OpenGL是函数库；DirectX则是组件库 教学、科研方面OpenGL是主流，游戏开发、商业应用则基本采用DirectX。 Java3D： 是一种功能完备、通用性强的编程语言。作为一种面向对象的高层API，具有高度的移植性。 Java3D API是Sun定义的用于实现3D显示接口。3D技术是底层的显示技术，Java3D提供了基于Java的上层接口。 Java3D把OpenGL和DirectX这些底层技术包装在Java接口中。 加入到J2SE、J2EE的整套架构，这些特性保证了Java3D技术强大的扩展性。 Java3D： 生成简单或复杂的形体 使形体具有颜色、透明效果、贴图 在三维环境中生成灯光、移动灯光 具有行为的处理判断能力（键盘、鼠标、定时等） 生成雾、背景、声音 使形体变形、移动、生成三维动画 编写非常复杂的应用程序，用于各种领域如VR（虚拟现实） 图形API对比： | 技术 | 实现层次 | 开发难度 | 扩展性 | 应用领域 || ——- | —————- | ———— | —————– | ———— || OpenGL | 底层（显卡） | C/C++（难） | 多平台（较好） | 三维设计软件 || DirectX | 底层（操作系统） | C++（较难） | Windows平台（差） | 三维游戏 || Java3D | 中层（JVM） | Java（较易） | 多平台（好） | 网络三维显示 | 第四章 图形的表示与数据结构纲要 基本概念 三维形体的表示 非规则对象的表示 层次建模 4.1 基本概念-造型技术 基本概念 把研究如何在计算机中建立恰当的模型表示不同图形对象的技术称为造型技术。 有两类图形对象： 规则对象：几何造型、几何模型 不规则对象：过程式模拟。 基本图形元素：图素或图元、体素。 图素是指可以用一定的几何参数和属性参数描述的最基本的图形输出元素。 段是指具有逻辑意义的有限个图素（或体素）及其附加属性的集合。 图形信息与非图形信息 几何信息：形体在欧式空间中的位置和大小。 拓扑信息：形体各分量（点、线、面）的数目及其相互间的连接关系。 4.1 基本概念-几何信息与拓扑信息 刚体运动：不改变图形上任意两点间的距离，也不改变图形的几何性质的运动。 拓扑运动：允许形体作弹性运动，即在拓扑关系中，对图形可随意地伸张扭曲。但在图上各个点仍为不同的点，绝不允许把不同的点合并成一个点。 4.1 基本概念-实体 点的领域：如果P是点集S的一个元素，那么点P的以R（R&gt;0）为半径的领域指的是围绕点P的半径为R的小球（二维情况下为小圆）。 开集的闭包：是指该开集与其所有边界点的集合并集，本身是一个闭集。 正则集：由内部点构成的点集的闭包就是正则集，三维空间的正则集就是正则形体。 组成三维物体的点的集合可以分为两类： 内点为点集中的这样一些点，它们具有完全包含于该点集的充分小的领域。 边界点：不具备此性质的点集中的点。 定义点集的正则运算r运算为： ​ r·A=c·i·A 正则运算即为先对物体取内点再取闭包的运算。 r·A称为A的正则集。 二维流形指的是对于实体表面上的任意一点，都可以找到一个围绕着它的任意小的领域，该领域与平面上的一个圆盘是拓扑等价的。 实体：对于一个占据有限空间的正则形体，如果其表面是二维流形，则该正则形体为实体。 4.1 基本概念-正则集合运算 运算条件：有效实体的封闭性。 把能够产生正则形体的集合运算称为正则集合运算。 4.2 三维形体表示-规则对象的表示方法 线框模型与实体模型（实体造型技术） 可以将实体模型的表示大致分为三类： 边界表示 构造实体几何表示 空间分割表示 多边形表面模型 扫描表示 构造实体几何法 空间位置枚举表示 八叉树 4.2 三维形体表示-多边形表面模型 边界表示的最普遍方式是多边形表面模型，它使用一组包围物体内部的平面多边形，也即平面多面体，来描述实体。 数据结构 几何信息 建立3张表：顶点表、边表和多边形表来存储几何数据。 实体模型中，用多边形顶点坐标值以及多边形所在平面方程方式保存实体单个表面部分的空间方向信息。 数据结构 拓扑信息：翼边结构表示 属性信息 用属性表来存储多边形面的属性，指明物体透明度及表面反射度的参数和纹理特征等等。 4.2 三维形体表示-多边形网格 多边形网格：三维形体的边界通常用多边形网格的拼接来模拟 4.2 三维形体表示-扫描表示法 扫描表示法可以利用简单的运动规则生成有效实体。 包含两个要素 一是作扫描运动的基本图形（截面）； 二是扫描运动的方式 4.2 三维形体表示-构造实体几何法 构造实体几何法由两个实体间的并、交或差操作生成新的实体。 早构造实体几何法中，集合运算的实现过程可以用一棵二叉树（称为CSG树）来描述。 树的叶子是基本体素或是几何变换参数； 树的非终端结点是施加于其子结点的正则集合算子（正则并、正则交和正则差）或几何变换的定义。 优点：如果体素设置比较齐全，通过集合运算就可以构造出多种不同的符合需要的实体 缺点一：集合运算的中间结果难以用简单的代数方程表示，求交困难。 缺点二：CSG树不能显式地表示形体的边界，因而无法直接显示CSG树表示的形体。 解决：光投影算法。 4.2 三维形体表示-空间位置枚举表示法 空间位置枚举表示法将包含实体的空间分割为大小相同、形状规则（正方形或立方体）的体素，然后，以体素的集合来表示图形对象。 二维情况，常用二维数组存放。 三维情况下，常用三维数组p[i][j][k]来存放。 八叉树又称为分层树结构，它对空间进行自适应划分，采用具有层次结构的八叉树来表示实体。 4.3 非规则对象的表示-基本概念 分形几何 形状语法 微粒系统 基于物理的建模 4.3 非规则对象的表示-分形几何 分形几何物体具有一个基本特征：无限的自相似性。 无限的自相似性的是指物体的整体和局部之间细节的无限重现。 分形维数，又称分数维数 4 = 2的2次方 8 = 2的3次方 N = K的D次方 D = lgN/lgK K为边长缩小倍速；N为边长缩小后产生的新形体个数。 生成过程：初始生成元、生成元。 4.3 非规则对象的表示-形状语法 形状语法：给定一组产生式规则，形状设计者可以在从给定初始物体到最终物体结构的每一次变换中应用不同的规则。 产生式规则可以用具有图形运算能力的数学式或其他过程性方法结合实现。 4.3 非规则对象的表示-微粒系统 用于模拟自然景物或模拟其它非规则形状物体展示“流体”性质的一个方法是微粒系统。 这一方法尤其擅长描述随时间变化的物体。 微粒运动的模拟方式：随机过程模拟、运动路径模拟、力学模拟。 4.3 非规则对象的表示-基于物理的建模 基于物理的建模方法：描述了物体在内外力相互作用下的行为。通常用一组网格结点逼近物体。网格结点间取为柔性连接，再考虑贯穿物体网格的力传递。 4.4 图形的层次结构-基本概念 段的层次模型 存储简单：一个段虽然再图中各处出现，但他的几何和拓扑信息只要保存一次。 编辑简单：删除、移动及缩放操作都可以以段为单位。、 系统的层次模型可以通过将一个图段嵌套到另一个图段中形成图段树来创建。不同的段和基本图形元素在各自的建模坐标系中定义。 图层。通过把功能相同的部分归类，并将它们绘制在同一层上，有助于图形的理解和管理。 一般图层不再嵌套。 第五章 基本图形生成算法","raw":null,"content":null,"categories":[],"tags":[{"name":"图形学学习笔记","slug":"图形学学习笔记","permalink":"http://zehwakaka.github.io/tags/图形学学习笔记/"}]},{"title":"Java基础","slug":"Java基础","date":"2021-03-14T12:14:45.000Z","updated":"2021-03-15T01:48:20.000Z","comments":true,"path":"2021/03/14/Java基础/","link":"","permalink":"http://zehwakaka.github.io/2021/03/14/Java基础/","excerpt":"","text":"Java 基础语法 面向对象 高级应用 第一节 资料文件结构 概述 计算机硬件介绍 计算机发展史上的鼻祖 操作系统 万维网 职业发展与提升 学习经验探讨 第二节 入门概述 计算机包括硬件和软件两部分。硬件包括计算机中可以看得见的物理部分。而软件提供看不见的指令。这些指令控制硬件并且使得硬件完成特定的任务。 程序设计 定义：创建（或开发）软件。软件包含了指令，告诉计算机做什么。 应用场景：软件遍布我们周围。除了个人计算机，飞机、汽车、手机甚至烤面包机中，同样运行着软件。 程序设计语言 软件开发人员在称为程序设计语言的强大工具的帮助下创建软件。 计算机硬件介绍 中央处理器（CPU）、内存（主存）、存储设备、输入设备、输出设备、通信设备。总线（bus） 冯·诺依曼体系结构是现代计算机的基础，现在大多计算机仍是冯·诺伊曼计算机的组织结构，只是作了一些改进而已，并没有从根本上突破冯体系结构的束缚。冯·诺伊曼也因此被人们称为“计算机之父”。 中央处理器（CPU）是计算机的大脑。它从内存中获取指令，然后执行这些指令。 包括：控制单元和算术/逻辑单元。 控制单元：用于控制和协调其他组件的动作。 算术/逻辑单元：用于完成数值运算（+、-、*、/）和逻辑运算（比较）。 每台计算机都有一个内部时钟，该时钟以固定速度发射电子脉冲。时钟速度越快，在给定的时间段内执行的指令就越多。速度的计量单位是赫兹（Hz），1Hz相当于每秒1个脉冲。随着CPU速度不断提高，目前以千兆赫（GHz）来表述。 最初一个CPU只有一个核（core）。核是处理器中实现指令读取和执行的部分。一个多核CPU是一个具有两个或者更多独立核的组件。可提高CPU的处理能力。 IT定律之计算机行业发展规律 摩尔定律 安迪-比尔定律 反摩尔定律 内存中的信息在断电时会丢失。那我们可以考虑将程序和数据永久的保存在存储设备上。当计算机确实需要这些数据时，再移入内存，因为从内存中读取比从存储设备读取要快得多。 存储设备主要有以下三种： 磁盘驱动器 光盘驱动器 USB闪存驱动器 内存 比特（bit）和字节（byte） 一个0或者一个1存储为一个比特（bit），是计算机中最小的存储单位。 计算机中最基本的存储单元是字节（byte）。每个字节由8个比特构成。 内存（RAM）：由一个有序的字节序列组成，用于存储程序及程序需要的数据。 一个程序和它的数据在被CPU执行前必须移到计算机的内存中。 但内存是带电存储的（一旦断电数据就会消失），而且容量有限，所以要长时间存储程序或数据就需要使用硬盘。 输入和输出设备 常见的输入设备：键盘和鼠标 常见的输出设备：显示器和打印机 显示器屏幕分辨率：是指显示设备水平和垂直方向上显示的像素（px）数。 分辨率可以手工设置 分辨率越高，图像越锐化、越清晰。 通讯设备 常见的设备有：拨号调制解调器、DSL（数字用户线）、电缆调制解调器、网络接口卡（NIC）、无线网络","raw":null,"content":null,"categories":[],"tags":[{"name":"面试Java_尚硅谷","slug":"面试Java-尚硅谷","permalink":"http://zehwakaka.github.io/tags/面试Java-尚硅谷/"}]},{"title":"夜","slug":"银河-夜","date":"2020-12-26T07:20:14.000Z","updated":"2020-12-26T07:20:14.000Z","comments":true,"path":"2020/12/26/银河-夜/","link":"","permalink":"http://zehwakaka.github.io/2020/12/26/银河-夜/","excerpt":"","text":"银河空旷、坦荡，列车奔驰在夜的星空，似乎没有方向，也无法预测终点将在何时何地到来。生命，就像这遥远无依的茫然，充满了未知，有过光明与黑暗、挚爱与哀愁，然后脆弱得好似掉进银河的一颗星，瞬间沉没于无垠的浩瀚。忧伤的少年啊，在人生虚妄而伤感的旅途中，就这样缓慢悲伤地成长。也许你想要的，仅是些许的幸福和被这个世界所认同，却无奈地总被排斥在外。但不要哭泣，你所搭乘的列车，终点不会是伤感的归宿，而是银河最深处幸福恬静的天堂。 《银河铁道之夜》 — 〔日〕宫泽贤治","raw":null,"content":null,"categories":[{"name":"文学","slug":"文学","permalink":"http://zehwakaka.github.io/categories/文学/"}],"tags":[{"name":"文学","slug":"文学","permalink":"http://zehwakaka.github.io/tags/文学/"}]},{"title":"常用dos命令","slug":"常用dos命令","date":"2020-10-20T11:14:11.000Z","updated":"2020-12-26T07:19:30.000Z","comments":true,"path":"2020/10/20/常用dos命令/","link":"","permalink":"http://zehwakaka.github.io/2020/10/20/常用dos命令/","excerpt":"","text":"123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# 盘符切换cd /d 地址# 查看当前目录下的所有文件dir# 切换目录cd change directorycd ..# 清理屏幕cls (clear screen)# 退出终端exit# 查看电脑ipipconfig# 打开应用'''calcmspaintnotepad# ping 命令&gt; ping www.baidu.com# 文件操作md 目录名rd 目录名cd&gt; 文件名del 文件名","raw":null,"content":null,"categories":[],"tags":[{"name":"java 课程","slug":"java-课程","permalink":"http://zehwakaka.github.io/tags/java-课程/"}]},{"title":"IT专业英语","slug":"IT专业英语","date":"2020-10-13T09:15:23.000Z","updated":"2020-12-26T07:18:48.000Z","comments":true,"path":"2020/10/13/IT专业英语/","link":"","permalink":"http://zehwakaka.github.io/2020/10/13/IT专业英语/","excerpt":"","text":"单词 hosted service 托管服务 deliver 接生、传送 pervasive computing 普适计算 threshold 阈值 dissertation defense 毕业答辩 take many forms 以多种形式 expertise 专业技能 disciplines 学科 categorize 分类 entail 牵涉 distinct 明显的 namely 表示穷举 can be defined as 被定义 utilization 使用 much more than 不仅仅 infrastructure 基础设施 leverage 利用、杠杆 employ 利用 apply 利用 objective 目标 encompass 包含 macro 宏观的 feature 以…为特色 up one‘s game 升级游戏 buzz word 流行行话 channel firms 公司 access 评估","raw":null,"content":null,"categories":[],"tags":[{"name":"复习","slug":"复习","permalink":"http://zehwakaka.github.io/tags/复习/"}]},{"title":"随记","slug":"随记","date":"2020-09-21T13:41:25.000Z","updated":"2020-12-26T07:20:08.000Z","comments":true,"path":"2020/09/21/随记/","link":"","permalink":"http://zehwakaka.github.io/2020/09/21/随记/","excerpt":"","text":"亲爱的朋友，倘若你既被大人物的喧嚣声吵得震耳欲聋，又备受小人的暗箭刺伤，请躲入你的孤独中去吧! –尼采","raw":null,"content":null,"categories":[],"tags":[{"name":"随记","slug":"随记","permalink":"http://zehwakaka.github.io/tags/随记/"}]},{"title":"数值计算方法","slug":"数值计算方法","date":"2020-09-14T13:45:52.000Z","updated":"2020-12-26T07:20:00.000Z","comments":true,"path":"2020/09/14/数值计算方法/","link":"","permalink":"http://zehwakaka.github.io/2020/09/14/数值计算方法/","excerpt":"","text":"第一章 数值计算引论1.1 数值计算方法数值计算方法是以数学问题为研究对象，但它不是研究数学本身的理论，而是着重研究数学问题求解的数值方法及其相关理论，包括误差分析、收敛性和稳定性等内容。它应具有以下特点： 把每个求解的数学问题用计算机所能直接处理的四则运算的有限形式的公式表达出来即构成数值方法。 每个数值方法要保证收敛性，数值方法的解即数值解能逼近精确解到要求的程度，还要保证数值稳定性。 数值方法有良好的计算复杂度，即运算次数要少，同时所需存储量要小。 1.2 误差的来源 建立的数学模型和实际事物的差距称为模型误差或描述误差。 在建立的各种计算公式中，通常会包括一些参数，而这些参数又往往是通过观测或实验得到的，他们与真值之间有一定的差异，这就给计算带来了一定的误差。这种误差称为观测误差或测量误差。 在数值计算方法中不研究模型误差和观测误差，总是认为数学模型正确、合理的反映了客观实际，只是对求解数学模型时产生的误差进行分析研究，求解数学模型时常遇到的误差是截断误差和舍入误差。 1.3 近似数的误差表示近似数的误差常用绝对误差、相对误差和有效数字表示。下面介绍这三种表示方法及其相互之间的关系。 绝对误差 相对误差 有效数字 有效数字与相对误差","raw":null,"content":null,"categories":[],"tags":[{"name":"复习","slug":"复习","permalink":"http://zehwakaka.github.io/tags/复习/"}]},{"title":"操作系统","slug":"操作系统","date":"2020-09-14T13:45:19.000Z","updated":"2020-12-26T07:19:24.000Z","comments":true,"path":"2020/09/14/操作系统/","link":"","permalink":"http://zehwakaka.github.io/2020/09/14/操作系统/","excerpt":"","text":"第一章 操作系统引论 操作系统：计算机硬件上的第一层软件；主要作用是管理好计算机硬件，提高利用率和系统吞吐量；为用户和应用程序提供简单接口，方便用户使用。 1.1操作系统的目标和作用操作系统的目标与应用环境有关。例如在查询系统中所用的OS，希望能提供良好的人——机交互性；对于应用于工业控制、武器控制以及多媒体环境下的OS，要求其具有实时性；而对于微机上配置的OS，则更看重的是使用的方便性。 操作系统的目标 方便性，用户采用高级语言编写程序，或使用OS提供的命令操作计算机，使计算机变得易学易用。 有效性，提高系统资源的利用率，提高系统的吞吐量。 方便性和有效性是设计OS时最重要的两个目标。 可扩充性，令OS能适应计算机硬件、体系结构、计算机应用的发展。 开放性，计算机硬件和软件兼容性的需要。 操作系统的作用 用户、资源管理、资源抽象等方面。 OS作为用户与计算机硬件系统之间的接口 OS处于用户与计算机硬件系统之间，用户通过OS来使用计算机系统。或则说，用户在OS帮助下能够方便、快捷、可靠地操纵计算机硬件和运行自己的程序。 OS作为计算机系统资源的管理者 在一个计算机系统中，通常都含有多种硬件和软件资源。归纳起来可将这些资源分为五类：处理机、存储器、I/O设备以及文件(数据和程序)、网络与通信管理。 OS的主要功能正是对这四类资源进行有效的管理。处理机管理是用于分配与回收；存储器管理主要负责内存的分配与回收；I/O设备管理是负责I/O设备的分配(回收)与操纵；文件管理是用于实现对文件的存取、共享和保护。网络与通信管理是用于对网路资源、数据通信、应用服务等管理。 资源技术管理 资源复用(解决物理资源数量不足) 资源虚拟(解决物理资源数量不足，提高服务的能力和水平) 资源抽象(处理系统的复杂性，解决资源的易用性) 2.1 资源管理 复用 空分复用共享——该资源可进一步分割成更多和更小的单位供进程使用。 时分复用共享——并不把资源进一步分割成更小的单位，进程可在一个时间段内独占使用整个物理资源。 虚拟 对资源进行转化、模拟或整合，把物理上的一个资源变成逻辑上的多个对应物的一类技术。 空分复用分割实际存在的物理资源，虚拟实现虚构假想的虚拟同类资源。资源虚拟的例子——虚拟设备、虚拟主存、虚拟文件、虚拟屏幕(终端)、虚拟信道。 2.2 OS实现了对计算机资源的抽象一台完全无软件的计算机系统(即裸机)，由于它向用户提供的仅是硬件接口(物理接口)，因此，用户必须对物理接口的实现细节有充分的了解，这就致使该物理机器难以广泛使用。 为了方便用户使用I/O设备，人们在裸机上覆盖上一层I/O设备软件管理软件，如图1-2所示，由它来实现对I/O设备操作的细节，并向上将I/O设备抽象为一组数据结构和操作指令，方便用户实现对I/O操作。 同理，为了方便用户使用文件系统等计算机硬件资源，可以在计算机硬件上铺设多层软件，对硬件资源进行抽象，方便用户使用，也就构成了OS。 推动操作系统发展的主要动力 不断提高计算机资源利用率 方便用户 器件的不断更新换代 计算机体系结构的不断发展 不断提出新的应用需求 观察和研究操作系统总纲 观察和研究操作系统4种观点细化 服务用户观点——操作系统作为用户接口和公共服务程序 进程交互观点——操作系统作为进程执行的控制者和协调者 系统实现观点——操作系统作为扩展机或虚拟机 资源管理观点——操作系统作为资源的管理者和控制者 操作系统即是”管理员”,又是”服务员” 对内作为”管理员”,做好软硬件资源的管理、控制与调度,在裸机基础上形成虚拟机供应用程序使用，并对程序执行进行控制和协调，提高系统效率和资源利用率； 对外作为”服务员”，是用户与硬件的接口和人机界面，为用户提供最友善的运行环境和最佳的服务，操作系统在管理好资源的基础上，向外提供强有力的服务； 所以，资源管理是操作系统一项主要任务。 OS作为用户接口和服务提供者 操作系统提供友善的人机接口，使得用户能够方便、可靠、安全、高效地使用硬件和运行应用程序； 操作系统对计算机硬件进行改造和扩充，为用户提供强有力的各种服务。 OS作为程序执行的控制者和协调者 进程是支持程序执行的一种系统机制，进程是执行中的程序，系统以进程方式组织程序在计算机上运行； OS需要提供机制，解决并发进程执行时产生的互斥、同步、通信和死锁问题。 OS作为扩展机或虚拟机 把操作系统分为若干层次或模块，逐步添加到裸机上，形成操作系统虚拟机； 操作系统把硬件的复杂性与用户隔离开来； 操作系统与硬件组成一台功能显著增强，使用更加方便，安全可靠性更好的扩展机器或虚拟机。 OS作为资源管理者和控制者 对软硬件资源进行资源复用、虚拟和抽象，管理各类资源，记录使用情况，确定分配策略，实施分配和回收，满足用户对资源的需求和申请。 提供机制协调应用程序对资源的使用冲突，研究资源使用的统一方法，为用户提供简单、有效的资源使用手段，在满足应用程序需求的前提下，最大限度地实现各种资源的共享，提高资源使用率。 1.2 操作系统的发展过程在20世纪50年代中期，出现了第一个简单的批处理OS;60年代中期开发出多道批处理系统;不久又推出分时系统，与此同时，用于工业和武器控制的实时OS也相继问世。 20世纪70到90年代，是VLSI和计算机体系结构大发展的年代，导致了微型机、多处理机和计算机网络的诞生和发展，与此相应地，也相继开发出了微机OS、多处理机OS和网络OS，并得到极为迅猛的发展。 具体发展历程可以分为以下几个阶段： 未配置操作系统的计算机系统 人工操作方式 早期的操作方式是由程序员将事先已穿孔的纸带(或卡片)，装入纸带输入机(或卡片输入机)，然后将纸带(或卡片)上的程序和数据输入计算机，进行运行。仅当程序运行完毕并取走计算结果后，才允许下一个用户上机。这种人工操作方式有以下两方面的缺点： 用户独占全机，即一台计算机的全部资源由上机用户所独占。 CPU等待人工操作。当用户进行装带(卡)、卸带(卡)等人工操作时，CPU及内存等资源是空闲的。 脱机输入/输出(Off-Line I/O)方式 为了解决人机矛盾及CPU和I/O设备之间速度不匹配的矛盾，20世纪50年代末出现了脱机I/O技术。 该技术是事先将装有用户程序和数据的纸带1装入纸带输入机，在一台外围机的控制下，把纸带(卡片)上的数据(程序)输入到磁带上。当CPU需要这些程序和数据时，再从磁带上高速地调入内存。 优点：减少CPU空闲世纪；提高I/O速度。 单道批处理系统 单道批处理系统(Simple Batch Processing System) 为了实现对作业的连续处理，需要先把一批作业以脱机方式输入到磁带上，并在系统中配上监督程序(Monitor),在它的控制下，使这批作业能一个接一个地连续处理。 单道批处理系统特点 单道批处理作用：旨在解决人机矛盾、CPU和I/O设备速度之间的矛盾，一定程度上提高系统的利用率和吞吐量。 最主要的缺点：系统中的资源仍有得不到充分的利用。这是因为在内存中仅有一道程序，每逢该程序在运行中发出I/O请求后，CPU便处于等待状态，必须在其I/O完成后才继续运行。又因I/O设备的低速性，更使CPU的利用率显著降低。图1-5示出了单道程序的运行情况，从图可以看出：在t2~t3、t6~t7时间间隔内CPU空闲。 多道批处理系统(Multiprogrammed Batch Processing System) 多道程序设计的基本概念 为了进一步提高资源的利用率和系统吞吐量，在20世纪60年代中期引入了多道程序设计技术，由此形成了多道批处理系统。图1-6示出了四道程序时的运行情况。 CPU利用率是主存中多道程序道数的函数 程序等待I/O操作的时间的比例为p，当主存中有n道程序时，所有程序都等待I/O的概论是p的n次方，那么， CPU利用率 = 1-p的n次方 n称多道程序的道数或度数，可见CPU的利用率是n的函数 多道批处理系统的优缺点 多道批处理系统的优点： 资源利用率高。引入多道批处理能使多道程序交替运行，以保持CPU处于忙碌状态；在内存中装入多道程序可提高内存的利用率；此外还可以提高I/O设备的利用率。 系统吞吐量大。能提高系统吞吐量的主要原因可归结为： CPU和其他资源保持”忙碌”状态； 仅当作业完成时或运行不下去时才进行切换，系统开销小。 多道批处理系统的缺点： 平均周转时间长。由于作业要排队依次进行处理，因而作业的周转时间较长，通常需几个小时，甚至几天。 无交互能力。用户一旦把作业交给系统后，直至作业完成，用户都不能与自己的作业进行交互，修改和调试程序极为不方便。 实现多道批处理系统需要解决的问题 处理机争用问题。既要能满足各道程序运行的需要，又要能提高处理机的利用率。(处理器的管理和调度) 内存分配和保护问题。系统应能为每道程序分配必要的内存空间，使他们“各得其所”，且不会因某道程序出现异常情况而破坏其他程序。(存储保护与程序浮动) I/O设备分配问题。系统应采取适当的策略来分配系统中的I/O设备，以达到能方便用户对设备的使用，又能提高设备利用率的目的。(系统资源的管理和调度) 文件的组织和管理问题。系统应能有效地组织存放在系统中的大量的程序和数据，使它们既便1于用户使用，又能保证数据的安全性。 作业管理问题。系统中存在着各种作业(应用程序)，系统应能对系统中所有的作业进行合理的组织，以满足这些作业用户的不同要求。 用户与系统的接口问题。为使用户能方便的使用操作系统，OS还应提供与OS之间的接口。 分时系统(Time Sharing System) 分时系统的引入 提高人——机交互的需要，是推动分时系统形成和发展的主要动力。用户的需求具体表现在以下几个方面： 人——机交互：用户希望能独占计算机。 共享主机：同时供许多用户使用，又能满足上述人——机交互需要。 分时系统实现中的关键问题 为了能够实现人——机交互，必须解决的问题是：如何使用户能与自己的作业进行交互。如何实现人——机交互的实时性。如何实现多人同时共享一台计算机，感觉不到他人的存在。 及时接收：配置多路卡和缓存区，实现分时多路复用；用极短的时间接收输入。 及时处理：作业直接进入内存中；采用轮转运行方式(引入时间片)。 分时系统的特征 分时系统与多道批处理系统相比，具有非常明显的不同特性，可以归纳成以下四个方面： 多路性：一台主机，多台中断，分时原则进行服务。 独立性：终端用户互不干扰。 及时性：用户的请求能在短时间内得到相应。 交互性：用户通过终端可以与系统进行广泛的人机对话。 实时系统(Real Time System) 实时系统的类型 实时系统以时间作为关键参数，能及时相应外部事件请求。 随着计算机应用的普及，实时系统的类型也相应增多，下面列出当前常见的几种： 工业(武器)控制系统。 信息查询系统。 多媒体系统。 嵌入式系统。 实时任务的类型 周期性实时任务和非周期性实时任务，都有一个截止时间(Deadline)，可以分为：开始截止时间；完成截止时间。 硬实时任务和软实时任务。 硬实时任务，指系统必须满足任务对截止时间的要求。 软实时任务，指系统并不需要严格执行截止时间。 注意分类说明的特征和要点：以某种属性，进行分类 实时系统与分时系统特征的比较 多路性：分时系统按照分时原则为多路终端提供服务。实时系统多路性指系统周期性地对多个对象进行控制(服务)。 独立性：两种系统对于不同用户(终端)均保证彼此互不干扰。 及时性：分时系统中依照人的接受程度，实现实时性。实时系统中以截止时间来实现实时性。 交互性：分时系统能向终端提供数据处理、资源共享等服务。实时系统只能提供有限的特定操作。 可靠性：分时系统要求一般。实时系统要求很高。 微机操作系统的发展 微机系统可以按照微机的字长来分： 单用户单任务操作系统 CP/M：8位微机操作系统 MS-DOS：16位、32位操作系统 单用户多任务操作系统 单用户多任务操作系统的含义是，只允许一个用户上机，但允许用户把程序分为若干个任务，使它们并发执行，从而有效地改善了系统的性能。 例如：Windows1.0-3.1，window85/98，/XP/7/Server 多用户多任务操作系统 多用户多任务操作系统的含义是，允许多个用户通过各自的终端，使用同一台极其，共享主机系统中的各种资源，而每个用户程序又可进一步分为几个任务，使它们能并发执行，从而可进一步提高资源利用率和系统吞吐量。在大、中和小型机中所配置的大多是用户多任务操作系统。 在32位微机上，也有不少配置的是多用户多任务操作系统，其中最有代表性的是UNIX OS，Linux OS。 1.3 操作系统的基本特征多道批处理系统、分时系统和实时系统这三种基本操作系统都具有各自不同的特征，但它们也共同具有并发、共享、虚拟和异步四个基本特征。 并发 正是系统中的程序能并发执行这一特征，才使得OS能有效地提高系统中的资源利用率，增加系统的吞吐量。 并行与并发 并行性和并发性是既相似又有区别的两个概念。并行性是指两个或多个事件在同一时刻发生。而并发性是指两个或多个事件在同一时间间隔内发生。 引入进程 在一个未引入进程的系统中，在属于同一个应用程序的计算程序和I/O程序之间只能是顺序执行。 但在为计算程序和I/O程序分别建立一个进程(Process)后，这两个进程便可并发执行。若对内存中的多个程序都分别建立一个进程，它们就可以并发执行，这样便能极大地提高系统资源的利用率，增加系统的吞吐量。 进程：指在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令、数据和堆栈等组成的，是一个能独立运行的活动实体。(进程和并发是现代操作系统中最重要的概念，也是操作系统运行的基础。) 共享(Sharing) OS中的资源共享：指系统中的资源可供内存中多个并发执行的进程共同使用(注：进程在内存中) 为什么共享这么重要？ 系统中的资源远少于多道程序需求的总和。 各种资源属性不同，资源复用方式也不同。 互斥共享方式 系统中的某些资源，如打印机、磁带机等，虽然可以提供给多个进程(线程)使用，但应规定在一段时间内，只允许一个进程访问该资源。为此，需要互斥访问方式。 互斥共享方式：一个时间段内只允许一个进程访问这一个资源的资源共享方式。这种资源被称为临界资源。 同时访问方式 系统中还有另一类资源，允许在一段时间内由多个进程”同时”对它们进行访问。这里所谓的”同时”，在单处理机环境下是宏观意义上的，而在微观上，这些进程对该资源的访问是交替进行。例如：磁盘。 虚拟(Virtual) 时分复用技术 使用某设备为一个用户服务的空闲时间，又转去为其他用户服务，使设备得到最充分的利用。 虚拟处理机技术：为每一道程序建立至少一个进程，让多道程序并发执行。 虚拟设备技术：使用分时复用的方法，将一台物理I/O设备虚拟为多台逻辑上的I/O设备。 空分复用技术 它是利用存储器的空闲空间，分区域存放和运行其他的多道程序。把空分复用技术用于对存储空间的管理，可以提高存储空间的利用率。 进一步引入虚拟存储技术，可以从逻辑上扩大存储器的容量。 异步(Asynchronism) 在多道程序环境下，系统允许多个进程并发执行。在单处理机环境下，由于系统中只有一台处理机，因而每次只允许一个进程执行，其余进程只能等待。 当正在执行的进程提出某种资源要求时，如打印请求，而此时打印机正在为其他进程打印，由于打印机属于临界资源，因此正在执行的进程必须等待，并释放出处理机，直到打印机空闲，并再次获得处理机时，该进程方能继续执行。 可见，由于资源等因素的限制，使进程的执行通常都不可能”一气呵成”，而是以”停停走走”的方式运行。 进程的异步性：进程以人们不可预知的速度向前推进。 1.4 操作系统的主要功能引入OS的主要目的是，为多道程序的运行提供良好的运行环境，以保证多道程序能有条不紊地、高效地运行，并能最大程序地提高系统中各种资源的利用率，方便用户的使用。 传统OS中应具有处理机管理、存储器管理、设备管理和文件管理等基本功能。此外，为了方便用户使用OS，还需向用户提供方便的用户接口。 处理机管理功能 主要功能：创建和撤销进程，对诸进程的运行进行协调，实现进程之间的信息交换，以及按照一定的算法把处理机分配给进程。 进程控制：为作业创建进程、撤销已结束的进程、控制进程在运行过程中的状态转换。 进程同步：进程互斥方式、进程同步方式。 进程通信：实现相互合作进程之间的信息交换。 调度：第一步 作业调度；第二步 进程调度。 存储器管理功能 功能：内存分配和回收、内存保护、地址映射和内存扩充。 内存分配 内存分配的主要任务是： 为每道程序分配内存空间，使它们”各得其所”。 提高存储器的利用率，尽量减少不可用的内存空间(碎片)。 允许正在运行的程序申请附加的内存空间，以适应程序和数据动态增长的需要。 OS在实现内存分配时，可采取静态和动态两种方式： 静态分配方式。每个作业的内存空间是在作业装入时确定的，在作业装入后的整个运行期间不允许该作业再申请新的内存空间，也不允许作业在内存中”移动”。 动态分配方式。每个作业所要求的基本内存空间虽然也是在装入时确定的，但允许作业在运行过程中继续申请新的附加内存空间，以适应程序和数据的动态增长，也允许作业在内存中”移动”。 内存保护 内存保护的主要任务是： 确保每道用户程序都仅在自己的内存空间内运行，彼此互不干扰。 绝不允许用户访问操作系统的程序和数据，也不允许用户程序转移道非共享的其他用户程序中去执行。 地址映射 在多道程序环境下，由于每道程序经编译和链接后所形成的可装入程序其他地址都是从0开始的，但不可能将它从”0”地址(物理)开始装入内存，致使(各程序段的)地址空间内的逻辑地址与其在内存空间中的物理地址并不相一致。 为保证程序能正确运行，存储器管理必须提供地址映射功能，即能够将地址空间中的逻辑地址转换为内存空间中与之对应的物理地址。(该功能应在硬件的支持下完成) 内存扩充 内存扩充并非是从物理上去扩大内存的容量，而是借助于虚拟存储技术，从逻辑上扩充内存容量，使用户所感觉到的内存容量比实际内存容量大得多，以便让更多的用户程序能并发运行。 为了能在逻辑上扩充内存，系统必须设置内存扩充机制(包含少量的硬件)，用于实现下述各功能： 请求调入功能。 置换功能。 设备管理功能 设备管理的主要任务如下： 完成用户进程提出的I/O请求，为用户进程分配所需的I/O设备，并完成指定的I/O操作。 提高CPU和I/O设备的利用率，提高I/O速度，方便用户使用I/O设备。 为实现上述任务，设备管理应具有缓冲管理、设备分配和设备处理以及虚拟设备等功能。 缓存管理 设备分配 设备处理 文件管理功能 对用户文件和系统文件进行管理以方便用户使用，并保证文件的安全性。主要包含以下内容： 文件存储空间的管理 目录管理 文件的读/写管理和保护 文件的度/写管理。 文件保护。 操作系统与用户之间的接口 用户接口 联机用户接口。 脱机用户接口。 图形用户接口。 程序接口 程序接口是为用户程序在执行中访问系统资源而设置的，是用户程序取得操作系统服务的唯一途径。 它是由一组系统调用组成的，每一个系统调用都是一个能完成特定功能的子程序。每当应用程序要求OS提供某种服务(功能)时，便调用具有相应功能的系统调用(子程序)。 现代操作系统的新功能 现代操作系统是在传统操作系统基础上发展起来的，它除了具有传统操作系统的功能外，还增加了面向安全、面向网络和面向多媒体等功能。 系统安全 认证技术 密码技术 访问控制技术 反病毒技术 网络的功能和服务 网络通信 资源管理 应用互操作 支持多媒体 接纳控制功能 实时调度 多媒体文件的存储 1.5 OS结构设计根据软件工程开发要求(质量、费用)，先后出现多种操作系统的开放方法，如：模块化方法、结构化方法和面向对象的方法等。 传统操作系统结构 无结构操作系统 早期开发操作系统，注意力主要放在功能的实现和效率上，缺乏首尾一致的设计思想。此时的OS是为一组过程的集合，每个过程可以任意地荷香调用其他过程，致使操作系统内部既复杂又混乱，因此，这种OS是无结构的，也有人把它称为整体系统结构。 模块化结构OS 模块化程序设计技术的基本概念 模块化程序设计技术基于”分解”和“模块化”的原则来控制大型软件的复杂度。按其功能精心地划分为若干个具有一定独立性和大小的模块。每个模块具有某方面的管理功能，如：进程管理模块、存储器管理模块、I/O设备管理模块等。图1-7示出了由模块、子模块等组成的模块化OS结构。 模块独立性 在模块-接口法中，关键问题是模块的划分和规定好模块之间的接口。如果我们在划分模块时将模块划分得太小，虽然可以降低模块本身的复杂性，但会引起模块之间的联系过多，从而会造成系统比较混乱；如果将模块划分得过大，又会增加模块内部的复杂性，使内部的联系增加，因此在划分模块时，应在二者间进行权衡。 同时，必须充分注意模块的独立性。衡量模块独立性的标准：低耦合、高内聚。 模块接口法的优点 利用模块-接口法开发的OS，较之无结构OS具有以下明显的优点： 提高OS设计的正确性、可理解性和可维护性。 增强OS的可适用性。 加速OS的开发过程 模块化结构设计仍存在下述问题： 在OS设计时，对各模块间的接口规定很难满足在模块设计完成后对接口的实际需求。 在OS设计阶段，设计者必须做出一系列的决定(决策)，每一个决定必须建立在上一个决定的基础上，但模块化结构设计中，各模块的设计齐头并进，无法寻找一个可靠的决定顺序，造成各种决定的”无序性”，这将使程序人员很难做到”设计中的每一步决定”都是建立在可靠的基础上，因此模块-接口法又被称为”无序模块法”。 分层式结构OS 分层式结构的基本概念 为了将模块-接口法中”决定顺序”的无序性变为有序性，引入了有序分层法，分层法的设计任务是，在目标系统An和裸机系统(又称宿主系统)A0之间，铺设若干个层次的软件A1、A2、A3、…、An-1，使An通过An-1、An-2、…、A2、A1层，最终能在A0上运行。在操作系统中，常采用自底向上法来铺设这些中间层。 分层结构的优缺点 分层结构的主要优点： 易保证系统的正确性。 易扩充和易维护性。 分层结构的主要缺点： 系统效率降低。由于层次结构是分层单向依赖的，必须在每层之间都建立层次间的通信机制，OS每执行一个功能，通常要自上而下地穿越多个层次，这无疑会增加系统的通信开销，从而导致系统效率的降低。 客户/服务器模式(Client/Server Model) 简介 客户/服务器模式的由来、组成和类型 客户/服务器系统主要由三部分组成 客户机 服务器 网络系统 客户/服务器之间的交互 客户发送请求消息 服务器接收消息 服务器回送消息 客户机接收消息 客户/服务器模式的优点 数据的分布处理和存储 便于集中管理 灵活性和可扩充性 易于改编应用软件 1.5.3 面向对象的程序设计(Object-Orientated Programming)技术简介 面向对象技术的基本概念 面向对象技术是基于”抽象”和”隐蔽”原则来控制大型软件的复杂度。 对象 在面向对象的技术中，是利用被封装的数据结构(变量)和一组对它进行操作的过程(方法)来表示系统中的某个对象的，如图1-8所示。 对象中的变量(数据)对我是隐蔽的，外界不能直接访问，需要通过该对象中的一组方法对它进行访问。 对象类 在实践中，有许多对象可能表示的是同一类事物，每一个对象具有自己的变量集合，而它们所具有的方法是相同的。如果为每一个相似的对象都定义一组变量和方法，显然是低效的，由此产生了”对象类”的概念，利用”对象类”来定义一组大体相似的对象。 一个类同类定义了一组变量和针对该变量的一组方法，用它们来描述一组对象的共同属性和行为。类是在对象上的抽象，对象则是类的实例。对象类中所定义的变量在实例中均有具体的值。 继承 在面向对象的技术中，可以根据已有类来定义一个新的类，新类被称为子类(B),原来的类被称为父类(A),见图1-10所示。 面向对象技术的优点 在操作系统设计时，将计算机中的实体作为对象来处理，可带来如下好处： 通过”重用”提高产品质量和生产率。 使系统具有更好的易修改性和易扩展性。 更易于保证系统的”正确性”和”可靠性”。 微内核OS结构 微内核(MicroKernel),能有效地支持多处理机，如windowsXP/7/8。为了提高操作系统的”正确性”、”灵活性”、”易维护性”、”可扩充性”，大多采用基于客户/服务器模式的微内核结构，将操作系统划分为:微内核和多服务器。微内核操作系统尚无一致定义，本文将从下列四个方面进行阐述。 微内核操作系统的基本概念 足够小的内核 在微内核操作系统中，内核是能实现现代OS最基本核心功能的小型内核。它只是将操作系统中最基本的部分放入微内核。 微内核通常包括： 与硬件处理紧密相关的部分 一些较基本的功能 客户和服务器之间的通信 基于客户/服务器模式 单机微内核操作系统中，基本都采用客户/服务器模式，将操作系统中最基本的部分放入内核中，而把操作系统的绝大部分功能都放在微内核外面的一组服务器(进程)中实现。 例如:用于提供对进程(线程)进行管理的进程(线程)服务器、提供虚拟存储器管理功能的虚拟存储器服务器、提供I/O设备管理的I/O设备管理服务器等，它们都是被作为进程来实现的，运行在用户态。 客户与服务器之间是借助微内核提供的消息传递机制来实现信息交互的。图1-11示出了在单机环境下的客户/服务器模式。 应用”机制与策略分离”原理 在现在操作系统的结构设计中，经常利用”机制与策略分离”的原理来构造OS结构。 机制，是指实现某一功能的具体执行机构。(放在:基层，微内核) 策略，则是在机制的基础上借助于某些参数和算法来实现该功能的优化，或达到不同的功能目标。(放在：高层) - 采用面向对象技术 通过基于面向对象技术中的&quot;抽象&quot;和&quot;隐蔽&quot;原则控制系统的复杂性。 利用&quot;对象&quot;、&quot;封装&quot;和&quot;继承&quot;等概念来确保操作系统的&quot;正确性&quot;、&quot;可靠性&quot;、&quot;易修改性&quot;、&quot;易扩展性&quot;等，并提高操作系统的设计速度。 微内核的基本功能 微内核一般将机制部分以及与硬件紧密相关的部分放入微内核中。由此可知微内核通常具有如下几方面的功能： 进程(线程)管理：进程调度属于调度功能的机制部分(内核)；进程分类、优先级设定属于策略部分(微内核外)。 低级存储器管理：低级存储器管理机制(内核)；虚拟存储器管理策略(微内核外)。 中断和陷入处理。 微内核操作系统的优点 由于微内核OS结构是建立在模块化、层次化结构的基础上的，并采用了客户/服务器模式和面向对象的程序设计技术，因此，微内核结构的操作系统是集各种技术优点之大成： 提高了系统的可扩展性。 增强了系统的可靠性。 可移植性强。 提供了对分布式系统的支持。 融入了面向对象技术。 微内核操作系统存在的问题 较之早期的操作系统，微内核操作系统的运行效率有所降低。 一次服务请求，需要利用消息实现多次交互。 频繁出现用户/内核模式与上下文的多次切换。 如图1-12所示，其中的文件服务器还需要磁盘服务器的帮助，这时就需要进行8次上下文的切换。 1.6 操作系统基本服务和用户接口 1.6.1 基本服务和用户接口 创建程序 执行程序 数据I/O 信息存取 通信服务 错误检测和处理 还具有其他功能：资源分配，统计，保护。 用户接口： 程序接口与系统调用 什么是系统调用？ 系统调用的作用？ 系统调用是应用程序获得操作系统服务的唯一途径。 内核的主体是系统调用的集合，内核可以看成是特殊的公共子程序。 操作系统的功能通过一组称为系统调用(system call)的接口呈现给用户，内核提供一系列实现预定功能的内核函数，系统调用把应用程序的请求传达给内核，内核调用对应的内核函数完成请求所需处理后，再将处理结果返回给应用程序。 系统调用的作用 系统调用是一种中介角色，把用户与硬件隔离开来，应用程序通过系统调用才能请求系统服务和使用系统资源，其作用有： 一是内核可基于权限和规则对资源访问进行裁决，保证系统的安全性； 二是系统调用封装资源抽象，提供一致性接口，避免用户使用资源时可能发生的错误，且使编程方便效率高。 API、库函数、系统调用 应用程序能直接使用系统调用吗？ POSIX(Portable Operating System Interface for Computer Environment)标准； API和库函数 库函数和系统调用。 API、库函数、系统调用之间的关系 Linux系统程序、库函数、系统调用之间的关系 第二章 进程的描述与控制2.1 前趋图和程序执行 在早期未配置OS的系统和单道批处理系统缺点：程序顺序执行，内存中仅装入一道用户程序，独占系统中的所有资源。 解决方法：多道程序系统，同时装入多个程序，进程并发执行，共享系统资源。 2.1.1 前趋图 为了能更好地描述程序的顺序和并发执行情况，我们先介绍用于描述程序执行先后顺序的前趋图。 前趋图(Precedence Graph)，是指一个有向无环图，可记为DAG(Directed Acyclic Graph),它用于描述进程之间执行的先后顺序。 图中的每个结点可用来表示一个进程或程序段，乃至一条语句，结点间的有向边则表示两个结点之间存在的偏序(Partial Order)或前趋关系(Precedence Relation)。 进程(或程序)之间的前趋关系可用”-&gt;”来表示，如果进程Pi和Pj存在着前趋关系，可表示为(Pi，Pj)属于 -&gt;,也可写成Pi-&gt;Pj,表示在Pj开始执行之前Pi必须完成。 称Pi是Pj的直接其拿去，而称Pj是Pi的直接后继。在前趋图中把没有前趋的结点称为初始结点(Initail Node),把没有后继的结点称为终止结点(Final Node)。 每个结点还具有一个重量(Weight),用于表示该结点所含有的程序量或程序的执行时间。 在图2-1(a)所示的前趋图中，存在着如下前趋关系： P1-&gt;P2,P1-&gt;3,P1-&gt;P4,P2-&gt;P5,P3-&gt;P5,P4-&gt;P6,P4-&gt;P7,P5-&gt;P8,P6-&gt;P8 ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​ ​","raw":null,"content":null,"categories":[],"tags":[{"name":"复习","slug":"复习","permalink":"http://zehwakaka.github.io/tags/复习/"}]},{"title":"计算机网络复习","slug":"计算机网络复习","date":"2020-08-26T09:09:08.000Z","updated":"2020-08-30T05:07:54.000Z","comments":true,"path":"2020/08/26/计算机网络复习/","link":"","permalink":"http://zehwakaka.github.io/2020/08/26/计算机网络复习/","excerpt":"","text":"第一章 概述1.3 互联网的组成 边缘部分：由所有连接在互联网上的主句组成。 端系统之间的通信方式通常可划分为两大类： 客户-服务器方式(C/S方式)：即Client/Server方式，简称C/S方式。 对等方式(P2P方式)：即Peer-to-Peer方式。 核心部分：由大佬网络和连载在这些完了的路由器组成。这部分是为边缘部分提供服务的(提供连通性和交换) 网络中的核心部分要向网络边缘中的大量主机提供连通性。 在网络核心部分的主要设备是路由器。 路由器是实现1分组交换的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。 分组交换的主要特点 分组交换则采用存储转发技术 在发送端，先把较长的报文划分成较短的、固定长度的数据段。 每一个数据段起那么添加上首部构成分组 每个分组在互联中独立的选择传输路径 用存储转发方式，最后分组到达最终目的地 在接收端把收到的数据恢复为原来的报文 1.6 计算机网络的性能计算机网络的性能一般是指他的几个重要的性能指标，主要包括： 速率 速率是计算机网络中最重要的一个性能指标，指的是数据的传送速率，他也称为数据率或比特率。 速率的单位是bit/s，或kbit/s、Mbit/s、Gbit/s等。例如4*1010bit/s的数据率就记为40Gbit/s 速率往往是指额定速率或标称速率，非实际运行速率。 带宽 带宽本来是指信号具有的频带宽度，其单位是赫(或千赫、兆赫、吉赫等)。 在计算机网络中，带宽用来表示网络中某通道传送数据的能力。表示在单位时间内网络中的某信道所能通过的“最高数据率”。单位bit/s，即“比特每秒”。 吞吐量 吞吐量表示在单位时间内通过某个网络(或信道、接口)的数据量。 吞吐量更经常的用于对现实世界的网络的一种测量，以便知道实际上到底有多少数据量能通过网络。 吞吐量受网络的带宽或网络的额定速率的限制。 时延 时延是指数据(一个报文或分组，甚至比特)从网络(或链路)的一端传送到另一端所需的时间。 有时也称为延迟或迟延 网络中的时延由以下几个不同的部分组成 发送时延 也称为传输时延。 发送数据时，数据帧从结点进入到传输媒体所需要的时间。 也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间 发送时延 = 数据帧长度(bit)/发送速率(bit/s) 传播时延 电磁波在信道中需要传播一定的距离而花费的时间 发送时延与传播时延有本质上的不同 信号发送速率和信号在信道上的传播速率是完全不同的概念 传播时延 = 信道长度(米)/信号在信道上的传播速率(米/秒) 处理时延 主机或路由器在收到分组时，为处理分组(例如分析首部、提取数据、差错检验或查找路由)所花费的时间。 排队时延 分组在路由器输入输出队列中排队等待处理所经历的时延。 排队时延的长短往往取决于网络中当时的通信量。 数据在网络中经历的总时延就是发送时延、传播时延、处理时延和排队时延之和。 总时延 = 发送时延+传播时延+处理时延+排队时延 必须指出，在总时延中，究竟是哪一种时延占主导地位，必须具体分析。 假设从结点A向结点B发送数据：在结点A中产生处理时延和排队时延，在发送器产生发送时延(即传输时延)，在链路上产生传播时延 往返时间RTT 互联网上的信息不仅仅单方向传输，而是双向交互的。因此，有时很需要知道双向交互一次所需的时间。 往返时间表示从发送方发送数据开始，到发送方收到来自接收方的确认，总共经历的时间。 在互联网中，往返时间还包括各中间结点的处理时延、排队时延以及转发数据时的发送时延 当使用卫星通信时，往返时间RTT相对较长，是很重要的一个性能指标。 利用率 分为信道利用率和网络利用率。 信道利用率指出某信道有百分之几的时间是被利用的(有数据通过)。完全空闲的信道的利用率是零。 网络利用率则是全网络的信道利用率的加权平均值。 信道利用率并非越高越好。当某信道的利用率增大时，该信道引起的时延也就迅速增加。 时延与网络利用率的关系：当信道的利用率增大时，该信道引起的时延迅速增加。 ​ 1.7 计算机网络的体系结构 计算机网络体系结构的形成 计算机网络是一个非常复杂的系统 互相通信的两个计算机系统必须高度协调工作才行，而这种”协调”是相当复杂的 “分层”可将庞大而复杂的问题，转化为若干较小的局部问题，而这些较小的局部问题就比较易于研究和处理。 计算机网络的各层及其协议的集合就是网络的体系结构 协议与划分层次 计算机网络中的数据交换必须遵守事先约定好的规则。 这些规则明确规定了所交换的数据的格式以及有关的同步问题(同步含有时序的意思)。 网络协议，简称为协议，是为进行网络中的数据交换而建立的规则、标准或约定。 网络协议的三个组成要素 语法：数据与控制信息的结构或格式 语义：需要发出何种控制信息，完成何种动作以及做出何种响应。 同步：事件实现顺序的详细说明。 由此可见，网络协议是计算机网络的不可缺少的组成部分。 具有五层协议的体系结构 OSI的七层协议体系结构的概念清楚，理论也较完整，但它既复杂又不实用。 TCP/IP是四层体系结构：应用层、运输层、网际层和网络接口层 但最下面的网络接口层并没有具体内容 因此往往采取折中的办法，即OSI和TCP/IP的优点，采用一种只有五层协议的体系。 第二章 物理层2.1 物理层的基本概念 常用术语 数据——运送消息的实体 信号——数据的电气的或电磁的表现 模拟信号——代表消息的参数的取值是连续的 数字信号——代表消息的参数的取值是离散的 码元——在使用时间域(或简称为时域)的波形表示数字信号时，代表不同离散数值的基本波形 2.2 数据通信的基础知识 有关信道的几个基本概念 信道——一般来表示向某一个方向传送信息的媒体 单向通信(单工通信)——只能有一个方向的通信而没有反方向的交互 双向交替通信(半双工通信)——通信的双方都可以发送信息，当不能双方同时发送(当然也就不能同时接收)。 双向同时通信(全双工通信)——通信的双方可以同时发送和接收信息。 有关信道的几个基本概念 基带信号(即基本频带信号)——来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。 基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。因此必须对基带信号进行调制。 调制分为两大类： 基带调制：仅对基带信号的波形进行变换，使它能够与信道特征性相适应。变换后的信号仍然是基带信号。把这种过程称为编码。 带通调制：使用载波进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，这样就能够更好的在模拟信道中传输(即仅在一段频率范围内能够通过信道)。 带通信号：经过载波调制后的信号。 基本的带通调制方法 最基本的二元制调制方法有以下几种： 调幅(AM)：载波的振幅随基带数字信号而变化。 调频(FM)：载波的频率随基带数字信号而变化。 调相(PM)：载波的初始相位随基带数字信号而变化。 信道的极限容量 任何实际的信道都不是理想的，在传输信号时会产生各种失真以及带来多种干扰。 码元传输的速率越高，或信号传输的距离越远，或传输媒体质量越差，在信道的输出端的波形的失真就越严重。 从概念上讲，限制码元在信道上的传输速率的因素有以下两个： 信道能够通过的频率范围 信噪比 信噪比 噪声存在于所有的电子设备和通信信道中 噪声是随机产生的，它的瞬时值有时会很大。因此噪声会使接收端对码元的判决产生错误。 但噪声的影响是相对的。如果信号相对较强，那么噪声的影响就相对较小。 信噪比就是信号的平均功率和噪声的平均功率之比。常记为S/N，并用分贝(dB)作为度量单位。即：信噪比(dB) = 10log10(S/N) （dB） 例如，当S/N = 10时，信噪比为10dB,而当S/N =1000时，信噪比为30dB。 香农公式 奈奎斯特于1924年推导出在理想低通信道下的最高码元传输速率(波特率)的公式，公式表示为理想低通信道下的最高码元传输速率=2W Baud 1984年，香农用信息论的理论推导出了带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率(香农公式) 信道的极限信息传输速率C可表达为： C = Wlog2(1+S/N) (bit/s) 其中：W为信道的带宽(以Hz为单位)； S为信道内所传信号的平均功率； N为信道内部的高斯噪声功率。 香农公式表明 信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。 只要信息传输速率低于信道的极限信息传输速率，就一定可以找到某种办法来实现无差错的传输。 若信道带宽W或信噪比S/N没有上限(当然实际信道不可能是这样的)，则信道的极限信息传输速率C也就没有上限。 实际信道上能够达到的信息传输速率要比香农的极限传输速率低不少。 2.3 物理层下面的传输媒体 引导型传输媒体 双绞线 同轴电缆 光缆 非引导型传输媒体 自由空间 2.4 信道复用技术 频分复用、时分复用和统计时分复用 频分复用(FDM) 将整个宽带分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。 频分复用的所有用户在同样的时间占用不同的带宽资源(请注意，这里的“带宽”是频率带宽而不是数据的发送速率)。 时分复用(TDM) 时分复用则是将时间划分为一段段等长的时分复用帧(TDM帧)。每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙。 每一个用户所占用的时隙是周期性的出现(其周期就是TDM帧的长度)。、 TDM信号也称为等时信号。 时分复用的所有用户是在不同的时间占用同样的频带宽度。 波分复用(WDM) 波分复用就是光的频分复用。使用一根光纤来同时传输多个光载波信号. 码分复用(CDM) 常用的名词是码分多址CDMA 各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。 这种系统发送的信号有很强的抗干扰能力，其频谱类似白噪声，不易被敌人发现。 码片序列 每一个比特时间划分为m个短的间隔，称为码片。 每一个站被指派一个唯一的m bit码片序列。 如发送比特1，则发送自己的 m bit 码片序列。 如发送比特0，则发送该码片序列的二进制反码。 例如，S站的8bit码片序列是00011011 发送比特1时，就发送序列00011011 发送比特0时，就发送序列11100100 S站的码片序列：(-1 -1 -1 +1 +1 -1 +1 +1) CDMA的重要特点 每个站分配的码片序列不仅必须各不相同，并且还必须相互正交。 在实用的系统中是使用伪随机码序列 码片序列的正交关系 令向量S表示站S的码片向量，令T表示其他任何站的码片向量。 两个不同站的码片序列正交，就是向量S和T的规格化内积等于0： 正交关系的另一个重要特性 任何一个码片向量和该码片向量自己的规格化内积都是1。 一个码片向量和该码片反码的向量的规格化内积值是-1. ​ 第三章 数据链路层3.1 使用点对点信道的数据链路层 数据链路层协议有许多种，但有三个基本问题则是共同的。三个基本问题是： 封装成帧 封装成帧就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。确定帧的界限。 首部和尾部的一个重要作用就是进行帧定界。 当数据是由可打印的ASCLL码组成的文本文件时，帧定界可以使用特殊的帧定界符。 控制字符SOH放在一帧的最前面，表示帧的首部开始。另一给控制字符EOT表示帧的结束。 透明传输 如果数据中的某个字节的二进制代码恰好和SOH或EOT一样，数据链路层就会错误的”找到帧的边界”。 解决方法：字节填充或字符填充 发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”(其十六进制编码是1B) 接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。 如果转义字符也出现在数据当中，那么应在转义字符前面插入一组转义字符ESC。当接收端收到联系的两个转义字符时，就删除其中前面的一个。 差错控制 在传输过程中可能会产生比特差错：1可能会变成0而0也可能变成1。 在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率BER。 误码率与信噪比有很大的关系。 为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种查错检测措施。 循环冗余检验的原理 在数据链路层传送的帧中，广泛使用了循环冗余检验CRC的检错技术。 帧检验序列FCS 在数据后面添加上的冗余码称为帧检验序列FCS。 循环冗余检验CRC和帧检验序列FCS并不等同 CRC是一种常用的检错方法，而FCS是添加在数据后面的冗余码 FCS可以用CRC这种方法得出，但CRC并非用来获得FCS的唯一方法 3.3 使用广播信道的数据链路层 局域网的数据链路层 媒体共享技术 静态划分信道：频分复用、时分复用、波分复用、码分复用 动态媒体接入控制(多点接入)：随机接入、受控接入，如多点线路探询，或轮询 适配器的作用 网络接口板又称为通信适配器或网络接口卡NIC或”网卡“。 适配器的重要功能 进行串行/并行转换 对数据进行缓存 在计算机的操作系统安装设备驱动程序 实现以太网协议 CSMA/CD协议 最初的以太网是将许多计算机都连接到一根总线上。当初认为这样的连接方法既简单有可靠，因为总线上没有与源器件。 以太网采用广播方式发送 总线上的每一个工作的计算机都能检测到B发送的数据信号。 由于只有计算机D的地址与数据帧首部写入的地址一致，因此只有D才接收这个数据帧。 其他所有计算机(A,C和E)都检测到不上发送给他们的数据帧，因此就丢弃这个数据帧而不能够收下来。 在具有广播特性的总线上实现了一对一的通信。 以太网采取了两种重要的措施 为了通信的简便，以太网采取了两种重要的措施： 采用较为灵活的无连接的工作方式 不必先建立连接就可以直接发送数据 对发送的数据帧不进行编号，也不要求对方发回确认。 这样做的理由是局域网信道的质量很好，因此信道质量产生差错的概率是很小的 以太网提供的服务 以太网提供的服务是不可靠的交付，即尽最大努力的交付。 当目的站受到有差错的数据帧时就丢弃此帧，其他上面也不做。差错的纠正由高层来决定。 如果高层发现丢失了一些数据而进行重传，但以太网并不知道这是一个重传的帧，而是当作一个新的数据帧来发送。 CSMA/CD协议 CSMA/CD含义：载波监听多点接入/碰撞检测 ”多点接入“表示许多计算机以多点接入的方式连接在一根总线上。 ”载波监听“是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。 总线上并没有什么”载波“。因此，”载波监听“就是用电子技术检测总线上有没有其他计算机发送的数据信号。 碰撞检测 ”碰撞检测“就是计算机边发送数据边检测信道上的信号电压大小。 当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大(互相叠加)。 当一个站检测到的信号电压摆动值超过一端的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。 所谓”碰撞“就是发生了冲突。因此”碰撞检测“也称为”冲突检测“。 检测到碰撞后 在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来。 每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要立即停止发送，免得继续浪费网络资源，然后等待一段随机时间后再次发送。 为什么要进行碰撞检测？ 由于电磁波在总线上的传播速率是有限的，当某个站监听到总线是空闲时，也可能总线并非真正是空闲的。 A向B发出的信息，要经过一定的时间后才能传送到B。 B若在A发送的信息到达B前发送直接的帧(因为这时B的子载波监听检测不到A所发送的信息)，则必然要在某个时间和A发送的帧发生碰撞。 碰撞的结果是两个帧变得无用。 所以需要在发送期间进行碰撞检测，以检测冲突。 信号传播时延对载波监听的影响 使用集线器的星形拓扑 以太网的信道利用率 以太网的MAC层 3.4 扩展的以太网","raw":null,"content":null,"categories":[],"tags":[]},{"title":"hexo常用命令","slug":"hexo常用命令","date":"2020-08-22T07:14:41.000Z","updated":"2020-08-22T08:41:28.000Z","comments":true,"path":"2020/08/22/hexo常用命令/","link":"","permalink":"http://zehwakaka.github.io/2020/08/22/hexo常用命令/","excerpt":"","text":"常用命令hexo new &quot;postName&quot; #新建文章 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） hexo deploy #部署到GitHub hexo help # 查看帮助 hexo version #查看Hexo的版本 缩写：hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy 组合命令：hexo s -g #生成并本地预览 hexo d -g #生成并上传","raw":null,"content":null,"categories":[],"tags":[]},{"title":"数据库概论复习","slug":"数据库概论复习","date":"2020-08-22T07:10:42.000Z","updated":"2020-08-28T15:43:50.000Z","comments":true,"path":"2020/08/22/数据库概论复习/","link":"","permalink":"http://zehwakaka.github.io/2020/08/22/数据库概论复习/","excerpt":"","text":"版权所有 数据库第一章 绪论数据库系统概述 数据库四个基本概念：数据库系统(DBS)包括 数据库管理系统(DBMA)，数据库管理员(DBA)，数据库(DB)。 数据管理技术的产生和发展：数据管理技术经历了人工管理、文件管理、数据库系统三个阶段。 数据库系统的特点 数据结构化 共享性高、冗余度低且易扩充 数据独立性高：数据独立性、物理独立性、逻辑独立性 数据由数据库管理系统统一管理和控制 数据模型 据模型也是一种模型，它是对现实世界数据特征的抽象。数据模型是数据库系统的核心和基础。 两类数据模型：第一类是概念模型，第二类是逻辑模型和物理模型。 首先将现实世界抽象为信息世界，然后将信息世界转换为机器世界。 概念模型：概念模型最常用的方法是实体-联系方法，E-R方法也称为E-R模型 实体：客观存在并可互相区别的事物称为实体。 属性：实体所具有的某一特性称为属性。 码：唯一标识实体的属性集称为码。 实体型：用实体名及其属性名集合来抽象和刻画同类实体，称为实体型。 实体集：同一类型实体的集合称为实体集 联系：实体之间的联系通常是指不同实体集之间的联系。实体之间的联系有一对一、一对多和多对多等多种类型。数据模型的组成要素 数据结构：数据结构描述数据库的组成对象以及对象之间的联系。 数据操作：数据操作是指对数据库中各种对象（型）的实例（值）允许执行的操作的集合，包括操作及有关的操作规则。 数据的完整性约束条件：数据的完整性约束条件是一组完整性规则。 常用的数据模型 层次模型 网状模型 关系模型 关系模型的数据结构 关系：一个关系对应通常说的一张表 元组：表中的一行即为一个元组 属性：表中的一列即为一个属性，给每一个属性起一个名称即属性名 码：也称码键。表中的某个属性组，它可以唯一确定一个元组 域：域是一组具有相同数据类型的值的集合 分量：元组中的一个属性值 关系模型要求关系必须是规范的，关系的每一个分量必须是一个不可分的数据项 关系模型的数据操纵与完整性约束 关系模型中的数据操作是集合操作，操作对象和操作结果都是关系。关系模型把存取路径向用户隐蔽起来 关系模型的优缺点 关系模型与格式化模型不同，他是建立在严格的数学基础上的。 关系模型的概念单一 关系模型的存取路径对用户透明 面向对象数据模型 对象关系数据模型 半结构化数据模型 数据库系统的结构 数据库系统模式的概念：在数据模型中有“型”和“值”的概念。型是指对某一类数据的结构和属性的说明，值是型的一个具体赋值。 模式是相对稳定的，而实例是相对变动的。 数据库系统的三级模式结构图： 三级模式 模式：模式也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。 外模式：外模式也称子模式或用户模式，它是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。 内模式：内模式也称存储模式，一个数据库只有一个内模式。它是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式。 数据库的二级映像功能与数据独立性 外模式/模式映像：当模式改变时(例如增加新的关系、新的属性、改变属性的数据类型等)，由数据库管理员对各个外模式/模式的映像作相应改变，可以使外模式保持不变。应用程序是依据数据的外模式编写的，从而应用程序不必修改，保证了数据与程序的逻辑独立性，简称数据的逻辑独立性。 模式/内模式映像：当数据库的存储结构改变时(例如选用了另一种存储结构)，由数据库管理员对模式/内模式映像作相应改变，可以使模式保持不变，从而应用程序也不必改变。保证了数据与程序的物理独立性，简称数据的物理独立性。 数据与程序之间的独立性使得数据的定义和描述可以从应用程序中分离出去。另外，由于数据的存取由数据库管理系统管理，从而简化了应用程序的编制，大大减少了应用程序的维护和修改。 据库系统的组成 包括硬件平台及数据库、软件、人员。 数据库管理员(DBA)职责： 决定数据库中的信息内容和结构 决定数据库的存储结构和存储策略 定义数据的安全性要求和完整性约束条件 监控数据库的使用和运行 数据库的改进和重组、重构 第二章 关系数据库关系数据结构及形式化定义 关系 域：域是一组具有相同数据类型的值的集合。 笛卡尔积：笛卡尔积定义，给定一组域D1,D2,…,Dn，允许其中某些域是相同的，D1,D2,…,Dn的笛卡尔积为 ​ D1\\D2*…*Dn = {(d1,d2,…,dn)|di属于Di,i=1,2,…,n}*​ 其中，每一个元素(d1,d2,…,dn)叫作一个n元组，或简称元组。元素中的每一个值di叫作一个分量。​ 一个域允许的不同取值个数称为这个域的基数。 关系：定义，D1*D2*…*Dn的子集叫做在域D1,D2,…,Dn上的关系，表示为R(D1,D2,…,Dn)这里R表示关系的名字,n是关系的目或度。当n = 1时，称该关系为一元关系。当n = 2时，称该关系为二元关系。 某一属性组的值能唯一的标识一个元组，而其子集不能，则称该属性组为候选码。若一个关系有多个候选码，则选定其中一个为主码。候选码的诸属性称为主属性。不包含在任何候选码中的属性称为非主属性或非码属性。在最简单的情况下，候选码只包含一个属性。在最极端的情况下，关系模式的所有属性是这个关系模式的候选码，称为全码。 关系可以有三种类型：基本关系(通常又称为基本表或基表)、查询表和视图表。 关系的性质： 列是同质的，即每一列中的分量是同一类型的数据，来自同一个域。 不同的列可出自同一个域，称其中的每一列为一个属性，不同的属性要给予不同的属性名。 列的顺序无所谓，即列的次序可以任意交换。 任意两个元组的候选码不能取相同的值。 行的顺序无所谓，即行的次序可以任意交换。 分量必须取原子值，即每一个分量都必须是不可分的数据项 这些规范条件中最基本的一条就是，关系的每一个分量必须是一个不可分的数据项。规范化的关系简称为范式(NF)。 关系模式 关系的描述称为关系模式。它可以形式化的表示为R(U,D,DOM,F)。其中R为关系名，U为组成改关系的属性名集合，D为U中属性所来自的域，DOM为属性向域的映像集合，F为属性间数据的依赖关系集合。 关系数据库 关系数据库也有型和值之分。关系数据库的型也称为关系数据库模式，是对关系数据库的描述。关系数据库的值是这些关系模式在某一时刻对应的关系的集合，通常就称为关系数据库。 关系操作 基本的关系操作：关系模型中常用的关系操作包括查询操作和插入、删除、修改操作两大部分。 关系的查询表达能力很强，是关系操作中最主要的部分。查询操作又可以分为旋转、投影、连接、除、并、差、交、笛卡尔积等。其中选择、投影、并、差、笛卡尔积是5种基本操作。 关系操作的特点是集合操作方式，即操作的对象和结果都是集合。这种操作方式也称为一次一集合的方式。相应的非关系数据模型的数据操作方式则为一次一记录的方式。 关系数据语言的分类 早期的关系操作能力通常用代数方式或逻辑方式来表示，分别称为关系代数和关系演算。关系代数用对关系的运算来表达查询要求，关系演算则用谓词来表达查询要求。关系演算又可按谓词变元的基本对象是元组变量还是域变量分为元组关系演算和域关系演算。 还有一种介于关系代数和关系演算之间的结构化查询语言(SQL)。SQL是集查询、数据定义语言、数据操纵语言和数据控制语言于一体的关系数据语言。 关系的完整性 关系模型中有三类完整性约束：实体完整性、参照完整性和用户定义的完整性。其中实体完整性和参照完整性是关系模型必须满足的完整性约束条件，被称作关系的两个不变性。 实体完整性：实体完整性规则，若属性(指一个或一组属性)A是基本关系R的主属性，则A不能取空值。所谓空值就是“不知道”或“不存在”或“无意义”的值。 对实体完整性规则说明： 实体完整性规则是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集。 现实世界中的实体是可区分的，即它们具有某种唯一性标识。例如每个学生都是独立的个体，是不一样的。 相应的，关系模型中以主码作为唯一性标识。 主码中的属性不能取空值。 参照完整性：设F是基本关系R的一个或一组属性，但不是关系R的码，Ks是基本关系S的码。如果F与Ks相对应，则称F是R的外码，并称基本关系R为参照关系，基本关系S为被参照关系或目标关系。 参照完整性规则：若属性(或属性组)F是基本关系R的外码，它与基本关系S的主码Ks相对应(基本关系R和S不一定是不同的关系)，则对于R中每个元组在F上的值必须： 或者取空值(F的每个属性值均为空值) 或者等于S中某个元组的主码值。 用户定义的完整性 用户定义的完整性就是针对某一具体关系数据库的约束条件，它反映某一具体应用所涉及的数据必须满足的语义要求。 关系代数 关系代数是一种抽象的查询语言，它用对关系的运算来表达查询。 任何一种运算都是将一定的运算符作用于一定的运算对象上，得到预期的运算结果。所以运算对象、运算符、运算结果是运算的三大要素。 关系代数用到的运算符包括两类：集合运算符和专门的关系运算符 关系代数的运算按运算符的不同可分为传统的集合运算和专门的关系运算两类。 传统的集合运算 传统的集合运算是二目运算，包括并、差、交、笛卡尔积四种运算 定义如下： 并：R∪S ={t|t属于R V t属于S} 其结果仍为n目关系，由属于R或属于S的元组组成。 差：R-S = {t|t属于R ∧ t不属于S} 其即结果关系仍为n目关系，由属于R而不属于S的所有元组组成。 交：R∩S = {t|t属于R ∧ t属于S} 其结果关系仍为n目关系，由既属于R又属于S的元组组成。关系的交可以用差来表示，即 R∩S = R - (R - S) 笛卡尔积：R*S = {tr 连ts|tr属于R ∧ ts属于S} 专门的关系运算 专门的关系运算包括选择、投影、连接、除运算 记号： 设关系模式为R(A1,A2,…,An)，它的一个关系设为R。t属于R表示t是R的一个元组。t[Ai]则表示元组t中相应于属性Ai的一个分量。 若A = {Ai1,Ai2,…,Aik}，其中Ai1，Ai2，…，Aik是A1，A2，…，An中的一部分，则A称为属性列或属性组。t[A] = (t[Ai1],t[Ai2],…,t[Aik])表示元组t在属性列A上诸分量的集合，A反则表示{A1,A2,…,An}中去掉{Ai1,Ai2,…,Aik}后剩余的属性组。 R为n目关系，S为m目关系。tr属于R，ts属于S，tr连接ts称为元组的连接或元组的串接。他是一个n+m列的元组前n个分量为R中的一个n元组，后m个分量为S中的一个m元组。 给定一个关系R(X,Z),X和Z为属性组。当t[X] = x时，x在R象集定义为 ​ Zx = {t[Z]|t属于R，t[X] = x} 它表示R中属性组X上值为x的诸元组在Z上分量的集合。 选择：选择又称为限制。它是在关系R中选择满足给定条件的诸元组，记作 的塔F(R) = {t|t属于R ∧ F(t)= ‘真’} 投影：关系R上的投影是从R中选择出若干属性列组成新的关系。记作 pi A(R) = {t[A]|t属于R} 其中A为R中的属性列。投影是从列的角度进行的运算。 连接：连接也称为 θ连接。他是从两个关系的笛卡尔积中选取属性间满足一定条件的元组。记作： 连接运算中有两种最为重要也最为常用的连接，一种是等值连接，另一种是自然连接。θ为“=”的连接运算称为等值连接是从关系R与S的广义笛卡尔积中选取A、B属性值相等的那些元组。自然连接是一种特殊的等值连接，它要求两个关系中进行比较的分量必须是同名的属性组，并且在结果中把重复的属性列去掉。即若R和S中具有相同的属性组B,U为R和S的全体属性集合。一般的连接操作是从行的角度进行运算，但自然连接还需要取消重复列，所以是同时从行和列的角度进行运算。 两个关系R和S在做自然连接时，选择两个关系在公共属性上值相等的元组构成新的关系。此时，关系R中某些元组有可能在S中不存在公共属性上值相等的元组，从而造成R中这些元组在操作时被舍弃，同样，S中某些元组也可能被舍弃。这些被舍弃的元组称为悬浮元组。 如果把悬浮元组也保存在结果关系中，而在其他属性上填空值(NULL)，那么这种连接就叫做外连接，记作R =&gt;&lt;= S;如果只保留左边关系R中的悬浮元组就叫做左外连接R=&gt;&lt;S;如果只保留右边关系S中的悬浮元组就叫做右外连接，记作R&gt;&lt;=S 除运算：设关系R除以关系S的结果为关系T，则T包含所有在R但不在S中的属性及其值，且T的元组与S的元组的所有组合都在R中。 下面用象集来定义除法：给定关系R(X,Y)和S(Y,Z)，其中X,Y,Z为属性组。R中的Y与S中的Y可以有不同的属性名，但必须出自相同的域集。 R与S的除运算得到一个新的关系P(X)，P是R中满足下列条件的元组在X属性列上的投影：元组在X上分量值x的象集Yx包含S在Y上投影的集合。记作：R/S = {Tr[X]|tr属于R ∧ piY(S)包含于Yx} 其中Yx为x在R中的象集，x = tr[X]。除操作是同时从行和列角度进行运算。 R/S -&gt;投影-&gt;象集-&gt;包含 其中并，差，笛卡尔积，选择和投影这五种运算为基本的运算。其他三种运算，即交，连接和除，均可以用这5种基本运算来表达。引进他们并不增加语言的能力，但可以简化表达 关系代数中，这些运算经有限次复合后形成的表达式称为关系代数表达式。 第三章 关系数据库标准语言SQLSQL 概述 SQL 的产生与发展 目前，没有一个数据库系统能够支持SQL标准的所有概念和特性。大部分数据库系统能支持SQL/92标准中的大部分功能以及SQL99、SQL2003中的部分新概念。同时，许多软件厂商对SQL基本命令集还进行了不同程度的扩展和修改，又可以支持标准以外的一些功能特性。 SQL的特点 综合统一 高度非过程化 只要提出“做什么”，而无须指明“怎么做”，因此无须了解存取路径。存取路径的选择以及SQL的操作过程由系统自动完成。 面向集合的操作方式 以同一种语法结构提供多种使用方式 语言简洁，易学易用 数据定义一个关系数据库管理系统的实例中可以建立多个数据库，一个数据库中可以建立多个模式，一个模式下通常包括多个表、视图和索引等数据库对象。 模式的定义与删除 定义模式：在SQL中，模式定义语句如下：create schema &lt;模式名&gt; authorization &lt;用户名&gt; ​ 如果没有指定&lt;模式名&gt;，那么&lt;模式名&gt;隐含为&lt;用户名&gt; 要创建模式，调用该命令的用户必须拥有数据库管理员权限，或者获得了数据库管理员授予的create schema 的权限 目前，create chema 中可以接受 create table，create view和grant 子句。也就是说用户可以在创建模式的同时在这个模式定义中进一步创建基本表、视图。定义授权。即：create schema &lt;模式名&gt; authorization &lt;用户名&gt; [&lt;表定义子句&gt;|&lt;视图定义子句&gt;|&lt;授权定义子句&gt;] 删除模式：在SQL中，删除模式语句如下，drop schema &lt;模式名&gt;&lt;cascade|restrict&gt; 其中cascade和restrict两者必选其一。选择了cascade(级联)，表示在删除模式的同时把该模式中所有的数据库对象全部删除；选择了restrict(限制)，表示如果该模式中已经定义了下属的数据库对象(如表，视图等)，则拒绝该删除语句的执行。只有当该模式中没有任何下属的对象时才能执行 drop schema语句。 基本表的定义、删除与修改 定义基本表：创建了一个模式就建立了一个数据库的命名空间，一个框架。在这个空间中首先要定义的是该模式包含的数据库基本表。SQL语言使用create table 语句定义基本表，其基本格式如下： create table &lt;表名&gt;(&lt;列名&gt;&lt;数据类型&gt;[列级完整性约束条件][,&lt;列名&gt;&lt;数据类型&gt;[列级完整性约束条件]][,表级完整性约束条件]) 参照表和被参照表可以是同一个表 数据类型： 模式与表 每一给基本表都属于某一个模式，一个模式包含多个基本表。当定义基本表时一般可以有三种方法定义它所属的模式，现在要在S-T中定义Student、Course、SC等基本表。 方法一：在表名中明显的给出模式名。 create table ”S-T“.Student(…);Student所属的模式是S-T 方法二：在创建模式语句中同时创建表 方法三：设置所属的模式，这样在创建表时表名中不必给出模式名。 当用户创建基本表(其他数据库对象也一样)时若没有指定模式，系统根据搜索路径来确定该对象所属的模式。 搜索路径包含一组模式列表，关系数据库管理系统会使用模式列表中第一个存在的模式作为数据库对象的模式名。若搜索路径中的模式名都不存在，系统将给出错误。 使用下面的语句可以显示当前的搜索路径： show search_path 搜索路径当前默认值是$user，PUBLIC。其含义是首先搜索与用户名相同的模式名，如果该模式名不存在，则使用PUBLIC模式 数据库管理员也可以设置搜索路径，如：SET search_path TO “S-T”,PUBLIC; 然后，定义基本表。实际结果是建立了S-T.Student基本表。因为关系数据库管理系统发现路径中第一个模式名S-T存在，就把该模式作为基本表Studnt所属的模式。 修改基本表 SQL语言用alter table语句修改基本表，其一般格式为 alter table &lt;表名&gt; [add [column] &lt;新列名&gt;&lt;数据类型&gt;[完整性约束]] [add &lt;表级完整性约束&gt;] [drop [column] &lt;列名&gt;[cascade|restrict]] [drop constraint &lt;完整性约束名&gt; [restrict|cascade]] [alter column &lt;列名&gt;&lt;数据类型&gt;] 删除基本表 drop table &lt;表名&gt;[restrict|cascade] 若选择restrict，则该表的删除是有限制条件的。欲删除的基本表不能被其他表的约束所引用(如cheack，foreign key等约束)，不能有视图，不能有触发器，不能有存储过程或函数等。如果存在这些依赖该表的对象，则此表不能被删除。 若选择cascade，则该表的删除没有限制条件。在删除基本表的同时，相关的依赖对象，例如视图，都将被一起删除。 默认情况是restrict 索引的建立与删除 数据库索引有多种类型，常见索引包括顺序文件上的索引、B+树索引、散列索引、位图索引等。顺序文件上的索引是针对按指定属性值升序或降序存储的关系，在该属性上建立一个顺序索引文件，索引文件由属性值和相应的元组指针组成。B+树索引是将索引属性组织成B+树形式，B+树的叶结点为属性值和相应的元组指针。B+树索引具有动态平衡的优点。散列索引是建立若干个桶，将索引属性按照其散列函数值映射到相应桶中，桶中存放索引属性值和相应的元组指针。散列索引具有查找速度快的特点。位图索引是用位向量记录所有属性中可能出现的值，每个位向量对于一个可能值。 关系数据库管理系统在执行查询时会自动选择合适的索引作为存取路径，用户不必也不能显式的选择索引。 建立索引：在SQL语言中，建立索引使用 create index 语句，一般格式为 create [unique][cluster] index &lt;索引名&gt; on &lt;表名&gt;(&lt;列名&gt;[&lt;次序&gt;][,&lt;列名&gt;[&lt;次序&gt;]]…) 其中，&lt;表名&gt;是要建索引的基本表的名字。索引可以建立在该表的一列或多列上，各列名之间用逗号分隔。每个&lt;列名&gt;后面还可以用&lt;次序&gt;指定索引值的排列次序，可选ASC(升序)或DESC(降序)，默认值为ASC. UNIQUE表明此索引每一个索引值只对应唯一的数据记录。 CLUSTER 表示要建立的索引是聚簇索引。 修改索引 对于已经建立的索引，如果需要对其重新命名，可以使用ALTER INDEX 语句。其一般格式为： ALTER INDEX &lt;旧索引名&gt; RENAME TO &lt;新索引名&gt; 删除索引 在SQL中，删除索引使用DROP INDEX语句，其一般格式为 DROP INDEX &lt;索引名&gt; 数据字典 数据字典是关系数据库管理系统内部的一组系统表，它记录了数据库中所有的定义信息，包括关系模式定义，视图定义，索引定义，完整性约束定义，各类用户对数据库的操作权限，统计信息等。 数据查询 数据查询是数据库的核心操作。SQL提供了SELECT语句进行数据查询，该语句具有灵活的使用方式和丰富的功能。其一般格式为 select [all|distinct] &lt;目标列表达式&gt;[,&lt;目标列表达式&gt;]… from &lt;表名或视图名&gt; [,&lt;表名或视图名&gt;…]|(&lt;select语句&gt;)[AS]&lt;别名&gt; [where&lt;条件表达式&gt;] [group by &lt;列名1&gt;[having&lt;条件表达式&gt;]] [order by&lt;列名2&gt;[asc|desc]] 整个select语句的含义是，根据where子句的条件表达式从from子句指定的基本表、视图或派生表中找出满足条件的元组，再按select子句中的目标列表达式选出元组中的属性值形成结果表。 如果由group by 子句，则将结果按&lt;列名1&gt;的值进行分组，该属性列值相等的元组为一组。通常会在每组中作用聚集函数。如果 group by子句带having短语，则只有满足指定条件的组才予以输出。 如果有order by子句，则结果表还有按&lt;列名2&gt;的值升序或降序排序。 select语句既可以完成简单的单表查询，也可以完成复杂的连接查询和嵌套查询。 单表查询 选择表中的若干列 查询指定列：如select Sno，Sname from Student。各个列的顺序可以与表中的顺序不一致 查询全部列：如select * from Student 查询经过计算的值：select 子句的&lt;目标列表达式&gt;不仅可以使表中的属性列，也可以是表达式。如：select Sname，‘Year of Birth：’，2014-Sage BIRTHDAY from Student 选择表中的若干元组 消除取值重复的行 两个本科并不完全相同的元组在投影到指定的某些列上后，可能会变成相同的行。可以使用distinct消除他们。 如：select distinct Sno from SC 查询满足条件的元组 查询满足条件的元组可以通过where子句实现。where子句常用的查询条件 比较大小 确定范围：谓词between…and…和not between…and…可以用来查找属性值在(或不在)指定范围内的元组，其中between后是范围的下限(即低值)，and后是范围的上限(即高值)。 字符匹配 谓词like可以用来进行字符串的匹配。其一般语法格式如下： [not] like ‘&lt;匹配串&gt;’ [escape’&lt;换码字符&gt;’] 其含义是查找指定的属性列值与&lt;匹配串&gt;相匹配的元组。&lt;匹配串&gt;可以是一个完整的字符串，也可以含有通配符%和_。其中： %(百分号)代表任意长度(长度可以为0)的字符串。例如a%b表示以a开头，以b结尾的任意长度的字符串。 _(下横线)代表任意单个字符 如果用户要查询的字符串本身就含有通配符%或_,这是就要使用escape ‘&lt;换码字符&gt;’ 短语对通配符进行转义了。 涉及空值的查询 IS和NOT IS 多重条件查询 AND 和 OR order by子句 用户可以用order by子句对查询结果按照一个或多个属性列的升序(asc)或降序(desc)排列，默认值为升序。 对于空值，排序时显示的次序由具体系统实现来决定。例如按升序排，含空值的元组最后显示；按降序排，空值的元组则最先显示。各个系统的实现可以不同，只要保持一致就行。 聚集函数 为了进一步方便用户，增强检索功能，SQL提供了许多聚集函，主要有： 聚集函数 作用 count(*) 统计元组个数 count([distinct\\ all]&lt;列名&gt;) 统计一列中值的个数 sum([distinct\\ all]&lt;列名&gt;) 计算一列值的总和(此列必须是数值型) sum([distinct\\ all]&lt;列名&gt;) 计算一列值的平均值(此列必须是数值型) max([distinct\\ all]&lt;列名&gt;) 求一列值中的最大值 min([distinct\\ all]&lt;列名&gt;) 求一列值中的最小值 如果指定distinct短语，则表示在计算时要取消指定列中的重复值。如果不指定distinct短语或指定all短语(all为默认值)，则表示不取消重复值。 当聚集函数遇到空值时，除count(*)外，都跳过空值而只处理非空值。聚集函数只能用于select子句和group by中的having子句。 group by子句 group by子句将查询结果按某一列或多列的值分组，值相等的为一组。 对查询结果分组的目的是为了细化聚集函数的作用对象。如果未对查询结果分组，聚集函数将作用于整个查询结果。分组后聚集函数将作用于每一个组，即每一组都有一个函数值。 例子：见课本P99 例3.48 连接查询 若一个查询同时涉及两个以上的表，则称之为连接查询。连接查询是关系数据库中最主要的查询，包括等值连接查询、自然连接查询、非等值连接查询、自身连接查询、外连接查询和复合条件连接查询等。 等值与非等值连接查询 连接查询的where子句中用来连接两个表的条件称为连接条件或连接谓词其一般格式为 [&lt;表名1&gt;.]&lt;列名1&gt;&lt;比较运算符&gt;[&lt;表名2&gt;.]&lt;列名2&gt; 此外连接谓词还可以使用下面形式： [&lt;表名1&gt;.]&lt;列名1&gt; between [&lt;表名2&gt;.]&lt;列名2&gt; and [&lt;表名3&gt;.]&lt;列名3&gt; 当连接运算符为=时，称为等值连接。使用其他运算符称为非等值连接。 连接谓词中的列名称为连接字段。连接条件中的各连接字段类型必须是可比的，但名字不必相同。 关系数据库管理系统执行该连接操作的一种可能过程是：首先在表Student中找到第一个元组，然后从头开始扫描SC表，逐一查找与Student第一个元组的Sno相等的SC元组，找到后就将Student中的第一个元组与该元组拼接起来，形成结果表中的一个元组。SC全部查找完后，再找Student中第二个元组，然后再从头开始扫描SC，逐一查找满足连接条件的元组，找到后就将Student中的第二个元组与该元组拼接起来，形成结果表中一个元组。重复以上操作。这就是嵌套循环连接算法的基本思想。 如果在SC表Sno上建立了索引的化，就不用每次全表扫描SC表了，而是根据Sno值通过索引找到相应的SC元组。用索引查询SC中满足条件的元组一般会比全表扫描快。若在等值连接中把目标列中重复的属性列去掉则为自然连接。 一条SQL语句可以同时完成选择和连接查询，这时where子句是由连接谓词和选择谓词组成的复合条件。 自身连接 连接操作不仅可以在两个表之间进行，也可以是一个表与其自己进行连接，称为表的自身连接。例：select FIRST.Cno，SECOND.Cpno ​ from Course FIRST,Course SECOND ​ where FIRST.Cpno = SECOND.Cno 外连接 若某个学生没有选课，仍把Student的悬浮元组保存在结果关系中，而在SC表的属性上填空值NULL，这时就需要使用外连接。 左外连接列出左边关系中所有的元组，右外连接列出右边关系中所有的元组。 多表连接 连接操作处理可以是两表连接、一个表与其自身连接外，还可以是两个以上的表进行连接，猴子通常称为多表连接。 嵌套查询 在SQL语言中，一个select-from-where语句称为一个查询块。将一个查询块嵌套在另一个查询块的where子句或having短语的条件中的查询称为嵌套查询。上层的查询块称为外层查询或父查询，下层查询块称为内层查询或子查询。 SQL语言允许多层嵌套查询，即一个子查询中还可以嵌套其他子查询。需要特别指出的是，子查询的select语句中不能使用order by子句，order by子句只能对最终查询结果排序。 嵌套查询使用户可以用多个简单查询构成复杂的查询，从而增强SQL的查询能力。以层层嵌套的方式来构造程序正是SQL中”结构化“的含义所在。 带有in谓词的子查询 子查询的查询条件不依赖于父查询，称为不相关子查询 实现同一个查询请求可以有多种方法，当然不同的方法其执行效率可能会有差别，甚至会差别很大。这就是数据库编程人员应该掌握的数据库性能调优技术。 有些嵌套查询可以用连接运算代替，有些是不能替代的。 查询的查询条件不依赖于父查询，这类子查询称为不相关子查询。不相关子查询是较简单的一类子查询。如果子查询的查询条件依赖于父查询，这类子查询称为相关子查询，整个查询语句称为相关嵌套查询语句。 带有比较运算符的子查询 x是表SC的别名，又称为元组变量，可以用来表示SC的元组。内层查询是求一个学生所有选修课程平均成绩的，至于是哪个学生的平均成绩要看参数x.Sno的值，而该值是与父查询相关的，因此这类查询称为相关子查询。 求解相关子查询不能像求解不相关子查询那样一次将子查询求解出来，然后求解父查询。内层查询由于与外层查询有关，因此必须反复求值。 带有any(some) 或 all 谓词的子查询 子查询返回单值时可以用比较运算符，但返回多值时要用any(有的系统用some)或all谓词修饰符。而使用any或all谓词时则必须同时使用比较运算符。 &gt;any 大于子查询结果中的某个值 &gt;all 大于子查询结果中的所有值 例子见课本P107 例3.58 例子中的查询也可以用聚集函数来实现，事实上，用聚集函数实现子查询通常比直接用any或all查询效率要高。 带有exists谓词的子查询 exists代表存在量词∃。带有exists谓词的子查询不返回任何数据，只产生逻辑真值”true”或逻辑假值”false”。 例子：课本P109 例3.60 使用存在量词exists后，若内层查询结果非空，则外层的where子句返回真值，否则返回假值。 由exists引出的子查询，其目标列表达式通常都用*，因为带exists的子查询只返回真值或假值，给出列名无实际意义。 与exists谓词相对应的是not exists谓词。使用存在量词not exists后，若内层查询结果为空，则外层的where子句返回真值，否则返回假值。 一些带exists 或 not exists谓词的子查询不能被其他形式的子查询等价替换，但所有带in谓词、比较运算符、any和all谓词的子查询都能用带exists谓词的子查询等价替换。 SQL中没有全称量词，但是可以把带有全称量词的谓词转换为等价的带有存在量词的谓词 例子：课本P110 例3.62、3.63 集合查询 select 语句的查询结果是元组的集合，所以多个select语句的结果可进行集合操作。集合操作主要包括并操作union、交操作intersect和差操作except。 使用union将多个查询结果合并起来时，系统会自动去掉重复元组。如果要保留重复元组则用union all操作符。 基于派生表的查询 子查询不仅可以出现在where子句中，还可以出现在from子句中，这时子查询生成的临时派生表成为主查询的查询对象。 select Sno,Cno from SC,(select Sno,Avg(Grade) from SC group by Sno) as Avg_sc(avg_sno,avg_grade) where SC.Sno = Avg_sc.avg_sno and SC.Grade &gt;= Avg_grade 这里from子句中的子查询将生成一个派生表Avg_sc。该表由avg_sno和avg_grade两个属性组成，记录了每个学生的学号及平均成绩。主查询将SC表与Avg_sc按学号相等进行连接，选出选修课成绩大于其平均成绩的课程号。 通过from子句生成派生表时，as关键字可以省略，但必须为派生关系指定一个别名。 select 语句的一般格式： select [ALL|DISTINCT]&lt;目标列表达式&gt;[别名][,&lt;目标列表达式&gt;[别名]]… from &lt;表名或视图名&gt;[别名][,&lt;表名或视图名&gt;[别名]]…|()[as]&lt;别名&gt; [where &lt;条件表达式&gt;] [group by&lt;列名1&gt;[having1&lt;条件表达式&gt;]] [order by&lt;列名2&gt;[asc|desc]] 目标列表达式的可选格式 聚集函数的一般格式 where子句的条件表达式的可选格式 数据更新数据更新操作有三种:向表中添加若干行数据、修改表中的数据和删除表中的若干行数据。 插入数据 插入元组 insert into &lt;表名&gt;[(&lt;属性列1&gt;[,&lt;属性列2&gt;]…)]values(&lt;常量1&gt;[,常量2]…) 在into子句中指出了表名Student，并指出了新增加的元组在哪些属性上要赋值，属性的顺序可以与create table中的顺序不一样。values子句对新元组的各属性赋值，字符串常数要用单引号(英文符合)括起来。 例： insert into SC(Sno,Cno) values(‘201215128’,’1’) 关系数据库管理系统将在新插入记录的Grade列上自动的赋空值。 或 insert into SC values(‘201215128’,’1’,NULL) 因为没有指出SC的属性名，在Grade列上要明确给出空值。 插入子查询结果 插入子查询结果的insert 语句格式为 insert into &lt;表名&gt;[(&lt;属性列1&gt;[,&lt;属性列2&gt;…]） 子查询； 修改数据 修改操作又称为更新操作，其语句的一般格式为 update &lt;表名&gt; set &lt;列名&gt;=&lt;表达式&gt;[，&lt;列名&gt;=&lt;表达式&gt;]… [where &lt;条件&gt;] 其功能是修改指定表中满足where子句条件的元组。其中set子句给出&lt;表达式&gt;的值用于取代相应的属性列值。如果省略where子句，则表示要修改表中的所有元组。 修改某一个元组的值 例3.73 将学生201215121的年龄改为22岁 update Student set Sage=22 where Sno=’201215121’ 修改多个元组的值 例 3.74 将所有学生的年龄增加1岁 update Student set Sage=Sage+1 带子查询的修改语句 子查询也可以嵌套在update语句中，用以构造修改的条件 例 3.75 将计算机科学系全体学生的成绩置零。 update SC set Grade=0 where Sno in(select Sno from Student where Sdept=’CS’) 删除数据 删除语句的一般格式为 delete from &lt;表名&gt; [where &lt;条件&gt;]； 删除某一个元组的值 删除多个元组的值 带子查询的删除语句 空值的处理所谓的空值就是”不知道”或”不存在”或”无意义”的值。 SQL语言中允许某些元组的某些属性在一定情况下取空值。 一般有以下几种情况： 该属性应该有一个值，但目前不知道它的具体值。 该属性不应该有值。 由于某种原因不便于填写。 空值的产生 插入和连接会产生空值。空值的关系运算也会产生空值。 空值的判断 判断一个属性的值是否为空值，用 IS NULL或IS NOT NULL来表示。 空值的约束条件 属性定义(或者域定义)中有 NOT NULL约束条件的不能取空值，码属性不能取空值。 空值的算术运算、比较运算和逻辑运算 空值与另一个值(包括另一个空值)的算术运算的结果为空值，空值与另一个值(包括另一个空值)的比较运算的结果为unknow。有了unknown后，传统的逻辑运算中二值(true,false)逻辑就扩展成了三值逻辑。 视图视图是从一个或几个基本表(或视图)导出的表。它与基本表不同，是一个虚表。数据库中只存放视图的定义，二不存放视图对应的数据，这些数据仍存放在原来的基本表中。所以一旦基本表中的数据发生变化，从视图中查询出的数据也就随之改变了。视图一经定义，就可以和基本表一样被查询、被删除。 定义视图 建立视图 SQL语言用create view命令建立视图，其一般格式为 create view &lt;视图名&gt;[(&lt;列名&gt;[,&lt;列名&gt;]…)] as &lt;子查询&gt; [with check option] 其中，子查询可以是任意的select语句，是否可以含有order by子句和distinct短语，则取决于具体系统的实现。 with check option 表示对视图进行update、insert和delete操作时要保证更新、插入或删除的行满足视图定义中的谓词条件(即子查询中的条件表达式)。 组成视图的属性列名或者全部省略或者全部指定，没有第三种选择。如果省略了视图的各个属性列名，则隐含该视图由子查询中select子句目标列中的诸字段组成。但在下列三种情况下必须明确指定组成视图的所有列名: 某个目标列不是单纯的属性名，而是聚集函数或列表达式 多表连接时选出了几个同名列作为视图的字段 需要在视图中为某个列启用新的更合适的名字 关系数据库管理系统执行create view语句的结果只是把视图的定义存入数据字典，并不执行其中的select语句。只是在对视图查询时，才按视图的定义从基本表中将数据查出。 由于在定义IS_Student视图时加上了with check option子句，以后对该视图进行插入、修改和删除操作时，关系数据库管理系统会自动加上Sdept=’IS‘的条件。P122 例：3.85 若一个视图是从单个基本表导出的，并且只是去掉了基本表的某些行和某些列，但保留了主码，则称这类视图为行列子集视图。 视图不仅可以建立在一个或多个基本表上，也可以建立在一个或多个已定义好的视图上，或建立在基本表与视图上。 定义基本表时，为了减少数据库中的冗余数据，表中只存放基本数据，由基本数据经过各种计算派生吃的数据一般是不存储的。由于视图中的数据并不实际存储，所以定义视图时可以根据应用的需要设置一些派生属性列。这些派生属性由于在基本表中并不实际存在，也称它们为虚拟列。带虚拟列的视图也称为带表达式的视图。例 P123 例3.88 删除视图 该语句的格式为 drop view &lt;视图名&gt;[cascade]; 视图删除后视图的定义将从数据字典中删除。如果该视图上还导出了其他视图，则使用cascade级联删除语句把该视图和由它导出的所有视图一起删除。 基本表删除后，由该基本表导出的所有视图均无法使用，但是视图的定义没有从字典中清除。删除这些视图定义需要显式的使用drop view语句。 查询视图 关系数据库管理系统执行对视图的查询时，首先进行有效性检查，检查查询中涉及的表、视图等是否存在。如果存在，则从数据字典中取出视图的定义，把定义中的子查询和用户的查询结合起来，转换成等价的对基本表的查询，然后再执行修正了的查询。这一转换过程称为视图消解。 目前多数关系数据库系统对行列子集视图的查询均能进行正确转换。但对非行列子集视图的查询就不一定能做转换了，因此这类查询应该直接对基本表进行。 但定义视图并查询视图与基于派生表的查询是有区别的。视图一旦定义，其定义将永久保存在数据字典中，之后的所有查询都可以直接引用该视图。而派生表只是在语句执行时临时定义，语句执行后该定义即被删除。 更新视图 更新视图是指通过视图来插入、删除和修改数据。 由于视图是不实际存储数据的虚表，因此对视图的更新最终要转换为对基本表的更新。像查询视图那样，对视图的更新操作也是通过视图消解，转换为对基本表的更新操作。 为防止用户通过视图对数据进行增加、删除、修改时，有意无意的对不属于视图范围内的基本表数据进行操作，可在定义视图时加上with check option子句。这样在视图上增、删、改数据时，关系数据库管理系统会检查视图定义中的条件，若不满足条件则拒绝执行该操作。 在关系数据库中，并不是所有的视图都是可更新的，因为有些视图的更新不能唯一的有意义的转换成对相应基本表的更新。 一般的，行列子集视图是可更新的。除行列子集视图外，有些视图理论上是可更新的，但他们的确切特征还是尚待研究的课题。还有些视图从理论上就是不可更新的。 目前，各个关系数据库管理系统一般都只允许对行列子集视图进行更新，而且各个系统对视图的更新还有更进一步的规定。由于各系统实现方法上的差异，这些规定也不尽相同。 一个不允许更新的视图上定义的视图也不允许更新，不可更新的视图与不允许更新的视图是两个不同的概念。 视图的作用 视图最终是定义在基本表之上的，对视图的一起操作最终也要转换为对基本表的操作。 视图能够简化用户的操作 视图能够是用户以多种角度看待同一组数据 视图对重构数据库提供了一定程度的逻辑独立性 这样尽管数据库的逻辑结构改变了(变为SX和SY两个表)，但应用程序不必修改，因为新建立的视图定义为用户原来的关系，使用户的外模式保持不变，用户的应用程序通过视图仍然能够查找数据。 视图能够对机密数据提供安全保护 适当利用视图可以更清晰的表达查询 第四章 数据库安全性数据库安全性概述数据库的安全性是指保护数据库以防止不合法使用所造成的数据泄露、更改或破坏。 数据库的不安全因素 非授权用户对数据库的恶意存取和破坏 数据库中重要或敏感的数据被泄漏 安全环境的脆弱性 安全标准简介 为满足全球IT市场上互认标准化安全评估结果的需要，CTCPEC、FC、TCSEC和ITSEC的发起组织于1993年起开始联合行动，解决标准中概念和技术上的差异，将各自独立的准则集合成一组单一的、能被广泛使用的IT安全准则，这一行动被称为通用准则(CC)项目。项目发起组织的代表建立了专门的委员会来开发通用准则，经历多次讨论和修订，CCV2.1版于1999年被ISO采用为国际标准，2001年被我国采用为国家标准。 TCSEC又称桔皮书。1991年4月，美国国家计算机安全中心颁布了《可信计算机系统评估准则关于可信数据库系统的解释》(即紫皮书)，将TCSEC扩展到数据库管理系统。TCSEC/TDI中定义了数据库管理系统的设计与实现中需满足和用以进行安全性级别评估的标准，从4个方面来描述安全性级别划分的指标，即安全策略、责任、保证和文档。每个方面又细分为若干项。 根据计算机系统对各项指标的支持情况，TCSEC/TDI将系统划分为4组7个等级，依次是D、C(C1,C2)、B(B1,B2,B3)、A(A1),按系统可靠或可信程度逐渐增高 D级：该级是最低级别。保留D级的目的是为了将一切不符合更高标准的系统统统归于D组。如DOS就是操作系统中安全标准为D级的典型例子，它具有操作系统的基本功能，如文件系统、进程调度等，但在安全性方面几乎没有什么专门的机制来保障。 C1级：该级只提供了非常初级的自主安全保护，能够实现对用户和数据的分离，进行自主存取控制(DAC),保护或限制用户权限的传播。现有的商业系统往往稍作改进即可满足要求。 C2级：该级实际上是安全产品的最低档，提供受控的存取保护，即将C1级的DAC进一步细化，以个人身份注册负责，并实施审计和资源隔离。达到C2级的产品在其名称中往往不突出”安全”这一特色，如操作系统中的window 2000、数据库产品中的Oracle 7等。 B1级：标记安全保护。对系统的数据加以标记，并对标记的主体和客体实施强制存取控制(MAC)以及审计等安全机制。B1级别的产品才被认为是真正意义上的安全产品，满足此级别的产品前一般多冠以”安全”或可信的字样，作为区别于普通产品的安全产品出售。 B2级：结构化保护。建立形式化的安全策略模型，并对系统内的所有主体和客体实施DAC和MAC。 B3级：安全域。该级的TCB必须满足访问监控器的要求，审计跟踪能力更强，并提供系统恢复过程。 A1级：验证设计，即提供B3级保护的同时给出系统的形式化设计说明和验证，以确信各安全保护真正实现。 CC评估保障即的划分 的划分.jpg) 粗略而言，TCSEC的C1和C2级分别相当于EAL2和EAL3；B1、B2和B3分别相当于EAL4、EAL5和EAL6；A1对应于EAL7。 数据库安全性控制在一般计算机系统中，安全措施是一级一级层层设置的。 下面讨论与数据库有关的安全性，主要包括用户身份鉴别、多层存取控制、审计、视图和数据加密等安全技术。 用户身份鉴别 静态口令鉴别 动态口令鉴别 生物特征鉴别 智能卡鉴别 存取控制 数据库安全最重要的一点就是确保只授权给有资格的用户访问数据库的权限，同时令所有未被授权的人员无法接近数据，这主要通过数据库系统的存取控制机制实现。 存取控制机制主要包括定义用户权限和合法权限检查两部分。 定义用户权限，并将用户权限登记到数据字典中 用户对某一数据对象的操作权力称为权限。某个用户应该具有何种权限是个管理问题和政策问题，而不是技术问题。数据库管理系统的功能是保证这些决定的执行。为此，数据库管理系统必须提供适当的语言来定义用户权限，这些定义经过编译后存储在数据字典中，被称做安全规则活授权规则 合法权限检查 每当用户发送存取数据库的操作请求后(请求一般包括操作类型、操作对象和操作用户等信息)，数据库管理系统查找数据字典，根据安全规则进行合法权限检查，若用户的操作请求超出了定义的权限，系统将拒绝执行此操作。 定义用户权限和合法权限检查机制一起组成了数据库管理系统的窜去控制子系统。 C2级的数据库管理系统支持自主存取控制，B1级的数据库管理系统支持强制存取控制。 两类方法的简单定义： 在自主存取控制方法中，用户对于不同的数据库对象有不同的存取权限，不同的用户对同一对象也有不同的权限，而且用户还可将其拥有的存取权限转授给其他用户。因此自主存取控制非常灵活。 在强制存取控制方法中，每一个数据库对象被标以一定的密级，每一个用户也被授予某一个级别的许可证。对于任意一个对象，只有具有合法许可证的用户才可以存取。因此强制存取控制因此相对比较严格。 自主存取控制方法 大型数据库管理系统都支持自主存取控制，SQL标准也对自主存取控制提供支持，这主要通过SQL的GTANT语句和REVOKE语句来实现。 用户权限是由两个要素组成的:数据库对象和操作类型。定义一个用户的存取权限就是要定义这个用户可以在哪些数据库对象上进行哪些类型的操作。在数据库系统中，定义存取权限称为授权。 在非关系系统中，用户只能对数据进行操作，存取控制的对象不仅有数据本身(基本表中的数据、属性列上的数据)，还有数据库模式(包括模式、基本表、视图和所有的创建等) 授权：授予与收回 SQL中使用GRANT和REVOKE语句向用户授予或收回对数据的操作权限。GRANT语句向用户授予权限，REVOKE语句收回以及授予用户的权限。 GRANT GRANT语句的一般格式为 GRANT &lt;权限&gt;[,&lt;权限&gt;]… ON &lt;对象类型&gt;&lt;对象名&gt;[,&lt;对象类型&gt;&lt;对象名&gt;]… TO &lt;用户&gt;[,&lt;用户&gt;]… [WITH GRANT OPTION] 其语义为：将对指定操作对象的指定操作权限授予指定的用户。发出该GRANT语句的可以是数据库管理员，也可以是该数据库对象创建者(即属主owner)，还可以是已经拥有该权限的用户。接受权限的用户可以是一个或多个具体用户，也可以是PUBLIC，即全体用户。 如果指定了 with grant option子句，则获得某种权限的用户还可以把这种权限再授予其他的用户。没有指定with grant option子句，则获得某种权限的用户只能使用该权限，不能传播该权限。 SQL标准允许具有with grant option的用户把相应权限或其子集传递授予其他用户，但不允许循环授权，即被授权者不能把权限再授回给授权者或其祖先。 REVOKE 授予用户的权限可以由数据库管理员或其他授权者用revoke 语句收回，revoke语句的一般格式为 REVOKE &lt;权限&gt;[,&lt;权限&gt;]… ON &lt;对象类型&gt;&lt;对象名&gt;[,&lt;对象类型&gt;&lt;对象名&gt;]… FROM &lt;用户&gt;[,&lt;用户&gt;]…[cascade|restrict] 所有授予出去的权力在必要时又都可以用revoke语句收回。 可见，用户可以”自主“的决定将数据的存取权限授予何人、决定是否也将”授权“的权限授予别人。因此称这一的存取控制是自主存取控制。 创建数据库模式的权限 GRANT和REVOKE语句向用户授予或收回对数据的操作权限。对创建数据库模式的一类的数据库对象的授权则由数据库管理员在创建用户时实现。 create user语句一般格式如下： create user [with][DBA|RESOURCE|CONNECT] 对create user语句说明如下： 只有系统的超级用户才有权创建一个新的数据库用户 新创建的数据库用户有三种权限：connec他、resource和dba。 create user命令中如果没有指定创建的新用户的权限，默认该用户拥有connect权限。拥有connect权限的用户不能创建新用户，不能创建模式，也不能创建基本表，只能登入数据库。由数据库管理员或其他用户授予它应由的权限，根据获得的授权情况他可以对数据库对象进行权限范围内的操作。 拥有resource权限的用户能创建基本表和视图，成为所创建对象的属主但不能创建新的用户。数据库对象的属主可以使用grant语句把该对象上的存取权限授予其他用户。 拥有DBA权限的用户是系统中的超级用户，可以创建新的用户、创建模式、创建基本表和视图等；DBA拥有对所有数据库对象的存取权限，还可以把这些权限授予一般用户。 注意：create user语句不上SQL标准，因此不同的关系数据库管理系统的语法和内容相差甚远。 数据库角色 数据库角色是被命名的一组与数据库操作相关的权限，角色是权限的集合。 角色的创建 创建角色的SQL语句格式是 create role &lt;角色名&gt; 刚刚创建的角色是空的，没有任何内容。可以用grant为角色授权。 给角色授权 grant &lt;权限&gt;[,&lt;权限&gt;]… on &lt;对象类型&gt;对象名 to &lt;角色&gt;[,&lt;角色&gt;]… 数据库管理员和用户可以利用grant语句将权限授予某一个或几个角色。 将一个角色授予其他的角色或用户 grant &lt;角色1&gt;[,&lt;角色2&gt;]… to &lt;角色3&gt;[,&lt;用户1&gt;]… [with admin option] 该语句把角色授予某用户，或授予另一角色。这样，一个角色所拥有的权限就是授予它的全部角色所包含的权限的总和。 授予者或者是角色的创建者忙活着拥有在这个角色上的admin option。 如果指定了with admin option子句，则获得某种权限的角色或用户还可以把这种权限再授予其他的角色 一个角色包含的权限包括直接授予这个角色的全部权限加上其他角色授予这个角色的全部权限。 角色权限的收回 revoke &lt;权限&gt;[,&lt;权限&gt;]… on &lt;对象类型&gt;&lt;对象名&gt; from &lt;角色&gt;[,&lt;角色&gt;]… 用户可以收回角色的权限，从而修改角色拥有的权限。 revoke 动作的执行者或者是角色的创建者，或者拥有在这个(些)角色上的ADMIN OPTION. 强制存取控制方法 在强制存取控制中，数据库管理系统所管理的全部视图被分为主体和客体两大类。 主体是系统中的获得实体，既包括数据库该你了系统所管理的实际用户，也包括代表用户的各进程。客体是系统中的被动实体，是受主体操作的，包括文件、基本表、索引、视图等。对于主体和客体，数据库管理系统为他们每个实例指派一个，敏感度标记。 敏感度标记被分成若干级别，例如绝密(TS)、机密(S)、可信(C)、公开(P)等。密级的次序是TS&gt;=S&gt;=C&gt;=P。主体的敏感度标记称为许可证级别，客体的敏感度标记称为密级。强制存取控制机制就是通过对比主体的敏感度标记和客体的敏感度标记，最终确定主体是否能够存取客体。 当某以用户以标记label注册入系统时，系统要求他对任何客体的存取必须遵循如下规则： 仅当主体的许可证级别大于或等同于客体的密级时，该主体才能读取相应的客体。 仅当主体的许可证级别小于或等同于客体的密级时，该主体才能写相应的客体。 如果违反了规则2，就有可能把数据的密级从高流向低，造成数据的泄漏。 强制存取控制是对数据本身进行密级标记，无论数据如何复制，标记与数据是一个不可分的整体，只有符合密级要求的用户才可以操作数据，从而提供了更高级别的安全性。 视图机制可以为不同的用户定义不同的视图,把数据对象限制在一定的范围内。也就是说，通过视图机制把要保密的数据对无权存取的用户隐藏起来，从而自动对数据提供一定程度的安全保护。 视图机制间接的实现支持存取谓词的用户权限定义。 审计审计功能把用户对数据库的所有操作自动记录下来，放入审计日志中。审计员可以利用审计日志监控数据库中的各种行为，重现导致数据库现有状况的一系列事件，找出非法存取数据的人、时间和内容等。 审计事件 审计事件一般有多个类别 服务器事件:审计数据库服务器发生的事件，包含数据库服务器的启动、停止、数据库服务器配置文件的重新加载。 系统权限：对系统拥有的结构或模式对象进行操作的审计，要求该操作的权限是通过系统权限获得的。 语句事件：对SQL语句，如DDL、DML、DQL及DCL语句的审计 模式对象事件：对特定模式对象上进行的select 或dml操作的审计。模式对象包括表、视图、存储过程、函数等。模式对象不包括依附于表的索引、约束、触发器、分区表等。 审计功能 审计功能主要包括以下几个方面： 基本功能，提供多种审计查阅方式：基本的、可选的、有限的，等等。 提供多套审计规则，审计规则一般在数据库初始化时设定，以方便审计员管理。 提供审计分析和报表功能 审计日志管理功能 系统提供查询审计设置及审计记录信息的专门视图。 audit语句和noaudit语句 audit语句用来设置审计功能，noaudit语句则取消审计功能。 审计一般可以分为用户级审计和系统级审计。 例：audit alter，update on SC和noaudit alter，update on SC 审计设置以及审计日志一般都存储在数据字典中。必须把审计开关打开，才可以在系统表SYS_AUDITTRAIL中查看到审计信息。 数据库安全审计系统提供了一种事后检查的安全机制。 数据加密加密的基本思想是根据一定的算法将原始数据——明文变换为不可直接识别的格式——密文，从而使得不知道界面算法的人无法获知数据的内容. 存储加密 对于存储加密，一般提供透明和非透明两种存储加密方式。透明存储加密是内核级加密保护方式，对用户完全透明；非透明存储加密则是通过多个加密函数实现的。 传输加密 常见的传输加密方式如链路加密和端到端加密 安全套接层协议SSL，端到端 实现思路包括： 确认通信双方端点的可靠性 协商加密算法和密钥 可信数据传输 其他安全性保护在自主存取控制和强制存取控制之外，还有推理控制以及数据库应用中隐蔽信道和数据隐私保护等技术。 推理控制除了的是强制存取控制为解决的问题。数据库推荐控制机制用来避免用户利用其能够访问的数据推知更高密级的数据。 隐蔽信道处理内容也是强制存取控制为解决的问题。 数据隐私成为数据库应用中新的数据保护模式。所谓数据隐私是控制不愿被他人知道或他人不便知道的个人数据的能力。 第五章 数据库完整性数据库的完整性是指数据的正确性和相容性 为维护数据库的完整性，数据库管理系统必须能够实现以下功能： 提供定义完整性约束条件的机制 提供完整性检查的方法 进行违约处理 关系数据库管理系统使得完整性控制成为其核心支持的功能，从而能够为所有用户和应用提供一致的数据库完整性。 实体完整性 定义实体完整性 关系模型的实体完整性在create table中用primary key定义。对单属性构成的码有两种说明方法，一种是定义为劣迹约束条件，另一种是定义为标记约束条件。对于多个属性构成的码只有一种说明方法，即定义为表级约束条件。 实体完整性检查和违约处理 用primary key短语定义了关系的主码后，每当用户程序对级别表插入一条记录或对主码列进行更新操作时，关系数据库管理系统将按照实体完整性规则进行自动检查。 检查主码值是否唯一，如果不唯一则拒绝插入或修改。 检查主码的各个属性是否为空，只要有一个为空就拒绝插入或修改。 全表扫描是十分好事都。为了避免对基本表进行全表扫描，关系数据库管理系统一般都在主码上自动建立一个索引。 参照完整性 定义参照完整性 关系模型的按照完整性在create table中用foreign key短语定义哪些列为外码，用references短语芝麻这些外码参照哪些表的主码。 参照完整性检查和违约处理 参照完整性将两个表中的相应元组联系起来了。因此，对被参照表和参照表进行增、删、改操作时有可能破坏参照完整性，必须进行检查以保证这两个表的相容性。 当上述的不一致发生时，系统可以采用以下策略加以处理 拒绝(no action)执行：不允许该操作。该策略一般设置为默认策略。 级联(cascade)操作：当删除或修改被参照表中的一个元组导致与参照表的不一致时，删除或修改参照表中的所有不一致的元组。 设置为空值：当删除或修改被参照表的一个元组时造成了不一致，则将参照表中所有曹操不一致的元组的对应属性设置为空值。 用户定义的完整性 属性上的约束条件 属性上约束条件的定义 列值非空(not null) 列值唯一(unique) 检查列值是否满足一个条件表达式(check短语) 属性上约束条件的检查和违约处理 不满足条件拒绝执行 元组上的约束条件 元组上约束条件的定义 与属性上约束条件的定义类似，在create table语句中可以用check 短语定义元组上的约束条件，即元组级的限制。同属性值限制相比，元组级的限制可以设置不同的属性之间的取值的相互约束条件。 属性上约束条件的检查和违约处理 不满足条件拒绝执行 完整性约束命名子句 完整性约束命名子句 constraint &lt;完整性约束条件名&gt;&lt;完整性约束条件&gt; &lt;完整性约束条件&gt;包括not null、unique、primary key、foreign key、check等 修改表中的完整性限制 可以使用alter table语句修改表中的完整性限制 alter table Student drop constraint C4 断言在SQL中可以使用数据定义语言中的create assertion语句，通过声明性断言来指定更具一般性的约束。可以定义设计多个表或聚集操作的笔记复制的完整性约束。任何断言不为真的都拒绝执行 创建断言的语句格式 create assertion &lt;断言名&gt; 每一断言都被赋予一个名字，中的约束条件与where子句的条件表达式类似。 删除断言的语句格式 drop assertion&lt;断言名&gt; 触发器触发器是用户定义在关系表上的一类由事件驱动的特殊过程。 定义触发器 触发器又叫做事件-条件-动作规则。其一般格式为 create trigger &lt;触发器名&gt; {before|after} &lt;触发器事件&gt; on &lt;表名&gt; referencing new|old row as &lt;变量&gt; for each{row|statement} [when&lt;触发条件&gt;]&lt;触发动作体&gt; 各部分详细说明 只有表的拥有者，即创建表的用户才可以在表上创建触发器，并且一个表上只能创建一定数量的触发器。触发器的具体数量由具体的关系数据库管理系统在设计时确定。 触发器名：触发器名可以保护模式名，也可以不包含模式名。同以模式下，触发器名必须是唯一的，并且触发器名与表名必须在同一模式下。 表名：触发器只能定义在基本表上，不能定义在视图上。当基本表的数据发生变化时，将激活定义在改表上相应触发事件的触发器，因此该表也称为触发器表。 触发事件：出发时间可以是insert、delete或update，也可以是这几个事件的组合，如insert or delete等，还可以是update of&lt;触发列，…&gt;即进一步指名修改哪些列时激活触发器。after/before是触发的时机。after表示在触发事件的操作执行之后激活触发器；before表示在触发事件的操作执行之前激活触发器。 触发器类型：触发器按照所触发动作的间隔尺寸可以分为行级触发器和语句级触发器。 触发条件：触发器被激活时，只有当触发条件为真时触发动作体才执行，否则触发动作体不执行。如果省略when触发条件，则触发动作体在触发器激活后立即执行。 触发动作体：触发动作体既可以是一个匿名PL/SQL过程块，也可以是对已创建存储过程的调用。 激活触发器 触发器的执行是由触发事件激活，并由数据库服务器自动执行的。一个数据表上可能定义了多个触发器，如多个before触发器、多个after触发器等，同一个表上的多个触发器激活时遵循如下的执行顺序： 执行该表上的before触发器 激活触发器的SQL语句 执行该表上的after触发器 对于同一个表的多个before(after)触发器，遵循“谁先创建谁先执行”的原则。 删除触发器 删除触发器的SQL语法如下： drop trigger &lt;触发器名&gt; on &lt;表名&gt; 第六章 关系数据理论问题的提出 由于关系模型有严格的数学理论基础，并且可以向别的数据模式转换，因此，人们就以关系模型为背景来讨论这个问题，形成了数据库逻辑设计的一个有力工具——关系数据库的规范化理论。 作为一个二维表，关系要符合一个最基本的条件：每一个分量必须是不可分的数据项。满足了这个条件的关系模式就属于第一范式(1NF)。 数据依赖是一个关系内部属性于属性之间的一种约束关系。这种约束关系是通过属性间值的相等与否体现出来的数据间相关关系。 人们已经提出了多种类型的数据依赖，其中最重要的是函数依赖和多值依赖。 一个好的模式应当不会发生插入异常、删除异常和更新异常，数据冗余尽可能少。 规范化 函数依赖 定义：设R(U)是属性集U上的关系模式，X,Y是U的子集。若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等，则称X函数确定Y或Y函数依赖于X，记作X-&gt;Y. 函数依赖和别的数据依赖一样是语义范畴的概念，只能根据语义来确定一个函数依赖。 X-&gt;Y,但Y不包含于X，则称X-&gt;Y是非平凡的函数依赖 X-&gt;Y但Y包含于X，则称X-&gt;Y是平凡的函数依赖。对于任一关系模式，平凡函数依赖都是必然成立的，它不反应新的语义。若不特别声明，总是讨论非平凡的函数依赖。 若X-&gt;,则X称为这个函数依赖的决定属性组，也称为决定因素。 若X-&gt;Y,Y-&gt;X,则记作XY 若Y不函数依赖于X,则记作X!-&gt;Y 在R(U)中，如果X-&gt;Y，并且对于X的任何一个真子集X’，都有X’!-&gt;Y,则称Y对X完全函数依赖，记作X F-&gt;Y 若X-&gt;,但Y不完全函数依赖于X，则称Y对X部分函数依赖，记作X P-&gt;Y 在R(U)中，如果X-&gt;Y(Y不包含于X),Y!-&gt;X,Y-&gt;Z,Z不包含于Y则称Z对X传递函数依赖。记作X 传递-&gt; Y 码 码是关系模式中的一个重要概念 设K为R&lt;U,F&gt;中的属性或属性组合，若K F-&gt;U,则K为R的候选码。 若候选码多于一个，则选定其中的一个为主码 不包含在任何候选码中的属性称为非主属性或非码属性。最简单的情况，单个属性是码；最极端的情况，整个属性组是码，称为全码。 关系模式R中属性或属性组X并非R的码，但X是另一个关系模式的码，则称X是R的外部码，也称外码。 范式 关系数据库中的关系是要满足一定要求的，满足不同程度要求的为不同范式。 一个低一级范式的关系模式通过模式分解可以转换为若干个高一级范式的关系模式的集合，这种过程就叫规范化。 2NF 若R属于1NF，且每一个非主属性完全函数依赖于任何一个候选码，则R属于2NF。 一个关系模式R不属于2NF，就会产生以下几个问题： 插入异常 删除异常 修改异常 3NF 设关系模式R&lt;U,F&gt;属于1NF，若R中不存在这样的码X，属性组Y及非主属性Z使得X-&gt;Y,Y-&gt; 成立，Y!-&gt;,则称R&lt;U,F&gt;属于3NF 由定义可以证明，若R属于3NF,则每一个非主属性既不传递依赖于码，也不部分依赖于码。也就是说，可以证明如果R属于3NF，则必有R属于2NF BCNF 关系模式R&lt;U,F&gt;属于1NF，若X-&gt;Y且Y不包含于X时X必含有码，则R&lt;U,F&gt;属于BCNF 也就是说，关系模式R&lt;U,F&gt;中，若每一个决定因素都包含码，则R&lt;U,F&gt;属于BCNF 由BCNF的定义可以得到结论，一个满足BCNF的关系模式由 所有非主属性对每一个码都是完全函数依赖。 所有主属性对每一个不包含它的码也是完全函数依赖 没有任何属性完全函数依赖于非码的任何一组属性。 规范化小结 规范化的基本思想是逐步消除数据依赖中不合适的部分，使模式中的各个关系模式达到某种程度的“分离”，即“一事一地”的模式设计原则。让一个关系描述一个概念，一个实体或者实体间的一种联系。若多于一个概念就把它“分离”出去。因此所谓规范化实质上是概念的单一化。 关系模式的规范化过程是通过对关系模式的分解来实现的，即把低一级的关系模式分解为若干个高以级的关系模式。 数据依赖的公理系统下面首先讨论函数依赖的一个有效而完备的公理系统——Armstrong公理系统。 定义：对于满足一组函数依赖F的关系模式R&lt;U,F&gt;,其任何一个关系r，若函数依赖X-&gt;Y都成立(即r中任意两元组t、s，若t[X]=s[X],则t[Y]=s[Y]),则称F逻辑蕴含X-&gt;Y. Armstrong公理系统 设U为属性集总体，F是U上的一组函数依赖，于是有关系模式R&lt;U,F&gt;,对R&lt;U,F&gt;来说有以下的推理规则： A1自反律：若Y包含于X包含于U，则X-&gt;Y为所蕴含。 A2增广律：若X-&gt;Y为F所蕴含，且Z包含于U,则XZ-&gt;YZ为F所蕴含。 A3传递律：若X-&gt;Y及Y-&gt;Z为F所蕴含，则X-&gt;Z为F所蕴含 注意：由自反律所得到的函数依赖均是平凡的函数依赖，自反律的使用并不依赖于F。 定理 6.1：Armstrong推理规则是正确的。 根据A1,A2,A3这三条推理规则可以得到下面三条很有用的推理规则 合并规则：由X-&gt;Y,X-&gt;Z,有X-&gt;YZ 伪传递规则：X-&gt;Y,WY-&gt;Z,有XW-&gt;Z 分解规则：由X-&gt;Y及Z包含于Y，有X-&gt;Z 定义6.12 在关系模式R&lt;U,F&gt;中为F所逻辑蕴含的函数依赖的全体叫作F的闭包，记为F+. 人们把自反律、传递律和增广律称为Armstrong公理系统。Armstrong公理系统是有效的、完备的。Armstrong公理的有效性指的是：由F出发根据Armstrong公理推导出来的每一个函数依赖一定在F+中；完备性指的是F+中的每一个函数依赖，必定可以由F出发根据Armstrong公理推导出来。 定义6.13 设F为属性集U上的一组函数依赖，X、Y包含于U，XF+ = {A|X-&gt;A能由F根据Armstrong公理导出}，XF+称为属性集X关于函数依赖集F的闭包。 引理 6.2：设F为属性集U上的一组函数依赖，X,Y包含于U，X-&gt;Y能由F根据Armstrong公理导出的充分必要条件是Y包含于XF+。 定理6.2 Armstrong公理系统是有效的、完备的。 如果函数依赖集F满足下列条件，则称F为一个极小函数依赖集，亦称为最小依赖集或最小覆盖。 F中任一函数依赖右部仅含有一个属性。 F中不存在这样的函数依赖X-&gt;A,使得F与F-{X-&gt;A}等价 F中不存在这样的函数依赖X-&gt;A,X有真子集Z使得F-{X-&gt;A}并{Z-&gt;A}与F等价。 模式的分解 模式分解的三个定义 分解具有无损连接性 分解要保持函数依赖 分解既要保持函数依赖，又要无损连接性 这三个定义是实行分解的三条不同的准则。按照不同的分解准则，模式所能达到的分离程度各不相同，各种范式就是对分离程度的测度。 模式分解的算法 关于模式分解保持函数依赖，那么模式分离总可以达到3NF，但不一定能达到BCNF 若要求分解既保持函数依赖，又具有无损连接性，可以达到3NF，但不一定能达到BCNF 若要求分解具有无损连接性，那么一定可达到4NF 算法6.3(合成法)转换为3NF的保持函数依赖的分解(课本P198 6.4.3) 算法6.4 转换为3NF既有无损连接性又保持函数依赖的分解(课本P198 6.4.3) 算法6.5(分解法)转换为BCNF的无损连接分解 (课本P198 6.4.3) 第七章 数据库设计数据库设计概述数据库设计，广义的讲，是数据库及其应用系统的设计，即设计整个数据库应用系统；狭义的讲，是设计数据库本身，即设计数据库的各级模式并建立数据库，这是数据库应用系统设计的一部分。 下面给出数据库设计的一般定义. 数据库设计是指对于一个给定的应用环境，构造(设计)优化的数据库逻辑模式和物理结构，并据此建立数据库及其应用系统，使之能够有效的存储和管理数据，满足各种用户的应用需求，包括信息管理要求和数据操作要求。 数据库设计的特点 数据库减少的基本规律 “三分技术，七分管理，十二分基础数据”是数据库设计的特点之一。 “十二分基础数据”则强调了数据的手机、整理、组织和不断更新是数据库建设中的重要环节。 结构(数据)设计和行为(处理)设计相结合 数据库设计应该和应用系统设计相结合。也就是说，整个设计过程中要把数据库结构设计和对数据的处理设计密切结合起来。这是数据库设计的特点之二。 数据库设计犯法 它要求从事数据库设计的专业人员具备多方面的知识和技术。主要包括： 计算机的基础知识 程序设计的方法和技巧 数据库的基本知识 数据库设计技术 应用领域的知识 数据库设计的基本步骤 需求分析阶段 概念结构设计阶段 逻辑结构设计阶段 物理结构设计阶段 数据库实施阶段 数据库运行和维护阶段 数据库设计过程中的各级模式 需求分析 需求分析的任务 调查的重点是“数据”和“处理”，通过调查、收集与分析，获得用户对数据库的如下要求： 信息要求。指用户需要从数据库中获得信息的内容与性质。由信息要求可以导出数据要求，即在数据库中需要存储哪些数据。 处理要求。指用户要完成的数据处理功能，对处理性能的要求。 安全性与完整性要求。 需求分析分析的方法 调查用户需求的具体步骤是： 调查组织机构情况。 调查各部门的业务活动情况。 在熟悉业务活动的基础上，协助用户明确对新系统的各种要求，包括信息要求、处理要求、安全性与完整性要求，这是调查的又一个重点。 确定新系统的边界。 调查常用的方法： 跟班作业。 开调查会 请专人介绍。 询问。 设计调查表请用户填写 查阅记录 数据字典 数据字典是进行详细的数据收集和数据分析所获得的主要成果。它是关于数据库中数据的描述，即元数据，而不是数据本身。数据字典是在需求分析阶段建立，在数据库设计过程中不断修改，充实，完善的。它在数据库设计中占有很重要的地位。 数据项 数据项是不可再分的数据单位。对数据项的描述通常包括以下内容。 数据项描述 = {数据项名，数据项含义说明，别名，数据类型，长度，取值范围，取值含义，与其他数据项的逻辑关系，数据项之间的联系} 其中，“取值范围”、“与其他数据项的逻辑关系”(如该数据项等于其他几个数据项的和、该数据项值等于另一数据项的值等)定义了数据的完整性约束条件，是设计数据检验功能的依据。 数据结构 数据结构反映了数据之间的组合关系。一个数据结构可以由若干给数据项组成，也可以由若干个数据结构组成，或由若干个数据项和数据结构混合组成。对数据结构的描述通常包括以下内容： 数据结构描述 = {数据结构名，含义说明，组成：{数据项或数据结构}} 数据流 数据流是数据结构在系统内传输的路径。对数据流的描述通常包括以下内容： 数据流描述 = {数据流名，说明，数据流来源，数据流去向，组成：{数据结构}，平均流量，高峰期流量} 其中，“数据流来源”是说明该数据流来自哪个过程；“数据流去向”是说明该数据流将导哪个过程取；“平均流量”是指在单位时间(每天、每周、每月等)里的传输次数；“高峰期流量”则是指在高峰时期的数据流量。 数据存储 数据存储是数据结构停留或保存的地方，也是数据流的来源和去向之一。它可以是手工文档或手工凭单，也可以是计算机文档，对数据存储的描述通常包括以下内容： 数据存储描述 = {数据存储名，说明，编号，输入的数据流，输出的数据流，组成：{数据结构}，数据量，存储频率，存取方式} 其中，“存取频度”指每小时、每天或每周存取次数及每次存取的数据量等信息； 处理过程 处理过程的具体处理逻辑一般用判定表或判定树来描述。数据字典中只需要描述处理过程的说明信息即可，通常包括以下内容： 处理过程描述 = {处理过程名，说明，输入：{数据流}，输出：{数据流}，处理：{简要说明}} 最后要强调两点： 需求分析阶段的一个重要而困难的任务是收集将来应用所涉及的数据，设计人员应充分考虑到可能的扩充和改变，使设计易于更改、系统易于扩充。 必须强调用户的参与，这是数据库应用系统设计的特点。 概念结构设计 概念模型 概念模型的主要特点是： 能真实、充分的反映现实世界，包括事物和事物之间的联系，能满足用户对数据的处理要求，是现实世界的一个真实模型。 易于理解，可以用它和不熟悉计算机多用户交换意见。用户的积极参与是数据库设计成功的关键。 易于更改，当应用环境和应用要求改变时容易对概念模型修改和扩充。 易于向关系、网状、层次等各种数据模型转换。 E-R模型 实体之间的联系 两个实体型之间的联系：一对一联系(1:1)、一对多联系(1:n)、多对多联系(m:n) 两个以上的实体型之间的联系：两个以上的实体型之间也存在着一对一、一对多和多对多联系。 单个实体型内的联系：同一个实体集内的各实体之间也可以存在一对一、一对多和多对多的联系。 一般的，把参与联系的实体型的数目称为联系的度。两个实体型之间的联系度为2，也称为二元联系；三个实体型之间的联系度为3，称为三元联系；N个实体型之间的联系度为N，也成为N元联系。 E-R图 E-R图提供了表示实体型、属性和联系的方法。 实体型用矩形表示，矩形框内写明实体名。 属性用椭圆表示，并用无向边将其与相应的实体型连接起来 联系用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体型来南京起来，同时在无向边旁标上联系的类型(1：1、1：n、m:n) 一个实例 扩展的E-R模型 ISA联系 用E-R方法构建一个项目的模型时，经常会遇到某些实体型的子类型。例如，研究生和本科生是学生的子类型，学生是父类型。这种父类-子类联系称为ISA联系，表示“is a”的语义。联系用三角形来表示。 分类属性 根据分类属性的值把父实体型中的实体分派到子实体型中。 不相交约束与可重叠约束 不相交约束描述父类中的一个实体不能同时属于多个子类中的实体集，即一个父类中的实体最多属于一个子类实体集，用ISA联系三角形符号内加一个叉号“X“来表示。 完备性约束 完备性约束描述父类中的一个实体是否必须是某一个子类中的实体，如果是，则叫做完全特化，否则叫做部分特化。完全特化用父类到子类的双线连接来表示，单线连接则表示部分特化。 基数约束 基数约束是对实体之间一对一，一对多和多对多来呢西的细化。参与联系的每个实体型用基数约束来说明实体型中的任何一个实体可以在联系中出现的最少次数和最多次数。 约束用一个数对min..max表示，0&lt;=min&lt;=max。例如，0..1、1..3、1..(\\代表无穷大)。min=1的约束叫做强制参与约束，即被施加基数约束的实体型中的每个实体都要参与联系；min=0的约束叫做非强制参与约束，被世家基数约束的实体型中的实体可以出现在联系中，也可以不出现在联系中。 Part-of联系 Part-of联系即部分联系，它表明某个实体型是另外一个实体型的一部分。非独占的Part-of联系可以通过基数约束来表达(非强制参与联系)。与非独占联系相反，还有一种Part-of联系是独占联系。即整体实体如果被破坏，部分实体不能存在，在E-R图中用弱实体类型和识别联系来表示独占联系。如果一个实体型的存在依赖于其他实体型的存在，则这个实体型叫做弱实体型，否则叫做强实体型。如果不能从一个实体型的属性中找出可以作为码的属性，则这个实体型是弱实体型。在E-R图中用双矩形表示弱实体型，用双菱形表示识别联系。 概念结构设计 实体与属性的划分原则 在调整中遵循的一条原则是：为了简化E-R图的处置，现实世界的事物能作为属性对待的尽量作为属性对待。 符合什么条件的事物可以作为属性对待，可以给出两条准则： 作为属性，不能再具有需要描述的性质，即属性必须是不可分的数据项，不能包含其他属性。 属性不能与其他实体具有联系，即E-R图中所表示的联系是实体之间的联系。 E-R图的集成 E-R图的集成一般需要两步走: 合并。解决各分E-R图之间的冲突，将分E-R图合并起来生成初步E-R图。 修改和重构。消除不必要的冗余，生成基本E-R图。 合并E-R图生成初步E-R图 合理消除各E-R图的冲突是合并E-R如的主要工作与关键所在。 属性冲突 属性域冲突，即属性值的类型、取值范围或取值集合不同 属性取值单位冲突 命名冲突 同名异义，即不同意义的对象在不同的局部应用中具有相同的名字 异名同义，即同一意义的对象在不同的局部应用中具有不同的名字 结构冲突 结构冲突主要包含以下三类冲突： 同一对象在不同应用中具有不同的抽象。 同一实体在不同子系统的E-R图中所包含的属性个数和数学排列次序不完全相同。 实体间的联系在不同的E-R图中为不同的类型。 消除不必要的冗余，设计基本E-R图 在初步E-R图中可能存在一些冗余的数据和实体间冗余的联系。 消除冗余主要采用分析方法，即以数据字典和数据流图为依据，根据数据字典中关于数据项之间逻辑关系的说明来消除冗余。 除分析方法外，还可以用规范化理论来消除冗余。在规范化理论中，函数依赖的概念提供了消除冗余联系的形式化工具。具体方法如下： 确定分E-R图实体之间的数据依赖。 求FL的最小覆盖GL，差集为D=FL-GL。 由于规范化理论受到泛关系假设的限制，应注意下面两个问题： 冗余的联系一定在D中，而D中的联系不一定是冗余的。 当实体之间存在多种联系时，要将实体之间的联系在形式上加以区分。 逻辑结构设计逻辑结构设计的任务就是把概念呢结构设计阶段设计好的基本E-R图转换为与选用数据库管理系统产品所支持的数据模型相符合的逻辑结构。 E-R图向关系模型的转换 下面介绍转换的一般原则。一个实体型转换为一个关系模式，关系的属性就是实体的属性，关系的码就是实体的码。对于实体型间的联系有以下不同的情况： 一个1:1联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并。 一个1:n 联系可以转换为一个独立的关系模式，也可以与n端对应的关系模式合并。 一个m:n联系转换为一个关系模式，与该联系相连的各实体的码以及联系本身的数据均转换为关系的属性，各实体的码组成关系的码或关系码的一部分。 三个或三个以上实体间的一个多元联系可以转换为一个关系模式。 具有相同码的关系模式可合并。 数据模型的优化 数据库逻辑设计的结果不是唯一的。关系数据模型的优化通常以规范化理论为指导，方法为： 确定数据依赖 对于各个关系模式之间的数据依赖进行极小化除了，消除冗余的联系 按照数据依赖的理论对关系模式逐一进行分析，考察是否存在部分函数依赖、传递函数依赖、多值依赖等，确定各关系模式分别属于第几范式。 根据需求分析阶段得到的处理要求分析对于这样的应用环境这些模式是否合适，确定是否要对某些模式进行合并或分解。 必须注意的是，并不是规范化程度越高的关系就越优。 对关系模式进行必要分解，提高数据操作效率和存储空间利用率。常用的两种分解方法是水平分解和垂直分解。 设计用户子模式 由于用户外模式与模式是相对独立的，因此在定义用户外模式时可以注重考虑用户的习惯与方便。具体包括以下几个方面： 使用更符合用户习惯的别名。 可以对不同级别的用户定义不同的视图，以保证系统的安全性。 简化用户对系统的使用。 物理结构设计为一个给定的逻辑数据模型选取一个最适合应用要求的物理结构的过程，就是数据库的物理设计。 数据库的物理设计通常分为两步： 确定数据库的物理结构，在关系数据库中主要指存取方法和存储结构。 对物理结构进行评价，评价的重点是时间和空间效率。 数据库物理设计的内容和方法 对于数据库查询事务，需要得到如下信息： 查询的关系 查询条件所涉及的属性 连接条件所涉及的属性 查询的投影属性 对于数据更新事务，需要得到如下信息： 被更新的关系 每个关系上的更新操作条件所涉及的属性 修改操作要改变的属性值 通常关系数据库物理涉及的内容主要包括为关系模式选择存取方法，以上设计关系、索引等数据库文件的物理存储结构。 关系模式存取方法选择 存取方法是快速存取数据库中数据的基数。数据库管理系统一般提供多种存取方法。常用的存取方法为索引方法和聚簇方法。 B+树索引存取方法的选择 hash索引存取方法的选择 聚簇存取方法的选择 为了提高某个属性(或属性组)的查询速度，把这个或这些属性上具有相同值的元组集中存放在连续的物理块中称为聚簇。该属性(或属性组)称为聚簇码。 确定数据库的存储结构 确定数据的存放位置 确定系统配置 评价物理结构 数据库的实施和维护 数据的载入和应用程序的调试 数据库应用程序的设计应该与数据库设计同时进行，因此在组织数据入库的同时还要调试应用程序。 数据库的试运行 这里特别要强调两点。第一上面已经讲到组织数据入库是十分费时、费力的事，如果试运行后还要修改数据库的设计，还要重新组织数据入库。因此应分期分批的组织数据入库，先输入小批量数据做调试用，带试运行基本合格后再大批量输入数据，逐步增加数据量，组别完成评价。第二，再数据库试运行阶段，由于系统还不稳定，硬、软件故障随时都可能发生；而系统的操作人员对新系统还不熟悉，误操作也不可避免，因此要做好数据库的转储和恢复工作。 数据库的运行和维护 数据库的转储和恢复 数据库的安全性、完整性控制 数据库性能的监督分析和改造 数据库的重组织与重构造 数据库编程未完待续。。。 —&gt;","raw":null,"content":null,"categories":[],"tags":[]},{"title":"杭电oj-1004","slug":"杭电oj-1004","date":"2020-04-06T04:43:21.000Z","updated":"2020-12-26T07:19:44.000Z","comments":true,"path":"2020/04/06/杭电oj-1004/","link":"","permalink":"http://zehwakaka.github.io/2020/04/06/杭电oj-1004/","excerpt":"","text":"杭电oj-10041234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;stdio.h&gt;#include&lt;string.h&gt;using namespace std;int max(int a[], int n)&#123;int max = a[0];int k = 0;for (int i = 0; i &lt; n; i++)&#123; if (a[i] &gt; max) &#123; max = a[i]; k = i; &#125;&#125;return k;&#125;int main()&#123;//freopen(\"C:/Users/19856/Desktop/wakaka.txt\",\"r\",stdin );int n;int k;while (1)&#123; char a[1005][17]; char b[17]; int c[1005] = &#123;0&#125;; memset(a, 0, sizeof(a)); memset(b, 0, sizeof(b)); scanf(\"%d\", &amp;n); if (n == 0)break; for (int i = 0; i &lt; n; i++) &#123; scanf(\"%s\", &amp;b); for (int j = 0; (j &lt; n)&amp;&amp;(a[j][0]!='\\0'); j++) &#123; if (!strcmp(a[j], b))c[j]++; &#125; if (a[i][0] == '\\0') &#123; strcpy(a[i], b); c[i]++; &#125; &#125; k = max(c, n); printf(\"%s\\n\", a[k]); &#125;&#125;","raw":null,"content":null,"categories":[{"name":"技术","slug":"技术","permalink":"http://zehwakaka.github.io/categories/技术/"},{"name":"刷题","slug":"技术/刷题","permalink":"http://zehwakaka.github.io/categories/技术/刷题/"}],"tags":[{"name":"oj","slug":"oj","permalink":"http://zehwakaka.github.io/tags/oj/"}]},{"title":"blog写作之旅启程","slug":"blog写作之旅启程","date":"2020-04-06T04:06:27.000Z","updated":"2020-04-06T04:39:54.000Z","comments":true,"path":"2020/04/06/blog写作之旅启程/","link":"","permalink":"http://zehwakaka.github.io/2020/04/06/blog写作之旅启程/","excerpt":"","text":"十分抱歉个人于19年搭建主页，由于学业繁忙，再没去触碰，近期将边学习边写blog，内容包括不局限于 计算机网络，汇编语言，Java学习，希望能强迫自己output，也希望自己能熟练掌握markdown写作。","raw":null,"content":null,"categories":[{"name":"技术","slug":"技术","permalink":"http://zehwakaka.github.io/categories/技术/"},{"name":"汇编","slug":"技术/汇编","permalink":"http://zehwakaka.github.io/categories/技术/汇编/"}],"tags":[{"name":"汇编学习","slug":"汇编学习","permalink":"http://zehwakaka.github.io/tags/汇编学习/"}]},{"title":"hello hexo markdown","slug":"hello-hexo-markdown","date":"2020-04-05T19:58:17.000Z","updated":"2020-12-26T07:19:06.000Z","comments":true,"path":"2020/04/06/hello-hexo-markdown/","link":"","permalink":"http://zehwakaka.github.io/2020/04/06/hello-hexo-markdown/","excerpt":"","text":"","raw":null,"content":null,"categories":[],"tags":[]},{"title":"萌新Alice前来报道","slug":"初到小白，请多关照","date":"2019-06-07T16:00:00.000Z","updated":"2020-08-22T13:19:00.000Z","comments":true,"path":"2019/06/08/初到小白，请多关照/","link":"","permalink":"http://zehwakaka.github.io/2019/06/08/初到小白，请多关照/","excerpt":"","text":"第一次搭建blog，有点小激动(≧︶≦))(￣▽￣ )ゞ多多关照！","raw":null,"content":null,"categories":[{"name":"经验分享","slug":"经验分享","permalink":"http://zehwakaka.github.io/categories/经验分享/"}],"tags":[{"name":"技术交流","slug":"技术交流","permalink":"http://zehwakaka.github.io/tags/技术交流/"}]}]}