<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta property="og:type" content="website">
<meta property="og:title" content="Alice&#39;s blog">
<meta property="og:url" content="http://zehwakaka.github.io/page/2/index.html">
<meta property="og:site_name" content="Alice&#39;s blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Alice&#39;s blog">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://zehwakaka.github.io/page/2/">





  <title>Alice's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Alice's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">郑</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zehwakaka.github.io/2021/03/14/Java基础/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alice's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/14/Java基础/" itemprop="url">Java基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2021-03-14T20:14:45+08:00">
                2021-03-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><ul>
<li><p>基础语法</p>
</li>
<li><p>面向对象</p>
</li>
<li><p>高级应用</p>
</li>
</ul>
<hr>
<h2 id="第一节-资料文件结构"><a href="#第一节-资料文件结构" class="headerlink" title="第一节 资料文件结构"></a>第一节 资料文件结构</h2><ul>
<li>概述</li>
<li>计算机硬件介绍</li>
<li>计算机发展史上的鼻祖</li>
<li>操作系统</li>
<li>万维网</li>
<li>职业发展与提升</li>
<li>学习经验探讨</li>
</ul>
<h2 id="第二节-入门概述"><a href="#第二节-入门概述" class="headerlink" title="第二节 入门概述"></a>第二节 入门概述</h2><blockquote>
<p><strong>计算机包括硬件和软件两部分。</strong>硬件包括计算机中可以看得见的物理部分。而软件提供看不见的指令。这些指令控制硬件并且使得硬件完成特定的任务。</p>
<p><strong>程序设计</strong></p>
<p><strong>定义：</strong>创建（或开发）软件。软件包含了指令，告诉计算机做什么。</p>
<p><strong>应用场景：</strong>软件遍布我们周围。除了个人计算机，飞机、汽车、手机甚至烤面包机中，同样运行着软件。</p>
<p><strong>程序设计语言</strong></p>
<p>软件开发人员在称为程序设计语言的强大工具的帮助下创建软件。</p>
</blockquote>
<h3 id="计算机硬件介绍"><a href="#计算机硬件介绍" class="headerlink" title="计算机硬件介绍"></a>计算机硬件介绍</h3><blockquote>
<p>中央处理器（CPU）、内存（主存）、存储设备、输入设备、输出设备、通信设备。总线（bus）</p>
<p><strong>冯·诺依曼体系结构</strong>是现代计算机的基础，现在大多计算机仍是冯·诺伊曼计算机的组织结构，只是作了一些改进而已，并没有从根本上突破冯体系结构的束缚。冯·诺伊曼也因此被人们称为“计算机之父”。</p>
<p><strong>中央处理器（CPU）</strong>是计算机的大脑。它从内存中获取指令，然后执行这些指令。</p>
<p>包括：控制单元和算术/逻辑单元。</p>
<p><strong>控制单元：</strong>用于控制和协调其他组件的动作。</p>
<p><strong>算术/逻辑单元：</strong>用于完成数值运算（+、-、*、/）和逻辑运算（比较）。</p>
<p>每台计算机都有一个内部时钟，该时钟以固定速度发射电子脉冲。时钟速度越快，在给定的时间段内执行的指令就越多。速度的计量单位是赫兹（Hz），1Hz相当于每秒1个脉冲。随着CPU速度不断提高，目前以千兆赫（GHz）来表述。</p>
<p>最初一个CPU只有一个核（core）。核是处理器中实现指令读取和执行的部分。一个多核CPU是一个具有两个或者更多独立核的组件。可提高CPU的处理能力。</p>
</blockquote>
<p><strong>IT定律之计算机行业发展规律</strong></p>
<ul>
<li>摩尔定律</li>
<li>安迪-比尔定律</li>
<li>反摩尔定律</li>
</ul>
<blockquote>
<ul>
<li>内存中的信息在断电时会丢失。那我们可以考虑将程序和数据永久的保存在存储设备上。当计算机确实需要这些数据时，再移入内存，因为从内存中读取比从存储设备读取要快得多。</li>
<li>存储设备主要有以下三种：<ul>
<li>磁盘驱动器</li>
<li>光盘驱动器</li>
<li>USB闪存驱动器</li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>内存</strong></p>
<blockquote>
<p><strong>比特（bit）和字节（byte）</strong></p>
<ul>
<li>一个0或者一个1存储为一个比特（bit），是计算机中最小的存储单位。</li>
<li>计算机中最基本的存储单元是字节（byte）。每个字节由8个比特构成。</li>
<li>内存（RAM）：由一个有序的字节序列组成，用于存储程序及程序需要的数据。</li>
<li>一个程序和它的数据在被CPU执行前必须移到计算机的内存中。</li>
<li>但内存是带电存储的（一旦断电数据就会消失），而且容量有限，所以要长时间存储程序或数据就需要使用硬盘。</li>
<li>输入和输出设备<ul>
<li>常见的输入设备：键盘和鼠标</li>
<li>常见的输出设备：显示器和打印机</li>
<li>显示器屏幕分辨率：是指显示设备水平和垂直方向上显示的像素（px）数。<ul>
<li>分辨率可以手工设置</li>
<li>分辨率越高，图像越锐化、越清晰。</li>
</ul>
</li>
</ul>
</li>
<li>通讯设备<ul>
<li>常见的设备有：拨号调制解调器、DSL（数字用户线）、电缆调制解调器、网络接口卡（NIC）、无线网络</li>
</ul>
</li>
</ul>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zehwakaka.github.io/2020/12/26/银河-夜/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alice's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/12/26/银河-夜/" itemprop="url">夜</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-12-26T15:20:14+08:00">
                2020-12-26
              </time>
            

            

            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/文学/" itemprop="url" rel="index">
                    <span itemprop="name">文学</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>银河空旷、坦荡，列车奔驰在夜的星空，似乎没有方向，也无法预测终点将在何时何地到来。<br>生命，就像这遥远无依的茫然，充满了未知，有过光明与黑暗、挚爱与哀愁，然后脆弱得好似<br>掉进银河的一颗星，瞬间沉没于无垠的浩瀚。忧伤的少年啊，在人生虚妄而伤感的旅途中，就<br>这样缓慢悲伤地成长。也许你想要的，仅是些许的幸福和被这个世界所认同，却无奈地总被排<br>斥在外。但不要哭泣，你所搭乘的列车，终点不会是伤感的归宿，而是银河最深处幸福恬静的<br>天堂。<br>                                                                                 《银河铁道之夜》 — 〔日〕宫泽贤治</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zehwakaka.github.io/2020/10/20/常用dos命令/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alice's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/10/20/常用dos命令/" itemprop="url">常用dos命令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-10-20T19:14:11+08:00">
                2020-10-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 盘符切换</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span>  /d 地址</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前目录下的所有文件</span></span><br><span class="line"></span><br><span class="line">dir</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换目录</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> change directory</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清理屏幕</span></span><br><span class="line"></span><br><span class="line">cls	(clear screen)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出终端</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看电脑ip</span></span><br><span class="line"></span><br><span class="line">ipconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开应用</span></span><br><span class="line"></span><br><span class="line"><span class="string">''</span><span class="string">'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">calc</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mspaint</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">notepad</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># ping 命令</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&gt; ping www.baidu.com</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 文件操作</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">md 目录名</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">rd 目录名</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">cd&gt; 文件名</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">del 文件名</span></span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zehwakaka.github.io/2020/10/13/IT专业英语/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alice's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/10/13/IT专业英语/" itemprop="url">IT专业英语</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-10-13T17:15:23+08:00">
                2020-10-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h1><ul>
<li>hosted service <strong>托管服务</strong></li>
<li>deliver <strong>接生、传送</strong></li>
<li>pervasive computing <strong>普适计算</strong></li>
<li>threshold <strong>阈值</strong></li>
<li>dissertation defense <strong>毕业答辩</strong></li>
<li>take many forms <strong>以多种形式</strong></li>
<li>expertise <strong>专业技能</strong></li>
<li>disciplines <strong>学科</strong></li>
<li>categorize <strong>分类</strong></li>
<li>entail <strong>牵涉</strong></li>
<li>distinct <strong>明显的</strong></li>
<li>namely <strong>表示穷举</strong></li>
<li>can be defined as <strong>被定义</strong></li>
<li>utilization <strong>使用</strong></li>
<li>much more than <strong>不仅仅</strong></li>
<li>infrastructure <strong>基础设施</strong></li>
<li>leverage <strong>利用、杠杆</strong></li>
<li>employ <strong>利用</strong></li>
<li>apply <strong>利用</strong></li>
<li>objective <strong>目标</strong></li>
<li>encompass <strong>包含</strong></li>
<li>macro <strong>宏观的</strong></li>
<li>feature <strong>以…为特色</strong></li>
<li>up one‘s game <strong>升级游戏</strong></li>
<li>buzz word <strong>流行行话</strong></li>
<li>channel firms <strong>公司</strong></li>
<li>access <strong>评估</strong></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zehwakaka.github.io/2020/09/21/随记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alice's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/21/随记/" itemprop="url">随记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-09-21T21:41:25+08:00">
                2020-09-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<blockquote>
<p>亲爱的朋友，倘若你既被大人物的喧嚣声吵得震耳欲聋，又备受小人的暗箭刺伤，请躲入你的孤独中去吧!</p>
<p>–尼采</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zehwakaka.github.io/2020/09/14/数值计算方法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alice's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/14/数值计算方法/" itemprop="url">数值计算方法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-09-14T21:45:52+08:00">
                2020-09-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第一章-数值计算引论"><a href="#第一章-数值计算引论" class="headerlink" title="第一章 数值计算引论"></a>第一章 数值计算引论</h1><h2 id="1-1-数值计算方法"><a href="#1-1-数值计算方法" class="headerlink" title="1.1 数值计算方法"></a>1.1 数值计算方法</h2><p>数值计算方法是以数学问题为研究对象，但它不是研究数学本身的理论，而是着重研究数学问题求解的数值方法及其相关理论，包括误差分析、收敛性和稳定性等内容。它应具有以下特点：</p>
<ol>
<li>把每个求解的数学问题用计算机所能直接处理的四则运算的有限形式的公式表达出来即构成数值方法。</li>
<li>每个数值方法要保证收敛性，数值方法的解即数值解能逼近精确解到要求的程度，还要保证数值稳定性。</li>
<li>数值方法有良好的计算复杂度，即运算次数要少，同时所需存储量要小。</li>
</ol>
<h2 id="1-2-误差的来源"><a href="#1-2-误差的来源" class="headerlink" title="1.2  误差的来源"></a>1.2  误差的来源</h2><ul>
<li>建立的数学模型和实际事物的差距称为模型误差或描述误差。</li>
<li>在建立的各种计算公式中，通常会包括一些参数，而这些参数又往往是通过观测或实验得到的，他们与真值之间有一定的差异，这就给计算带来了一定的误差。这种误差称为观测误差或测量误差。</li>
<li>在数值计算方法中不研究模型误差和观测误差，总是认为数学模型正确、合理的反映了客观实际，只是对求解数学模型时产生的误差进行分析研究，求解数学模型时常遇到的误差是截断误差和舍入误差。</li>
</ul>
<h2 id="1-3-近似数的误差表示"><a href="#1-3-近似数的误差表示" class="headerlink" title="1.3 近似数的误差表示"></a>1.3 近似数的误差表示</h2><p>近似数的误差常用绝对误差、相对误差和有效数字表示。下面介绍这三种表示方法及其相互之间的关系。</p>
<ol>
<li>绝对误差</li>
<li>相对误差</li>
<li>有效数字</li>
<li>有效数字与相对误差 </li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zehwakaka.github.io/2020/09/14/操作系统/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alice's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/09/14/操作系统/" itemprop="url">操作系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-09-14T21:45:19+08:00">
                2020-09-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第一章-操作系统引论"><a href="#第一章-操作系统引论" class="headerlink" title="第一章 操作系统引论"></a>第一章 操作系统引论</h1><ul>
<li><strong>操作系统：计算机硬件上的第一层软件；主要作用是管理好计算机硬件，提高利用率和系统吞吐量；为用户和应用程序提供简单接口，方便用户使用。</strong></li>
</ul>
<h2 id="1-1操作系统的目标和作用"><a href="#1-1操作系统的目标和作用" class="headerlink" title="1.1操作系统的目标和作用"></a>1.1操作系统的目标和作用</h2><p><strong>操作系统的目标与应用环境有关。</strong>例如在查询系统中所用的OS，希望能提供良好的人——机交互性；对于应用于工业控制、武器控制以及多媒体环境下的OS，要求其具有实时性；而对于微机上配置的OS，则更看重的是使用的方便性。</p>
<ol>
<li><p>操作系统的目标</p>
<ol>
<li><strong>方便性</strong>，用户采用高级语言编写程序，或使用OS提供的命令操作计算机，使计算机变得易学易用。</li>
<li><strong>有效性</strong>，提高系统资源的利用率，提高系统的吞吐量。</li>
</ol>
<p><strong>方便性和有效性是设计OS时最重要的两个目标。</strong></p>
<ol start="3">
<li><strong>可扩充性</strong>，令OS能适应计算机硬件、体系结构、计算机应用的发展。</li>
<li><strong>开放性</strong>，计算机硬件和软件兼容性的需要。</li>
</ol>
</li>
<li><p>操作系统的作用</p>
<p><strong>用户、资源管理、资源抽象等方面。</strong></p>
<ul>
<li><p><strong>OS作为用户与计算机硬件系统之间的接口</strong></p>
<p>OS处于用户与计算机硬件系统之间，用户通过OS来使用计算机系统。或则说，用户在OS帮助下能够方便、快捷、可靠地操纵计算机硬件和运行自己的程序。</p>
</li>
<li><p><strong>OS作为计算机系统资源的管理者</strong></p>
<p>在一个计算机系统中，通常都含有多种硬件和软件资源。归纳起来可将这些资源分为五类：<strong>处理机、存储器、I/O设备以及文件(数据和程序)、网络与通信管理。</strong></p>
<p>OS的主要功能正是对这四类资源进行有效的管理。处理机管理是用于分配与回收；存储器管理主要负责内存的分配与回收；I/O设备管理是负责I/O设备的分配(回收)与操纵；文件管理是用于实现对文件的存取、共享和保护。网络与通信管理是用于对网路资源、数据通信、应用服务等管理。</p>
<p><strong>资源技术管理</strong></p>
<ol>
<li>资源复用(解决物理资源数量不足)</li>
<li>资源虚拟(解决物理资源数量不足，提高服务的能力和水平)</li>
<li>资源抽象(处理系统的复杂性，解决资源的易用性)</li>
</ol>
</li>
</ul>
</li>
</ol>
<h2 id="2-1-资源管理"><a href="#2-1-资源管理" class="headerlink" title="2.1 资源管理"></a>2.1 资源管理</h2><ol>
<li><p>复用</p>
<p><strong>空分复用共享</strong>——该资源可进一步分割成更多和更小的单位供进程使用。</p>
<p><strong>时分复用共享</strong>——并不把资源进一步分割成更小的单位，进程可在一个时间段内独占使用整个物理资源。</p>
</li>
<li><p>虚拟</p>
<p>对资源进行转化、模拟或整合，把物理上的一个资源变成逻辑上的多个对应物的一类技术。</p>
<p>空分复用分割实际存在的物理资源，虚拟实现虚构假想的虚拟同类资源。资源虚拟的例子——虚拟设备、虚拟主存、虚拟文件、虚拟屏幕(终端)、虚拟信道。</p>
</li>
</ol>
<h2 id="2-2-OS实现了对计算机资源的抽象"><a href="#2-2-OS实现了对计算机资源的抽象" class="headerlink" title="2.2 OS实现了对计算机资源的抽象"></a>2.2 OS实现了对计算机资源的抽象</h2><p>一台完全无软件的计算机系统(即裸机)，由于它向用户提供的仅是硬件接口(物理接口)，因此，用户必须对物理接口的实现细节有充分的了解，这就致使该物理机器难以广泛使用。</p>
<p>为了方便用户使用I/O设备，人们在裸机上覆盖上一层I/O设备软件管理软件，如图1-2所示，由它来实现对I/O设备操作的细节，并向上将I/O设备抽象为一组数据结构和操作指令，方便用户实现对I/O操作。</p>
<p>同理，为了方便用户使用文件系统等计算机硬件资源，可以在计算机硬件上铺设多层软件，对硬件资源进行抽象，方便用户使用，也就构成了OS。</p>
<p><img src="\images\操作系统\1.png" alt="I/O软件隐藏了I/O操作实现的细节"></p>
<ul>
<li><p>推动操作系统发展的主要动力</p>
<ol>
<li>不断提高计算机资源利用率</li>
<li>方便用户</li>
<li>器件的不断更新换代</li>
<li>计算机体系结构的不断发展</li>
<li>不断提出新的应用需求</li>
</ol>
</li>
<li><p>观察和研究操作系统总纲</p>
<p><img src="\images\操作系统\2.png" alt="观察和研究操作系统总纲"></p>
</li>
<li><p>观察和研究操作系统4种观点细化</p>
<ol>
<li>服务用户观点——操作系统作为用户接口和公共服务程序</li>
<li>进程交互观点——操作系统作为进程执行的控制者和协调者</li>
<li>系统实现观点——操作系统作为扩展机或虚拟机</li>
<li>资源管理观点——操作系统作为资源的管理者和控制者</li>
</ol>
<ul>
<li><p><strong>操作系统即是”管理员”,又是”服务员”</strong></p>
<p>对内作为”管理员”,做好软硬件资源的管理、控制与调度,在裸机基础上形成虚拟机供应用程序使用，并对程序执行进行控制和协调，提高系统效率和资源利用率；</p>
<p>对外作为”服务员”，是用户与硬件的接口和人机界面，为用户提供最友善的运行环境和最佳的服务，操作系统在管理好资源的基础上，向外提供强有力的服务；</p>
<p>所以，资源管理是操作系统一项主要任务。</p>
</li>
<li><p><strong>OS作为用户接口和服务提供者</strong></p>
<p>操作系统提供友善的人机接口，使得用户能够方便、可靠、安全、高效地使用硬件和运行应用程序；</p>
<p>操作系统对计算机硬件进行改造和扩充，为用户提供强有力的各种服务。</p>
</li>
<li><p><strong>OS作为程序执行的控制者和协调者</strong></p>
<p>进程是支持程序执行的一种系统机制，进程是执行中的程序，系统以进程方式组织程序在计算机上运行；</p>
<p>OS需要提供机制，解决并发进程执行时产生的互斥、同步、通信和死锁问题。</p>
</li>
<li><p><strong>OS作为扩展机或虚拟机</strong></p>
<p>把操作系统分为若干层次或模块，逐步添加到裸机上，形成操作系统虚拟机；</p>
<p>操作系统把硬件的复杂性与用户隔离开来；</p>
<p>操作系统与硬件组成一台功能显著增强，使用更加方便，安全可靠性更好的扩展机器或虚拟机。</p>
</li>
<li><p><strong>OS作为资源管理者和控制者</strong></p>
<p>对软硬件资源进行资源复用、虚拟和抽象，管理各类资源，记录使用情况，确定分配策略，实施分配和回收，满足用户对资源的需求和申请。</p>
<p>提供机制协调应用程序对资源的使用冲突，研究资源使用的统一方法，为用户提供简单、有效的资源使用手段，在满足应用程序需求的前提下，最大限度地实现各种资源的共享，提高资源使用率。</p>
</li>
</ul>
</li>
</ul>
<h2 id="1-2-操作系统的发展过程"><a href="#1-2-操作系统的发展过程" class="headerlink" title="1.2 操作系统的发展过程"></a>1.2 操作系统的发展过程</h2><p>在20世纪50年代中期，出现了第一个简单的批处理OS;60年代中期开发出多道批处理系统;不久又推出分时系统，与此同时，用于工业和武器控制的实时OS也相继问世。</p>
<p>20世纪70到90年代，是VLSI和计算机体系结构大发展的年代，导致了微型机、多处理机和计算机网络的诞生和发展，与此相应地，也相继开发出了微机OS、多处理机OS和网络OS，并得到极为迅猛的发展。</p>
<p>具体发展历程可以分为以下几个阶段：</p>
<p><img src="\images\操作系统\3.png" alt="操作系统的发展过程"></p>
<ul>
<li><p>未配置操作系统的计算机系统</p>
<ol>
<li><p>人工操作方式</p>
<p>早期的操作方式是由程序员将事先已穿孔的纸带(或卡片)，装入纸带输入机(或卡片输入机)，然后将纸带(或卡片)上的程序和数据输入计算机，进行运行。仅当程序运行完毕并取走计算结果后，才允许下一个用户上机。这种人工操作方式有以下两方面的缺点：</p>
<ul>
<li>用户独占全机，即一台计算机的全部资源由上机用户所独占。</li>
<li>CPU等待人工操作。当用户进行装带(卡)、卸带(卡)等人工操作时，CPU及内存等资源是空闲的。</li>
</ul>
</li>
<li><p>脱机输入/输出(Off-Line I/O)方式</p>
<p>为了解决人机矛盾及CPU和I/O设备之间速度不匹配的矛盾，20世纪50年代末出现了脱机I/O技术。</p>
<p>该技术是事先将装有用户程序和数据的纸带1装入纸带输入机，在一台外围机的控制下，把纸带(卡片)上的数据(程序)输入到磁带上。当CPU需要这些程序和数据时，再从磁带上高速地调入内存。</p>
<p>优点：减少CPU空闲世纪；提高I/O速度。</p>
<p><img src="\images\操作系统\4.png" alt="脱机I/O示意图"></p>
</li>
</ol>
</li>
<li><p>单道批处理系统</p>
<ol>
<li><p>单道批处理系统(Simple Batch Processing System)</p>
<p>为了实现对作业的连续处理，需要先把一批作业以脱机方式输入到磁带上，并在系统中配上监督程序(Monitor),在它的控制下，使这批作业能一个接一个地连续处理。</p>
</li>
<li><p>单道批处理系统特点</p>
<p>单道批处理作用：旨在解决人机矛盾、CPU和I/O设备速度之间的矛盾，一定程度上提高系统的利用率和吞吐量。</p>
<p>最主要的缺点：系统中的资源仍有得不到充分的利用。这是因为在内存中仅有一道程序，每逢该程序在运行中发出I/O请求后，CPU便处于等待状态，必须在其I/O完成后才继续运行。又因I/O设备的低速性，更使CPU的利用率显著降低。图1-5示出了单道程序的运行情况，从图可以看出：在t2~t3、t6~t7时间间隔内CPU空闲。</p>
<p><img src="\images\操作系统\5.png" alt="单道程序的运行情况"></p>
</li>
</ol>
</li>
<li><p>多道批处理系统(Multiprogrammed Batch Processing System)</p>
<ol>
<li><p>多道程序设计的基本概念</p>
<p>为了进一步提高资源的利用率和系统吞吐量，在20世纪60年代中期引入了多道程序设计技术，由此形成了多道批处理系统。图1-6示出了四道程序时的运行情况。</p>
<p><img src="\images\操作系统\6.png" alt="多道程序的运行情况"></p>
</li>
<li><p>CPU利用率是主存中多道程序道数的函数</p>
<p><img src="\images\操作系统\7.png" alt="多道程序设计的道数"></p>
<p>程序等待I/O操作的时间的比例为p，当主存中有n道程序时，所有程序都等待I/O的概论是p的n次方，那么，</p>
<p>CPU利用率 = 1-p的n次方</p>
<p>n称多道程序的道数或度数，可见CPU的利用率是n的函数 </p>
<ol start="3">
<li><p>多道批处理系统的优缺点</p>
<p>多道批处理系统的优点：</p>
<ul>
<li>资源利用率高。引入多道批处理能使多道程序交替运行，以保持CPU处于忙碌状态；在内存中装入多道程序可提高内存的利用率；此外还可以提高I/O设备的利用率。</li>
<li>系统吞吐量大。能提高系统吞吐量的主要原因可归结为：</li>
</ul>
<ol>
<li>CPU和其他资源保持”忙碌”状态；</li>
<li>仅当作业完成时或运行不下去时才进行切换，系统开销小。</li>
</ol>
<p>多道批处理系统的缺点：</p>
<ul>
<li>平均周转时间长。由于作业要排队依次进行处理，因而作业的周转时间较长，通常需几个小时，甚至几天。</li>
<li>无交互能力。用户一旦把作业交给系统后，直至作业完成，用户都不能与自己的作业进行交互，修改和调试程序极为不方便。</li>
</ul>
<ol start="4">
<li>实现多道批处理系统需要解决的问题<ul>
<li>处理机争用问题。既要能满足各道程序运行的需要，又要能提高处理机的利用率。(处理器的管理和调度)</li>
<li>内存分配和保护问题。系统应能为每道程序分配必要的内存空间，使他们“各得其所”，且不会因某道程序出现异常情况而破坏其他程序。(存储保护与程序浮动)</li>
<li>I/O设备分配问题。系统应采取适当的策略来分配系统中的I/O设备，以达到能方便用户对设备的使用，又能提高设备利用率的目的。(系统资源的管理和调度)</li>
<li>文件的组织和管理问题。系统应能有效地组织存放在系统中的大量的程序和数据，使它们既便1于用户使用，又能保证数据的安全性。</li>
<li>作业管理问题。系统中存在着各种作业(应用程序)，系统应能对系统中所有的作业进行合理的组织，以满足这些作业用户的不同要求。</li>
<li>用户与系统的接口问题。为使用户能方便的使用操作系统，OS还应提供与OS之间的接口。</li>
</ul>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>分时系统(Time Sharing System)</p>
<ol>
<li><p>分时系统的引入</p>
<p>提高人——机交互的需要，是推动分时系统形成和发展的主要动力。用户的需求具体表现在以下几个方面：</p>
<ul>
<li>人——机交互：用户希望能独占计算机。</li>
<li>共享主机：同时供许多用户使用，又能满足上述人——机交互需要。</li>
</ul>
</li>
</ol>
</li>
</ul>
<ol start="2">
<li><p>分时系统实现中的关键问题</p>
<p>为了能够实现人——机交互，必须解决的问题是：如何使用户能与自己的作业进行交互。如何实现人——机交互的实时性。如何实现多人同时共享一台计算机，感觉不到他人的存在。</p>
<ul>
<li>及时接收：配置多路卡和缓存区，实现分时多路复用；用极短的时间接收输入。<ul>
<li>及时处理：作业直接进入内存中；采用轮转运行方式(引入时间片)。</li>
</ul>
</li>
</ul>
<ol start="3">
<li><p>分时系统的特征</p>
<p>分时系统与多道批处理系统相比，具有非常明显的不同特性，可以归纳成以下四个方面：</p>
<ul>
<li>多路性：一台主机，多台中断，分时原则进行服务。</li>
<li>独立性：终端用户互不干扰。</li>
<li>及时性：用户的请求能在短时间内得到相应。</li>
<li>交互性：用户通过终端可以与系统进行广泛的人机对话。</li>
</ul>
</li>
</ol>
</li>
</ol>
<ul>
<li><p>实时系统(Real Time System)</p>
<ol>
<li><p>实时系统的类型</p>
<p>实时系统以时间作为关键参数，能及时相应外部事件请求。</p>
<p>随着计算机应用的普及，实时系统的类型也相应增多，下面列出当前常见的几种：</p>
<ul>
<li>工业(武器)控制系统。</li>
<li>信息查询系统。</li>
<li>多媒体系统。</li>
<li>嵌入式系统。</li>
</ul>
</li>
<li><p>实时任务的类型</p>
<ul>
<li><p>周期性实时任务和非周期性实时任务，都有一个截止时间(Deadline)，可以分为：开始截止时间；完成截止时间。</p>
</li>
<li><p>硬实时任务和软实时任务。</p>
<p>硬实时任务，指系统必须满足任务对截止时间的要求。</p>
<p>软实时任务，指系统并不需要严格执行截止时间。</p>
<p><strong>注意分类说明的特征和要点：以某种属性，进行分类</strong></p>
</li>
</ul>
</li>
<li><p>实时系统与分时系统特征的比较</p>
<ul>
<li><p>多路性：分时系统按照分时原则为多路终端提供服务。实时系统多路性指系统周期性地对多个对象进行控制(服务)。</p>
</li>
<li><p>独立性：两种系统对于不同用户(终端)均保证彼此互不干扰。</p>
</li>
<li><p>及时性：分时系统中依照人的接受程度，实现实时性。实时系统中以截止时间来实现实时性。</p>
</li>
<li><p>交互性：分时系统能向终端提供数据处理、资源共享等服务。实时系统只能提供有限的特定操作。</p>
</li>
<li><p>可靠性：分时系统要求一般。实时系统要求很高。</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>微机操作系统的发展</p>
<p>微机系统可以按照微机的字长来分：</p>
<ol>
<li><p>单用户单任务操作系统</p>
<ul>
<li>CP/M：8位微机操作系统</li>
<li>MS-DOS：16位、32位操作系统</li>
</ul>
</li>
<li><p>单用户多任务操作系统</p>
<p>单用户多任务操作系统的含义是，只允许一个用户上机，但允许用户把程序分为若干个任务，使它们并发执行，从而有效地改善了系统的性能。</p>
<p>例如：Windows1.0-3.1，window85/98，/XP/7/Server</p>
</li>
<li><p>多用户多任务操作系统</p>
<p>多用户多任务操作系统的含义是，允许多个用户通过各自的终端，使用同一台极其，共享主机系统中的各种资源，而每个用户程序又可进一步分为几个任务，使它们能并发执行，从而可进一步提高资源利用率和系统吞吐量。在大、中和小型机中所配置的大多是用户多任务操作系统。</p>
<p>在32位微机上，也有不少配置的是多用户多任务操作系统，其中最有代表性的是UNIX OS，Linux OS。</p>
</li>
</ol>
</li>
</ul>
<h2 id="1-3-操作系统的基本特征"><a href="#1-3-操作系统的基本特征" class="headerlink" title="1.3 操作系统的基本特征"></a>1.3 操作系统的基本特征</h2><p>多道批处理系统、分时系统和实时系统这三种基本操作系统都具有各自不同的特征，但它们也共同具有并发、共享、虚拟和异步四个基本特征。</p>
<ul>
<li><p>并发</p>
<p>正是系统中的程序能并发执行这一特征，才使得OS能有效地提高系统中的资源利用率，增加系统的吞吐量。</p>
<ol>
<li><p>并行与并发</p>
<p>并行性和并发性是既相似又有区别的两个概念。并行性是指两个或多个事件在同一时刻发生。而并发性是指两个或多个事件在同一时间间隔内发生。</p>
</li>
<li><p>引入进程</p>
<p>在一个未引入进程的系统中，在属于同一个应用程序的计算程序和I/O程序之间只能是顺序执行。</p>
<p>但在为计算程序和I/O程序分别建立一个进程(Process)后，这两个进程便可并发执行。若对内存中的多个程序都分别建立一个进程，它们就可以并发执行，这样便能极大地提高系统资源的利用率，增加系统的吞吐量。</p>
<p>进程：指在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令、数据和堆栈等组成的，是一个能独立运行的活动实体。(进程和并发是现代操作系统中最重要的概念，也是操作系统运行的基础。)</p>
</li>
</ol>
</li>
<li><p>共享(Sharing)</p>
<p>OS中的资源共享：指系统中的资源可供内存中多个并发执行的进程共同使用(注：进程在内存中)</p>
<p>为什么共享这么重要？</p>
<ol>
<li>系统中的资源远少于多道程序需求的总和。</li>
<li>各种资源属性不同，资源复用方式也不同。</li>
</ol>
<ul>
<li><p>互斥共享方式</p>
<p>系统中的某些资源，如打印机、磁带机等，虽然可以提供给多个进程(线程)使用，但应规定在一段时间内，只允许一个进程访问该资源。为此，需要互斥访问方式。</p>
<p>互斥共享方式：一个时间段内只允许一个进程访问这一个资源的资源共享方式。这种资源被称为临界资源。</p>
</li>
<li><p>同时访问方式</p>
<p>系统中还有另一类资源，允许在一段时间内由多个进程”同时”对它们进行访问。这里所谓的”同时”，在单处理机环境下是宏观意义上的，而在微观上，这些进程对该资源的访问是交替进行。例如：磁盘。</p>
</li>
</ul>
</li>
<li><p>虚拟(Virtual)</p>
<ol>
<li><p>时分复用技术</p>
<p>使用某设备为一个用户服务的空闲时间，又转去为其他用户服务，使设备得到最充分的利用。</p>
<ul>
<li>虚拟处理机技术：为每一道程序建立至少一个进程，让多道程序并发执行。</li>
<li>虚拟设备技术：使用分时复用的方法，将一台物理I/O设备虚拟为多台逻辑上的I/O设备。</li>
</ul>
</li>
<li><p>空分复用技术</p>
<p>它是利用存储器的空闲空间，分区域存放和运行其他的多道程序。把空分复用技术用于对存储空间的管理，可以提高存储空间的利用率。</p>
<p>进一步引入虚拟存储技术，可以从逻辑上扩大存储器的容量。</p>
</li>
</ol>
</li>
<li><p>异步(Asynchronism)</p>
<p>在多道程序环境下，系统允许多个进程并发执行。在单处理机环境下，由于系统中只有一台处理机，因而每次只允许一个进程执行，其余进程只能等待。</p>
<p>当正在执行的进程提出某种资源要求时，如打印请求，而此时打印机正在为其他进程打印，由于打印机属于临界资源，因此正在执行的进程必须等待，并释放出处理机，直到打印机空闲，并再次获得处理机时，该进程方能继续执行。</p>
<p>可见，由于资源等因素的限制，使进程的执行通常都不可能”一气呵成”，而是以”停停走走”的方式运行。</p>
<p><strong>进程的异步性：进程以人们不可预知的速度向前推进。</strong></p>
</li>
</ul>
<h2 id="1-4-操作系统的主要功能"><a href="#1-4-操作系统的主要功能" class="headerlink" title="1.4 操作系统的主要功能"></a>1.4 操作系统的主要功能</h2><p>引入OS的主要目的是，为多道程序的运行提供良好的运行环境，以保证多道程序能有条不紊地、高效地运行，并能最大程序地提高系统中各种资源的利用率，方便用户的使用。</p>
<p>传统OS中应具有处理机管理、存储器管理、设备管理和文件管理等基本功能。此外，为了方便用户使用OS，还需向用户提供方便的用户接口。</p>
<ul>
<li><p>处理机管理功能</p>
<p>主要功能：创建和撤销进程，对诸进程的运行进行协调，实现进程之间的信息交换，以及按照一定的算法把处理机分配给进程。</p>
<ol>
<li>进程控制：为作业创建进程、撤销已结束的进程、控制进程在运行过程中的状态转换。</li>
<li>进程同步：进程互斥方式、进程同步方式。</li>
<li>进程通信：实现相互合作进程之间的信息交换。</li>
<li>调度：第一步 作业调度；第二步 进程调度。</li>
</ol>
</li>
<li><p>存储器管理功能</p>
<p>功能：内存分配和回收、内存保护、地址映射和内存扩充。</p>
<ul>
<li><p>内存分配</p>
<p>内存分配的主要任务是：</p>
<ol>
<li>为每道程序分配内存空间，使它们”各得其所”。</li>
<li>提高存储器的利用率，尽量减少不可用的内存空间(碎片)。</li>
<li>允许正在运行的程序申请附加的内存空间，以适应程序和数据动态增长的需要。</li>
</ol>
<p>OS在实现内存分配时，可采取静态和动态两种方式：</p>
<ol>
<li>静态分配方式。每个作业的内存空间是在作业装入时确定的，在作业装入后的整个运行期间不允许该作业再申请新的内存空间，也不允许作业在内存中”移动”。</li>
<li>动态分配方式。每个作业所要求的基本内存空间虽然也是在装入时确定的，但允许作业在运行过程中继续申请新的附加内存空间，以适应程序和数据的动态增长，也允许作业在内存中”移动”。</li>
</ol>
</li>
<li><p>内存保护</p>
<p>内存保护的主要任务是：</p>
<ol>
<li>确保每道用户程序都仅在自己的内存空间内运行，彼此互不干扰。</li>
<li>绝不允许用户访问操作系统的程序和数据，也不允许用户程序转移道非共享的其他用户程序中去执行。</li>
</ol>
</li>
<li><p>地址映射</p>
<p>在多道程序环境下，由于每道程序经编译和链接后所形成的可装入程序其他地址都是从0开始的，但不可能将它从”0”地址(物理)开始装入内存，致使(各程序段的)地址空间内的逻辑地址与其在内存空间中的物理地址并不相一致。</p>
<p>为保证程序能正确运行，存储器管理必须提供地址映射功能，即能够将地址空间中的逻辑地址转换为内存空间中与之对应的物理地址。(该功能应在硬件的支持下完成)</p>
</li>
<li><p>内存扩充</p>
<p>内存扩充并非是从物理上去扩大内存的容量，而是借助于虚拟存储技术，从逻辑上扩充内存容量，使用户所感觉到的内存容量比实际内存容量大得多，以便让更多的用户程序能并发运行。</p>
<p>为了能在逻辑上扩充内存，系统必须设置内存扩充机制(包含少量的硬件)，用于实现下述各功能：</p>
<ol>
<li>请求调入功能。</li>
<li>置换功能。</li>
</ol>
</li>
</ul>
</li>
<li><p>设备管理功能</p>
<p>设备管理的主要任务如下：</p>
<ol>
<li>完成用户进程提出的I/O请求，为用户进程分配所需的I/O设备，并完成指定的I/O操作。</li>
<li><p>提高CPU和I/O设备的利用率，提高I/O速度，方便用户使用I/O设备。</p>
<p>为实现上述任务，设备管理应具有缓冲管理、设备分配和设备处理以及虚拟设备等功能。</p>
</li>
<li><p>缓存管理</p>
</li>
<li>设备分配</li>
<li>设备处理</li>
</ol>
</li>
<li><p>文件管理功能</p>
<p>对用户文件和系统文件进行管理以方便用户使用，并保证文件的安全性。主要包含以下内容：</p>
<ol>
<li>文件存储空间的管理</li>
<li>目录管理</li>
<li>文件的读/写管理和保护<ul>
<li>文件的度/写管理。</li>
<li>文件保护。</li>
</ul>
</li>
</ol>
</li>
<li><p>操作系统与用户之间的接口</p>
<ol>
<li><p>用户接口</p>
<ul>
<li>联机用户接口。</li>
<li>脱机用户接口。</li>
<li>图形用户接口。</li>
</ul>
</li>
<li><p>程序接口</p>
<p>程序接口是为用户程序在执行中访问系统资源而设置的，是用户程序取得操作系统服务的唯一途径。</p>
<p>它是由一组系统调用组成的，每一个系统调用都是一个能完成特定功能的子程序。每当应用程序要求OS提供某种服务(功能)时，便调用具有相应功能的系统调用(子程序)。</p>
</li>
</ol>
</li>
<li><p>现代操作系统的新功能</p>
<p>现代操作系统是在传统操作系统基础上发展起来的，它除了具有传统操作系统的功能外，还增加了面向安全、面向网络和面向多媒体等功能。</p>
<ol>
<li>系统安全<ul>
<li>认证技术</li>
<li>密码技术</li>
<li>访问控制技术</li>
<li>反病毒技术</li>
</ul>
</li>
<li>网络的功能和服务<ul>
<li>网络通信</li>
<li>资源管理</li>
<li>应用互操作</li>
</ul>
</li>
<li>支持多媒体<ul>
<li>接纳控制功能</li>
<li>实时调度</li>
<li>多媒体文件的存储</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="1-5-OS结构设计"><a href="#1-5-OS结构设计" class="headerlink" title="1.5 OS结构设计"></a>1.5 OS结构设计</h2><p>根据软件工程开发要求(质量、费用)，先后出现多种操作系统的开放方法，如：模块化方法、结构化方法和面向对象的方法等。</p>
<ul>
<li><p>传统操作系统结构</p>
<ol>
<li><p>无结构操作系统</p>
<p>早期开发操作系统，注意力主要放在功能的实现和效率上，缺乏首尾一致的设计思想。此时的OS是为一组过程的集合，每个过程可以任意地荷香调用其他过程，致使操作系统内部既复杂又混乱，因此，这种OS是无结构的，也有人把它称为整体系统结构。</p>
</li>
<li><p>模块化结构OS</p>
<ul>
<li><p>模块化程序设计技术的基本概念</p>
<p>模块化程序设计技术基于”分解”和“模块化”的原则来控制大型软件的复杂度。按其功能精心地划分为若干个具有一定独立性和大小的模块。每个模块具有某方面的管理功能，如：进程管理模块、存储器管理模块、I/O设备管理模块等。图1-7示出了由模块、子模块等组成的模块化OS结构。</p>
<p><img src="\images\操作系统\8.png" alt="模块化结构的操作系统"></p>
</li>
<li><p>模块独立性</p>
<p>在模块-接口法中，关键问题是模块的划分和规定好模块之间的接口。如果我们在划分模块时将模块划分得太小，虽然可以降低模块本身的复杂性，但会引起模块之间的联系过多，从而会造成系统比较混乱；如果将模块划分得过大，又会增加模块内部的复杂性，使内部的联系增加，因此在划分模块时，应在二者间进行权衡。</p>
<p>同时，必须充分注意模块的独立性。衡量模块独立性的标准：低耦合、高内聚。</p>
</li>
<li><p>模块接口法的优点</p>
<p>利用模块-接口法开发的OS，较之无结构OS具有以下明显的优点：</p>
<ol>
<li>提高OS设计的正确性、可理解性和可维护性。</li>
<li>增强OS的可适用性。</li>
<li>加速OS的开发过程</li>
</ol>
<p>模块化结构设计仍存在下述问题：</p>
<ol>
<li>在OS设计时，对各模块间的接口规定很难满足在模块设计完成后对接口的实际需求。</li>
<li>在OS设计阶段，设计者必须做出一系列的决定(决策)，每一个决定必须建立在上一个决定的基础上，但模块化结构设计中，各模块的设计齐头并进，无法寻找一个可靠的决定顺序，造成各种决定的”无序性”，这将使程序人员很难做到”设计中的每一步决定”都是建立在可靠的基础上，因此模块-接口法又被称为”无序模块法”。</li>
</ol>
</li>
</ul>
</li>
<li><p>分层式结构OS</p>
<ul>
<li><p>分层式结构的基本概念</p>
<p>为了将模块-接口法中”决定顺序”的无序性变为有序性，引入了有序分层法，分层法的设计任务是，在目标系统An和裸机系统(又称宿主系统)A0之间，铺设若干个层次的软件A1、A2、A3、…、An-1，使An通过An-1、An-2、…、A2、A1层，最终能在A0上运行。在操作系统中，常采用自底向上法来铺设这些中间层。</p>
</li>
<li><p>分层结构的优缺点</p>
<p>分层结构的主要优点：</p>
<ul>
<li>易保证系统的正确性。</li>
<li>易扩充和易维护性。</li>
</ul>
<p>分层结构的主要缺点：</p>
<p>系统效率降低。由于层次结构是分层单向依赖的，必须在每层之间都建立层次间的通信机制，OS每执行一个功能，通常要自上而下地穿越多个层次，这无疑会增加系统的通信开销，从而导致系统效率的降低。</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>客户/服务器模式(Client/Server Model)</p>
<p>简介</p>
<ol>
<li><p>客户/服务器模式的由来、组成和类型</p>
<p>客户/服务器系统主要由三部分组成</p>
<ul>
<li>客户机</li>
<li>服务器</li>
<li>网络系统</li>
</ul>
</li>
<li><p>客户/服务器之间的交互</p>
<ul>
<li>客户发送请求消息</li>
<li>服务器接收消息</li>
<li>服务器回送消息</li>
<li>客户机接收消息</li>
</ul>
</li>
<li><p>客户/服务器模式的优点</p>
<ul>
<li>数据的分布处理和存储</li>
<li>便于集中管理</li>
<li>灵活性和可扩充性</li>
<li>易于改编应用软件</li>
</ul>
</li>
</ol>
</li>
<li><p>1.5.3 面向对象的程序设计(Object-Orientated Programming)技术简介</p>
<ol>
<li><p>面向对象技术的基本概念</p>
<p>面向对象技术是基于”抽象”和”隐蔽”原则来控制大型软件的复杂度。</p>
<ul>
<li><p>对象</p>
<p>在面向对象的技术中，是利用被封装的数据结构(变量)和一组对它进行操作的过程(方法)来表示系统中的某个对象的，如图1-8所示。</p>
<p><img src="\images\操作系统\9.png" alt="一个对象的示意图"></p>
<p>对象中的变量(数据)对我是隐蔽的，外界不能直接访问，需要通过该对象中的一组方法对它进行访问。</p>
<p><img src="\images\操作系统\10.png" alt="类和对象的关系"></p>
</li>
<li><p>对象类</p>
<p>在实践中，有许多对象可能表示的是同一类事物，每一个对象具有自己的变量集合，而它们所具有的方法是相同的。如果为每一个相似的对象都定义一组变量和方法，显然是低效的，由此产生了”对象类”的概念，利用”对象类”来定义一组大体相似的对象。</p>
<p>一个类同类定义了一组变量和针对该变量的一组方法，用它们来描述一组对象的共同属性和行为。类是在对象上的抽象，对象则是类的实例。对象类中所定义的变量在实例中均有具体的值。</p>
</li>
<li><p>继承</p>
<p>在面向对象的技术中，可以根据已有类来定义一个新的类，新类被称为子类(B),原来的类被称为父类(A),见图1-10所示。</p>
<p><img src="\images\操作系统\11.png" alt="类的继承关系"></p>
</li>
</ul>
</li>
<li><p>面向对象技术的优点</p>
<p>在操作系统设计时，将计算机中的实体作为对象来处理，可带来如下好处：</p>
<ul>
<li>通过”重用”提高产品质量和生产率。</li>
<li>使系统具有更好的易修改性和易扩展性。</li>
<li>更易于保证系统的”正确性”和”可靠性”。</li>
</ul>
</li>
</ol>
</li>
<li><p>微内核OS结构</p>
<p>微内核(MicroKernel),能有效地支持多处理机，如windowsXP/7/8。为了提高操作系统的”正确性”、”灵活性”、”易维护性”、”可扩充性”，大多采用基于客户/服务器模式的微内核结构，将操作系统划分为:微内核和多服务器。微内核操作系统尚无一致定义，本文将从下列四个方面进行阐述。</p>
<ol>
<li><p>微内核操作系统的基本概念</p>
<ul>
<li><p>足够小的内核</p>
<p>在微内核操作系统中，内核是能实现现代OS最基本核心功能的小型内核。它只是将操作系统中最基本的部分放入微内核。</p>
<p>微内核通常包括：</p>
<ul>
<li>与硬件处理紧密相关的部分</li>
<li>一些较基本的功能</li>
<li>客户和服务器之间的通信</li>
</ul>
</li>
<li><p>基于客户/服务器模式</p>
<p>单机微内核操作系统中，基本都采用客户/服务器模式，将操作系统中最基本的部分放入内核中，而把操作系统的绝大部分功能都放在微内核外面的一组服务器(进程)中实现。</p>
<p>例如:用于提供对进程(线程)进行管理的进程(线程)服务器、提供虚拟存储器管理功能的虚拟存储器服务器、提供I/O设备管理的I/O设备管理服务器等，它们都是被作为进程来实现的，运行在用户态。</p>
<p>客户与服务器之间是借助微内核提供的消息传递机制来实现信息交互的。图1-11示出了在单机环境下的客户/服务器模式。</p>
<p><img src="\images\操作系统\12.png" alt="在单机环境下的客户/服务器模式"></p>
</li>
<li><p>应用”机制与策略分离”原理</p>
<p>在现在操作系统的结构设计中，经常利用”机制与策略分离”的原理来构造OS结构。</p>
<p>机制，是指实现某一功能的具体执行机构。(放在:基层，微内核)</p>
<p>策略，则是在机制的基础上借助于某些参数和算法来实现该功能的优化，或达到不同的功能目标。(放在：高层)</p>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<pre><code>- 采用面向对象技术

  通过基于面向对象技术中的&quot;抽象&quot;和&quot;隐蔽&quot;原则控制系统的复杂性。

  利用&quot;对象&quot;、&quot;封装&quot;和&quot;继承&quot;等概念来确保操作系统的&quot;正确性&quot;、&quot;可靠性&quot;、&quot;易修改性&quot;、&quot;易扩展性&quot;等，并提高操作系统的设计速度。
</code></pre><ol start="2">
<li><p>微内核的基本功能</p>
<p>微内核一般将机制部分以及与硬件紧密相关的部分放入微内核中。由此可知微内核通常具有如下几方面的功能：</p>
<ul>
<li>进程(线程)管理：进程调度属于调度功能的机制部分(内核)；进程分类、优先级设定属于策略部分(微内核外)。</li>
<li>低级存储器管理：低级存储器管理机制(内核)；虚拟存储器管理策略(微内核外)。</li>
<li>中断和陷入处理。</li>
</ul>
</li>
<li><p>微内核操作系统的优点</p>
<p>由于微内核OS结构是建立在模块化、层次化结构的基础上的，并采用了客户/服务器模式和面向对象的程序设计技术，因此，微内核结构的操作系统是集各种技术优点之大成：</p>
<ol>
<li>提高了系统的可扩展性。</li>
<li>增强了系统的可靠性。</li>
<li>可移植性强。</li>
<li>提供了对分布式系统的支持。</li>
<li>融入了面向对象技术。</li>
</ol>
</li>
<li><p>微内核操作系统存在的问题</p>
<ul>
<li>较之早期的操作系统，微内核操作系统的运行效率有所降低。</li>
<li>一次服务请求，需要利用消息实现多次交互。</li>
<li>频繁出现用户/内核模式与上下文的多次切换。</li>
</ul>
<p>如图1-12所示，其中的文件服务器还需要磁盘服务器的帮助，这时就需要进行8次上下文的切换。</p>
<p><img src="\images\操作系统\13.png" alt="在传统OS和微内核OS中的上下文切换"></p>
</li>
</ol>
<h2 id="1-6-操作系统基本服务和用户接口"><a href="#1-6-操作系统基本服务和用户接口" class="headerlink" title="1.6 操作系统基本服务和用户接口"></a>1.6 操作系统基本服务和用户接口</h2><ul>
<li><p>1.6.1 基本服务和用户接口</p>
<ul>
<li>创建程序</li>
<li>执行程序</li>
<li>数据I/O</li>
<li>信息存取</li>
<li>通信服务</li>
<li>错误检测和处理</li>
</ul>
<p>还具有其他功能：资源分配，统计，保护。</p>
<p>用户接口：</p>
<p><img src="\images\操作系统\14.png" alt="用户接口"></p>
</li>
<li><p>程序接口与系统调用</p>
<p>什么是系统调用？</p>
<p>系统调用的作用？</p>
<p>系统调用是应用程序获得操作系统服务的唯一途径。</p>
<p>内核的主体是系统调用的集合，内核可以看成是特殊的公共子程序。</p>
<p>操作系统的功能通过一组称为系统调用(system call)的接口呈现给用户，内核提供一系列实现预定功能的内核函数，系统调用把应用程序的请求传达给内核，内核调用对应的内核函数完成请求所需处理后，再将处理结果返回给应用程序。</p>
</li>
<li><p>系统调用的作用</p>
<p>系统调用是一种中介角色，把用户与硬件隔离开来，应用程序通过系统调用才能请求系统服务和使用系统资源，其作用有：</p>
<ul>
<li>一是内核可基于权限和规则对资源访问进行裁决，保证系统的安全性；</li>
<li>二是系统调用封装资源抽象，提供一致性接口，避免用户使用资源时可能发生的错误，且使编程方便效率高。</li>
</ul>
</li>
<li><p>API、库函数、系统调用</p>
<p>应用程序能直接使用系统调用吗？</p>
<p>POSIX(Portable Operating System Interface for Computer Environment)标准；</p>
<p>API和库函数</p>
<p>库函数和系统调用。</p>
</li>
<li><p>API、库函数、系统调用之间的关系</p>
<p><img src="\images\操作系统\15.png" alt="API、库函数、系统调用之间的关系"></p>
</li>
<li><p>Linux系统程序、库函数、系统调用之间的关系</p>
<p><img src="\images\操作系统\16.png" alt="Linux系统程序、库函数、系统调用之间的关系"></p>
</li>
</ul>
<h1 id="第二章-进程的描述与控制"><a href="#第二章-进程的描述与控制" class="headerlink" title="第二章 进程的描述与控制"></a>第二章 进程的描述与控制</h1><h2 id="2-1-前趋图和程序执行"><a href="#2-1-前趋图和程序执行" class="headerlink" title="2.1 前趋图和程序执行"></a>2.1 前趋图和程序执行</h2><p>  在早期未配置OS的系统和单道批处理系统缺点：程序顺序执行，内存中仅装入一道用户程序，独占系统中的所有资源。</p>
<p>  解决方法：多道程序系统，同时装入多个程序，进程并发执行，共享系统资源。</p>
<ul>
<li><p>2.1.1 前趋图</p>
<p>为了能更好地描述程序的顺序和并发执行情况，我们先介绍用于描述程序执行先后顺序的前趋图。</p>
<p>前趋图(Precedence Graph)，是指一个有向无环图，可记为DAG(Directed Acyclic Graph),它用于描述进程之间执行的先后顺序。</p>
<p>图中的每个结点可用来表示一个进程或程序段，乃至一条语句，结点间的有向边则表示两个结点之间存在的偏序(Partial Order)或前趋关系(Precedence Relation)。</p>
<p>进程(或程序)之间的前趋关系可用”-&gt;”来表示，如果进程Pi和Pj存在着前趋关系，可表示为(Pi，Pj)属于 -&gt;,也可写成Pi-&gt;Pj,表示在Pj开始执行之前Pi必须完成。</p>
<p>称Pi是Pj的直接其拿去，而称Pj是Pi的直接后继。在前趋图中把没有前趋的结点称为初始结点(Initail Node),把没有后继的结点称为终止结点(Final Node)。</p>
<p>每个结点还具有一个重量(Weight),用于表示该结点所含有的程序量或程序的执行时间。</p>
<p>在图2-1(a)所示的前趋图中，存在着如下前趋关系：</p>
<p>P1-&gt;P2,P1-&gt;3,P1-&gt;P4,P2-&gt;P5,P3-&gt;P5,P4-&gt;P6,P4-&gt;P7,P5-&gt;P8,P6-&gt;P8</p>
</li>
</ul>
<p>  ​     </p>
<p>  ​     </p>
<p>  ​     </p>
<p>  ​     </p>
<p>  ​     </p>
<p>  ​     </p>
<p>  ​     </p>
<p>​     </p>
<p>​     </p>
<p>​     </p>
<p>​     </p>
<p>​     </p>
<p>  ​    </p>
<p>  ​    </p>
<p>  ​    </p>
<p>​     </p>
<p>​     </p>
<p>​     </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zehwakaka.github.io/2020/08/26/计算机网络复习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alice's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/26/计算机网络复习/" itemprop="url">计算机网络复习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-26T17:09:08+08:00">
                2020-08-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="第一章-概述"><a href="#第一章-概述" class="headerlink" title="第一章 概述"></a>第一章 概述</h1><h2 id="1-3-互联网的组成"><a href="#1-3-互联网的组成" class="headerlink" title="1.3 互联网的组成"></a>1.3 互联网的组成</h2><ol>
<li><p>边缘部分：由所有连接在互联网上的主句组成。</p>
<p>端系统之间的通信方式通常可划分为两大类：</p>
<ul>
<li>客户-服务器方式(C/S方式)：即Client/Server方式，简称C/S方式。</li>
<li>对等方式(P2P方式)：即Peer-to-Peer方式。</li>
</ul>
</li>
<li><p>核心部分：由大佬网络和连载在这些完了的路由器组成。这部分是为边缘部分提供服务的(提供连通性和交换)</p>
<ul>
<li>网络中的核心部分要向网络边缘中的大量主机提供连通性。</li>
<li>在网络核心部分的主要设备是路由器。</li>
<li>路由器是实现1分组交换的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。</li>
</ul>
</li>
<li><p>分组交换的主要特点</p>
<ul>
<li>分组交换则采用<strong>存储转发</strong>技术</li>
<li>在发送端，先把较长的报文<strong>划分成较短的、固定长度的数据段。</strong></li>
<li>每一个数据段起那么添加上<strong>首部构成分组</strong></li>
<li>每个分组在互联中<strong>独立的选择传输路径</strong></li>
<li>用<strong>存储转发</strong>方式，最后分组到达<strong>最终目的地</strong></li>
<li>在接收端把收到的数据<strong>恢复为原来的报文</strong></li>
</ul>
</li>
</ol>
<h2 id="1-6-计算机网络的性能"><a href="#1-6-计算机网络的性能" class="headerlink" title="1.6 计算机网络的性能"></a>1.6 计算机网络的性能</h2><p>计算机网络的性能一般是指他的几个重要的性能指标，主要包括：</p>
<ol>
<li><p>速率</p>
<ul>
<li>速率是计算机网络中最重要的一个性能指标，指的是数据的传送速率，他也称为数据率或比特率。</li>
<li>速率的单位是bit/s，或kbit/s、Mbit/s、Gbit/s等。例如4*1010bit/s的数据率就记为40Gbit/s</li>
<li>速率往往是指额定速率或标称速率，非实际运行速率。</li>
</ul>
<ol start="2">
<li><p>带宽</p>
<ul>
<li>带宽本来是指信号具有的频带宽度，其单位是赫(或千赫、兆赫、吉赫等)。</li>
<li>在计算机网络中，带宽用来表示网络中某通道传送数据的能力。表示在单位时间内网络中的某信道所能通过的“最高数据率”。单位bit/s，即“比特每秒”。</li>
</ul>
</li>
</ol>
</li>
<li><p>吞吐量</p>
<ul>
<li>吞吐量表示在单位时间内通过某个网络(或信道、接口)的数据量。</li>
<li>吞吐量更经常的用于对现实世界的网络的一种测量，以便知道实际上到底有多少数据量能通过网络。</li>
<li>吞吐量受网络的带宽或网络的额定速率的限制。</li>
</ul>
</li>
<li><p>时延</p>
<ul>
<li><p>时延是指数据(一个报文或分组，甚至比特)从网络(或链路)的一端传送到另一端所需的时间。</p>
</li>
<li><p>有时也称为延迟或迟延</p>
</li>
<li><p>网络中的时延由以下几个不同的部分组成</p>
<ol>
<li><p>发送时延</p>
<ul>
<li>也称为传输时延。</li>
<li>发送数据时，数据帧从结点进入到传输媒体所需要的时间。</li>
<li>也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间</li>
<li>发送时延 = 数据帧长度(bit)/发送速率(bit/s)</li>
</ul>
</li>
<li><p>传播时延</p>
<ul>
<li>电磁波在信道中需要传播一定的距离而花费的时间</li>
<li>发送时延与传播时延有本质上的不同</li>
<li>信号发送速率和信号在信道上的传播速率是完全不同的概念</li>
<li>传播时延 = 信道长度(米)/信号在信道上的传播速率(米/秒)</li>
</ul>
</li>
<li><p>处理时延</p>
<p>主机或路由器在收到分组时，为处理分组(例如分析首部、提取数据、差错检验或查找路由)所花费的时间。</p>
</li>
<li><p>排队时延</p>
<ul>
<li>分组在路由器输入输出队列中排队等待处理所经历的时延。</li>
<li>排队时延的长短往往取决于网络中当时的通信量。</li>
</ul>
</li>
</ol>
</li>
<li><p>数据在网络中经历的总时延就是发送时延、传播时延、处理时延和排队时延之和。</p>
<p>总时延 = 发送时延+传播时延+处理时延+排队时延</p>
<p>必须指出，在总时延中，究竟是哪一种时延占主导地位，必须具体分析。</p>
</li>
<li><p>假设从结点A向结点B发送数据：在结点A中产生处理时延和排队时延，在发送器产生发送时延(即传输时延)，在链路上产生传播时延</p>
</li>
</ul>
</li>
<li><p>往返时间RTT</p>
<ul>
<li>互联网上的信息不仅仅单方向传输，而是双向交互的。因此，有时很需要知道双向交互一次所需的时间。</li>
<li>往返时间表示从发送方发送数据开始，到发送方收到来自接收方的确认，总共经历的时间。</li>
<li>在互联网中，往返时间还包括各中间结点的处理时延、排队时延以及转发数据时的发送时延</li>
<li>当使用卫星通信时，往返时间RTT相对较长，是很重要的一个性能指标。</li>
</ul>
</li>
<li><p>利用率</p>
<ul>
<li><p>分为信道利用率和网络利用率。</p>
</li>
<li><p>信道利用率指出某信道有百分之几的时间是被利用的(有数据通过)。完全空闲的信道的利用率是零。</p>
</li>
<li><p>网络利用率则是全网络的信道利用率的加权平均值。</p>
</li>
<li><p>信道利用率并非越高越好。当某信道的利用率增大时，该信道引起的时延也就迅速增加。</p>
<p><em>时延与网络利用率的关系：当信道的利用率增大时，该信道引起的时延迅速增加。</em></p>
<p>​      </p>
</li>
</ul>
</li>
</ol>
<h2 id="1-7-计算机网络的体系结构"><a href="#1-7-计算机网络的体系结构" class="headerlink" title="1.7 计算机网络的体系结构"></a>1.7 计算机网络的体系结构</h2><ol>
<li><p>计算机网络体系结构的形成</p>
<ul>
<li>计算机网络是一个非常复杂的系统</li>
<li>互相通信的两个计算机系统必须高度协调工作才行，而这种”协调”是相当复杂的</li>
<li>“分层”可将庞大而复杂的问题，转化为若干较小的局部问题，而这些较小的局部问题就比较易于研究和处理。</li>
<li>计算机网络的各层及其协议的集合就是网络的体系结构</li>
</ul>
</li>
<li><p>协议与划分层次</p>
<ul>
<li><p>计算机网络中的数据交换必须遵守事先约定好的规则。</p>
</li>
<li><p>这些规则明确规定了所交换的数据的格式以及有关的同步问题(同步含有时序的意思)。</p>
</li>
<li><p>网络协议，简称为协议，是为进行网络中的数据交换而建立的规则、标准或约定。</p>
</li>
<li><p>网络协议的三个组成要素</p>
<ol>
<li><p>语法：数据与控制信息的结构或格式</p>
</li>
<li><p>语义：需要发出何种控制信息，完成何种动作以及做出何种响应。</p>
</li>
<li><p>同步：事件实现顺序的详细说明。</p>
<p><em>由此可见，网络协议是计算机网络的不可缺少的组成部分。</em></p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>具有五层协议的体系结构</p>
<ul>
<li>OSI的七层协议体系结构的概念清楚，理论也较完整，但它既复杂又不实用。</li>
<li>TCP/IP是四层体系结构：应用层、运输层、网际层和网络接口层</li>
<li>但最下面的网络接口层并没有具体内容</li>
<li><strong>因此往往采取折中的办法，即OSI和TCP/IP的优点，采用一种只有五层协议的体系。</strong></li>
</ul>
<p><img src="/images/计算机网络体系结构.png" alt="计算机网络体系结构"></p>
<p><img src="/images/主机1向主机2发送数据.png" alt="主机1向主机2发送数据"></p>
</li>
</ol>
<hr>
<h1 id="第二章-物理层"><a href="#第二章-物理层" class="headerlink" title="第二章 物理层"></a>第二章 物理层</h1><h2 id="2-1-物理层的基本概念"><a href="#2-1-物理层的基本概念" class="headerlink" title="2.1 物理层的基本概念"></a>2.1 物理层的基本概念</h2><ul>
<li>常用术语<ul>
<li>数据——运送消息的实体</li>
<li>信号——数据的电气的或电磁的表现</li>
<li>模拟信号——代表消息的参数的取值是连续的</li>
<li>数字信号——代表消息的参数的取值是离散的</li>
<li>码元——在使用时间域(或简称为时域)的波形表示数字信号时，代表不同离散数值的基本波形</li>
</ul>
</li>
</ul>
<h2 id="2-2-数据通信的基础知识"><a href="#2-2-数据通信的基础知识" class="headerlink" title="2.2 数据通信的基础知识"></a>2.2 数据通信的基础知识</h2><ol>
<li><p>有关信道的几个基本概念</p>
<ul>
<li>信道——一般来表示向某一个方向传送信息的媒体</li>
<li>单向通信(单工通信)——只能有一个方向的通信而没有反方向的交互</li>
<li>双向交替通信(半双工通信)——通信的双方都可以发送信息，当不能双方同时发送(当然也就不能同时接收)。</li>
<li>双向同时通信(全双工通信)——通信的双方可以同时发送和接收信息。</li>
</ul>
</li>
<li><p>有关信道的几个基本概念</p>
<ul>
<li><p>基带信号(即基本频带信号)——来自信源的信号。像计算机输出的代表各种文字或图像文件的数据信号都属于基带信号。</p>
</li>
<li><p>基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。因此必须对基带信号进行<strong>调制</strong>。</p>
</li>
<li><p>调制分为两大类：</p>
<ul>
<li>基带调制：仅对基带信号的波形进行变换，使它能够与信道特征性相适应。变换后的信号仍然是基带信号。把这种过程称为编码。</li>
<li>带通调制：使用<strong>载波</strong>进行调制，把基带信号的频率范围搬移到较高的频段，并<strong>转换为模拟信号</strong>，这样就能够更好的在模拟信道中传输(即仅在一段频率范围内能够通过信道)。</li>
<li>带通信号：经过载波调制后的信号。</li>
</ul>
</li>
<li><p>基本的带通调制方法</p>
<ul>
<li><p>最基本的二元制调制方法有以下几种：</p>
<ol>
<li>调幅(AM)：载波的振幅随基带数字信号而变化。</li>
<li>调频(FM)：载波的频率随基带数字信号而变化。</li>
<li>调相(PM)：载波的初始相位随基带数字信号而变化。</li>
</ol>
<p><img src="\images\最基本的三种调制方式.png" alt="最基本的三种调制方式"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>信道的极限容量</p>
<ul>
<li><p>任何实际的信道都不是理想的，在传输信号时会产生各种失真以及带来多种干扰。</p>
</li>
<li><p>码元传输的速率越高，或信号传输的距离越远，或传输媒体质量越差，在信道的输出端的波形的失真就越严重。</p>
</li>
<li><p>从概念上讲，限制码元在信道上的传输速率的因素有以下两个：</p>
<ul>
<li>信道能够通过的频率范围</li>
<li>信噪比</li>
</ul>
</li>
<li><p>信噪比</p>
<ul>
<li>噪声存在于所有的电子设备和通信信道中</li>
<li>噪声是随机产生的，它的瞬时值有时会很大。因此噪声会使接收端对码元的判决产生错误。</li>
<li>但噪声的影响是相对的。如果信号相对较强，那么噪声的影响就相对较小。</li>
<li>信噪比就是信号的平均功率和噪声的平均功率之比。常记为S/N，并用分贝(dB)作为度量单位。即：信噪比(dB) = 10log10(S/N) （dB）</li>
<li>例如，当S/N = 10时，信噪比为10dB,而当S/N =1000时，信噪比为30dB。</li>
</ul>
</li>
<li><p>香农公式</p>
<ul>
<li><p>奈奎斯特于1924年推导出在理想低通信道下的<strong>最高码元传输速率(波特率)</strong>的公式，公式表示为理想低通信道下的最高码元传输速率=2W Baud</p>
</li>
<li><p>1984年，香农用信息论的理论推导出了带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率(香农公式)</p>
</li>
<li><p>信道的极限信息传输速率C可表达为：</p>
<p>C = Wlog2(1+S/N)  (bit/s)</p>
<p>其中：W为信道的带宽(以Hz为单位)；</p>
<p>S为信道内所传信号的平均功率；</p>
<p>N为信道内部的高斯噪声功率。</p>
</li>
</ul>
</li>
<li><p>香农公式表明</p>
<ul>
<li>信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。</li>
<li>只要信息传输速率低于信道的极限信息传输速率，就一定可以找到某种办法来实现无差错的传输。</li>
<li>若信道带宽W或信噪比S/N没有上限(当然实际信道不可能是这样的)，则信道的极限信息传输速率C也就没有上限。</li>
<li>实际信道上能够达到的信息传输速率要比香农的极限传输速率低不少。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="2-3-物理层下面的传输媒体"><a href="#2-3-物理层下面的传输媒体" class="headerlink" title="2.3 物理层下面的传输媒体"></a>2.3 物理层下面的传输媒体</h2><ol>
<li><p>引导型传输媒体</p>
<ul>
<li>双绞线</li>
<li>同轴电缆</li>
<li>光缆</li>
</ul>
</li>
<li><p>非引导型传输媒体</p>
<ul>
<li>自由空间</li>
</ul>
</li>
</ol>
<h2 id="2-4-信道复用技术"><a href="#2-4-信道复用技术" class="headerlink" title="2.4 信道复用技术"></a>2.4 信道复用技术</h2><ol>
<li><p>频分复用、时分复用和统计时分复用</p>
<ul>
<li><p>频分复用(FDM)</p>
<ul>
<li>将整个宽带分为多份，用户在分配到一定的频带后，在通信过程中自始至终都占用这个频带。</li>
<li>频分复用的所有用户在同样的时间占用不同的带宽资源(请注意，这里的“带宽”是频率带宽而不是数据的发送速率)。</li>
</ul>
</li>
<li><p>时分复用(TDM)</p>
<ul>
<li>时分复用则是将时间划分为一段段等长的时分复用帧(TDM帧)。每一个时分复用的用户在每一个TDM帧中占用固定序号的时隙。</li>
<li>每一个用户所占用的时隙是周期性的出现(其周期就是TDM帧的长度)。、</li>
<li>TDM信号也称为等时信号。</li>
<li>时分复用的所有用户是在不同的时间占用同样的频带宽度。</li>
</ul>
</li>
<li><p>波分复用(WDM)</p>
<ul>
<li>波分复用就是光的频分复用。使用一根光纤来同时传输多个光载波信号.</li>
</ul>
</li>
<li><p>码分复用(CDM)</p>
<ul>
<li><p>常用的名词是码分多址CDMA</p>
</li>
<li><p>各用户使用经过特殊挑选的不同码型，因此彼此不会造成干扰。</p>
</li>
<li><p>这种系统发送的信号有很强的抗干扰能力，其频谱类似白噪声，不易被敌人发现。</p>
<ol>
<li><p>码片序列</p>
<ul>
<li><p>每一个比特时间划分为m个短的间隔，称为码片。</p>
</li>
<li><p>每一个站被指派一个唯一的m bit码片序列。</p>
<p>如发送比特1，则发送自己的 m bit 码片序列。</p>
<p>如发送比特0，则发送该码片序列的二进制反码。</p>
</li>
<li><p>例如，S站的8bit码片序列是00011011</p>
<p>发送比特1时，就发送序列00011011</p>
<p>发送比特0时，就发送序列11100100</p>
</li>
<li><p>S站的码片序列：(-1 -1 -1 +1 +1 -1 +1 +1)</p>
</li>
</ul>
</li>
<li><p>CDMA的重要特点</p>
<ul>
<li>每个站分配的码片序列不仅必须各不相同，并且还必须相互正交。</li>
<li>在实用的系统中是使用伪随机码序列</li>
</ul>
</li>
<li><p>码片序列的正交关系</p>
<ul>
<li><p>令向量S表示站S的码片向量，令T表示其他任何站的码片向量。</p>
</li>
<li><p>两个不同站的码片序列正交，就是向量S和T的规格化内积等于0：</p>
<p><img src="/images/规格化内积.png" alt="规格化内积"></p>
</li>
</ul>
</li>
<li><p>正交关系的另一个重要特性</p>
<ul>
<li>任何一个码片向量和该码片向量自己的规格化内积都是1。</li>
<li><img src="/images/公式.png" alt="公式"></li>
<li>一个码片向量和该码片反码的向量的规格化内积值是-1.</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>​      </p>
<h1 id="第三章-数据链路层"><a href="#第三章-数据链路层" class="headerlink" title="第三章 数据链路层"></a>第三章 数据链路层</h1><h2 id="3-1-使用点对点信道的数据链路层"><a href="#3-1-使用点对点信道的数据链路层" class="headerlink" title="3.1 使用点对点信道的数据链路层"></a>3.1 使用点对点信道的数据链路层</h2><ul>
<li>数据链路层协议有许多种，但有三个基本问题则是共同的。三个基本问题是：<ol>
<li>封装成帧<ul>
<li>封装成帧就是在一段数据的前后分别添加首部和尾部，然后就构成了一个帧。确定帧的界限。</li>
<li>首部和尾部的一个重要作用就是进行帧定界。</li>
<li><img src="/images/用帧首部和帧尾部封装成帧.png" alt="用帧首部和帧尾部封装成帧"></li>
<li>当数据是由可打印的ASCLL码组成的文本文件时，帧定界可以使用特殊的帧定界符。</li>
<li>控制字符SOH放在一帧的最前面，表示帧的首部开始。另一给控制字符EOT表示帧的结束。</li>
</ul>
</li>
<li>透明传输<ul>
<li>如果数据中的某个字节的二进制代码恰好和SOH或EOT一样，数据链路层就会错误的”找到帧的边界”。</li>
<li>解决方法：字节填充或字符填充</li>
<li>发送端的数据链路层在数据中出现控制字符“SOH”或“EOT”的前面插入一个转义字符“ESC”(其十六进制编码是1B)</li>
<li>接收端的数据链路层在将数据送往网络层之前删除插入的转义字符。</li>
<li>如果转义字符也出现在数据当中，那么应在转义字符前面插入一组转义字符ESC。当接收端收到联系的两个转义字符时，就删除其中前面的一个。</li>
</ul>
</li>
<li>差错控制<ul>
<li>在传输过程中可能会产生比特差错：1可能会变成0而0也可能变成1。</li>
<li>在一段时间内，传输错误的比特占所传输比特总数的比率称为误码率BER。</li>
<li>误码率与信噪比有很大的关系。</li>
<li>为了保证数据传输的可靠性，在计算机网络传输数据时，必须采用各种查错检测措施。</li>
</ul>
</li>
<li>循环冗余检验的原理<ul>
<li>在数据链路层传送的帧中，广泛使用了循环冗余检验CRC的检错技术。</li>
</ul>
</li>
<li>帧检验序列FCS<ul>
<li>在数据后面添加上的冗余码称为帧检验序列FCS。</li>
<li>循环冗余检验CRC和帧检验序列FCS并不等同<ul>
<li>CRC是一种常用的检错方法，而FCS是添加在数据后面的冗余码</li>
<li>FCS可以用CRC这种方法得出，但CRC并非用来获得FCS的唯一方法</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="3-3-使用广播信道的数据链路层"><a href="#3-3-使用广播信道的数据链路层" class="headerlink" title="3.3 使用广播信道的数据链路层"></a>3.3 使用广播信道的数据链路层</h2><ol>
<li><p>局域网的数据链路层</p>
<ul>
<li>媒体共享技术<ul>
<li>静态划分信道：频分复用、时分复用、波分复用、码分复用</li>
<li>动态媒体接入控制(多点接入)：随机接入、受控接入，如多点线路探询，或轮询</li>
</ul>
</li>
<li>适配器的作用<ul>
<li>网络接口板又称为通信适配器或网络接口卡NIC或”网卡“。</li>
<li>适配器的重要功能<ol>
<li>进行串行/并行转换</li>
<li>对数据进行缓存</li>
<li>在计算机的操作系统安装设备驱动程序</li>
<li>实现以太网协议</li>
</ol>
</li>
<li><img src="/images/计算机通过适配器和居于网进行通信.png" alt="计算机通过适配器和居于网进行通信"></li>
</ul>
</li>
</ul>
</li>
<li><p>CSMA/CD协议</p>
<ul>
<li><p>最初的以太网是将许多计算机都连接到一根总线上。当初认为这样的连接方法既简单有可靠，因为总线上没有与源器件。</p>
</li>
<li><p><img src="/images/CSMA协议.png" alt="CSMA协议"></p>
</li>
<li><p>以太网采用广播方式发送</p>
<ul>
<li>总线上的每一个工作的计算机都能检测到B发送的数据信号。</li>
<li>由于只有计算机D的地址与数据帧首部写入的地址一致，因此只有D才接收这个数据帧。</li>
<li>其他所有计算机(A,C和E)都检测到不上发送给他们的数据帧，因此就丢弃这个数据帧而不能够收下来。</li>
<li>在具有广播特性的总线上实现了一对一的通信。</li>
</ul>
</li>
<li><p>以太网采取了两种重要的措施</p>
<p>为了通信的简便，以太网采取了两种重要的措施：</p>
<ol>
<li>采用较为灵活的无连接的工作方式<ul>
<li>不必先建立连接就可以直接发送数据</li>
<li>对发送的数据帧不进行编号，也不要求对方发回确认。</li>
<li>这样做的理由是局域网信道的质量很好，因此信道质量产生差错的概率是很小的</li>
</ul>
</li>
<li>以太网提供的服务<ul>
<li>以太网提供的服务是不可靠的交付，即尽最大努力的交付。</li>
<li>当目的站受到有差错的数据帧时就丢弃此帧，其他上面也不做。差错的纠正由高层来决定。</li>
<li>如果高层发现丢失了一些数据而进行重传，但以太网并不知道这是一个重传的帧，而是当作一个新的数据帧来发送。</li>
</ul>
</li>
<li>CSMA/CD协议<ul>
<li>CSMA/CD含义：载波监听多点接入/碰撞检测</li>
<li>”多点接入“表示许多计算机以多点接入的方式连接在一根总线上。</li>
<li>”载波监听“是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据，如果有，则暂时不要发送数据，以免发生碰撞。</li>
<li>总线上并没有什么”载波“。因此，”载波监听“就是用电子技术检测总线上有没有其他计算机发送的数据信号。</li>
</ul>
</li>
<li>碰撞检测<ul>
<li>”碰撞检测“就是计算机边发送数据边检测信道上的信号电压大小。</li>
<li>当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大(互相叠加)。</li>
<li>当一个站检测到的信号电压摆动值超过一端的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞。</li>
<li>所谓”碰撞“就是发生了冲突。因此”碰撞检测“也称为”冲突检测“。</li>
</ul>
</li>
<li>检测到碰撞后<ul>
<li>在发生碰撞时，总线上传输的信号产生了严重的失真，无法从中恢复出有用的信息来。</li>
<li>每一个正在发送数据的站，一旦发现总线上出现了碰撞，就要<strong>立即停止发送</strong>，免得继续浪费网络资源，然后<strong>等待一段随机</strong>时间后再次发送。</li>
</ul>
</li>
<li>为什么要进行碰撞检测？<ul>
<li>由于电磁波在总线上的传播速率是有限的，当某个站监听到总线是空闲时，也可能总线并非真正是空闲的。</li>
<li>A向B发出的信息，要经过一定的时间后才能传送到B。</li>
<li>B若在A发送的信息到达B前发送直接的帧(因为这时B的子载波监听检测不到A所发送的信息)，则必然要在某个时间和A发送的帧发生碰撞。</li>
<li>碰撞的结果是两个帧变得无用。</li>
<li><strong>所以需要在发送期间进行碰撞检测，以检测冲突。</strong></li>
</ul>
</li>
<li>信号传播时延对载波监听的影响<ul>
<li></li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li><p>使用集线器的星形拓扑</p>
</li>
<li><p>以太网的信道利用率</p>
</li>
<li><p>以太网的MAC层</p>
</li>
</ol>
<h2 id="3-4-扩展的以太网"><a href="#3-4-扩展的以太网" class="headerlink" title="3.4 扩展的以太网"></a>3.4 扩展的以太网</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zehwakaka.github.io/2020/08/22/hexo常用命令/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alice's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/22/hexo常用命令/" itemprop="url">hexo常用命令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-22T15:14:41+08:00">
                2020-08-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><pre><code>hexo new &quot;postName&quot; #新建文章
hexo generate #生成静态页面至public目录
hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server）
hexo deploy #部署到GitHub
hexo help  # 查看帮助
hexo version  #查看Hexo的版本
</code></pre><h2 id="缩写："><a href="#缩写：" class="headerlink" title="缩写："></a>缩写：</h2><pre><code>hexo n == hexo new
hexo g == hexo generate
hexo s == hexo server
hexo d == hexo deploy
</code></pre><h2 id="组合命令："><a href="#组合命令：" class="headerlink" title="组合命令："></a>组合命令：</h2><pre><code>hexo s -g #生成并本地预览
hexo d -g #生成并上传
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zehwakaka.github.io/2020/08/22/数据库概论复习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alice's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/22/数据库概论复习/" itemprop="url">数据库概论复习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-22T15:10:42+08:00">
                2020-08-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>版权所有</em></p>
<hr>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h2><h3 id="数据库系统概述"><a href="#数据库系统概述" class="headerlink" title="数据库系统概述"></a>数据库系统概述</h3><ul>
<li>数据库四个基本概念：数据库系统(DBS)包括 数据库管理系统(DBMA)，数据库管理员(DBA)，数据库(DB)。</li>
<li>数据管理技术的产生和发展：数据管理技术经历了人工管理、文件管理、数据库系统三个阶段。     </li>
<li>数据库系统的特点</li>
</ul>
<ol>
<li>数据结构化<ol start="2">
<li>共享性高、冗余度低且易扩充</li>
<li>数据独立性高：数据独立性、物理独立性、逻辑独立性</li>
<li>数据由数据库管理系统统一管理和控制</li>
</ol>
</li>
</ol>
<h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><ul>
<li><p>据模型也是一种模型，它是对现实世界数据特征的抽象。数据模型是数据库系统的核心和基础。</p>
</li>
<li><p>两类数据模型：第一类是概念模型，第二类是逻辑模型和物理模型。 首先将现实世界抽象为信息世界，然后将信息世界转换为机器世界。</p>
</li>
<li><p>概念模型：概念模型最常用的方法是实体-联系方法，E-R方法也称为E-R模型</p>
<ol>
<li>实体：客观存在并可互相区别的事物称为实体。</li>
<li>属性：实体所具有的某一特性称为属性。</li>
<li>码：唯一标识实体的属性集称为码。</li>
<li>实体型：用实体名及其属性名集合来抽象和刻画同类实体，称为实体型。</li>
<li>实体集：同一类型实体的集合称为实体集</li>
<li>联系：实体之间的联系通常是指不同实体集之间的联系。实体之间的联系有一对一、一对多和多对多等多种类型。<br>数据模型的组成要素</li>
</ol>
</li>
<li><p>数据结构：数据结构描述数据库的组成对象以及对象之间的联系。</p>
</li>
<li><p>数据操作：数据操作是指对数据库中各种对象（型）的实例（值）允许执行的操作的集合，包括操作及有关的操作规则。</p>
</li>
<li><p>数据的完整性约束条件：数据的完整性约束条件是一组完整性规则。</p>
</li>
<li><p>常用的数据模型</p>
<ol>
<li><p>层次模型</p>
</li>
<li><p>网状模型</p>
</li>
<li><p><strong>关系模型</strong></p>
<ol>
<li><p>关系模型的数据结构</p>
<ul>
<li><p>关系：一个关系对应通常说的一张表</p>
</li>
<li><p>元组：表中的一行即为一个元组</p>
</li>
<li><p>属性：表中的一列即为一个属性，给每一个属性起一个名称即属性名</p>
</li>
<li><p>码：也称码键。表中的某个属性组，它可以唯一确定一个元组</p>
</li>
<li><p>域：域是一组具有相同数据类型的值的集合</p>
</li>
<li><p>分量：元组中的一个属性值</p>
<p><em>关系模型要求关系必须是规范的，关系的每一个分量必须是一个不可分的数据项</em></p>
</li>
</ul>
</li>
<li><p>关系模型的数据操纵与完整性约束</p>
<p><em>关系模型中的数据操作是集合操作，操作对象和操作结果都是关系。关系模型把存取路径向用户隐蔽起来</em></p>
</li>
<li><p>关系模型的优缺点</p>
<ul>
<li>关系模型与格式化模型不同，他是建立在严格的数学基础上的。</li>
<li>关系模型的概念单一</li>
<li>关系模型的存取路径对用户透明</li>
</ul>
</li>
</ol>
</li>
<li><p>面向对象数据模型</p>
</li>
<li><p>对象关系数据模型</p>
</li>
<li><p>半结构化数据模型</p>
</li>
</ol>
</li>
</ul>
<h3 id="数据库系统的结构"><a href="#数据库系统的结构" class="headerlink" title="数据库系统的结构"></a>数据库系统的结构</h3><ul>
<li><p>数据库系统模式的概念：在数据模型中有“型”和“值”的概念。型是指对某一类数据的结构和属性的说明，值是型的一个具体赋值。</p>
<p><em>模式是相对稳定的，而实例是相对变动的。</em></p>
</li>
<li><p><strong>数据库系统的三级模式结构图：</strong></p>
</li>
<li><p><img src="/images/数据库系统的三级模式结构.jpg" alt="数据库系统的三级模式结构" style="zoom:25%;transform:rotate(-90deg);">    </p>
</li>
<li><p><strong>三级模式</strong></p>
<ol>
<li><p>模式：模式也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。</p>
</li>
<li><p>外模式：外模式也称子模式或用户模式，它是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。</p>
</li>
<li><p>内模式：内模式也称存储模式，一个数据库只有一个内模式。它是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式。</p>
</li>
</ol>
</li>
<li><p><strong>数据库的二级映像功能与数据独立性</strong></p>
<ol>
<li><p>外模式/模式映像：当模式改变时(例如增加新的关系、新的属性、改变属性的数据类型等)，由数据库管理员对各个外模式/模式的映像作相应改变，可以使外模式保持不变。应用程序是依据数据的外模式编写的，从而应用程序不必修改，<strong>保证了数据与程序的逻辑独立性，简称数据的逻辑独立性。</strong></p>
</li>
<li><p>模式/内模式映像：当数据库的存储结构改变时(例如选用了另一种存储结构)，由数据库管理员对模式/内模式映像作相应改变，可以使模式保持不变，从而应用程序也不必改变。<strong>保证了数据与程序的物理独立性，简称数据的物理独立性。</strong></p>
<p><em>数据与程序之间的独立性使得数据的定义和描述可以从应用程序中分离出去。另外，由于数据的存取由数据库管理系统管理，从而简化了应用程序的编制，大大减少了应用程序的维护和修改。</em></p>
</li>
</ol>
</li>
<li><p>据库系统的组成</p>
<ul>
<li><p>包括硬件平台及数据库、软件、人员。</p>
</li>
<li><p>数据库管理员(DBA)职责：</p>
<ul>
<li>决定数据库中的信息内容和结构</li>
<li>决定数据库的存储结构和存储策略</li>
<li>定义数据的安全性要求和完整性约束条件</li>
<li>监控数据库的使用和运行</li>
<li>数据库的改进和重组、重构</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="第二章-关系数据库"><a href="#第二章-关系数据库" class="headerlink" title="第二章 关系数据库"></a>第二章 关系数据库</h2><h3 id="关系数据结构及形式化定义"><a href="#关系数据结构及形式化定义" class="headerlink" title="关系数据结构及形式化定义"></a>关系数据结构及形式化定义</h3><ul>
<li><p>关系</p>
<ol>
<li><p>域：域是一组具有相同数据类型的值的集合。</p>
</li>
<li><p><strong>笛卡尔积</strong>：笛卡尔积定义，给定一组域D1,D2,…,Dn，允许其中某些域是相同的，D1,D2,…,Dn的笛卡尔积为</p>
<p>​                                                        <em>D1\</em>D2*…*Dn = {(d1,d2,…,dn)|di属于Di,i=1,2,…,n}*<br>​                           其中，每一个元素(d1,d2,…,dn)叫作一个n元组，或简称元组。元素中的每一个值di叫作一个分量。<br>​                           一个域允许的不同取值个数称为这个域的基数。</p>
</li>
<li><p><strong>关系：</strong>定义，D1*D2*…*Dn的子集叫做在域D1,D2,…,Dn上的关系，表示为R(D1,D2,…,Dn)这里R表示关系的名字,n是关系的<strong>目或度</strong>。当n = 1时，称该关系为一元关系。当n = 2时，称该关系为二元关系。</p>
<ul>
<li><p>某一属性组的值能唯一的标识一个元组，而其子集不能，则称该属性组为<strong>候选码</strong>。若一个关系有多个候选码，则选定其中一个为<strong>主码</strong>。候选码的诸属性称为<strong>主属性</strong>。不包含在任何候选码中的属性称为<strong>非主属性或非码属性</strong>。在最简单的情况下，候选码只包含一个属性。在最极端的情况下，关系模式的所有属性是这个关系模式的候选码，称为<strong>全码</strong>。</p>
</li>
<li><p>关系可以有三种类型：基本关系(通常又称为基本表或基表)、查询表和视图表。</p>
</li>
<li><p>关系的性质：</p>
<ol>
<li><p>列是同质的，即每一列中的分量是同一类型的数据，来自同一个域。</p>
</li>
<li><p>不同的列可出自同一个域，称其中的每一列为一个属性，不同的属性要给予不同的属性名。</p>
</li>
<li><p>列的顺序无所谓，即列的次序可以任意交换。</p>
</li>
<li><p>任意两个元组的候选码不能取相同的值。</p>
</li>
<li><p>行的顺序无所谓，即行的次序可以任意交换。</p>
</li>
<li><p>分量必须取原子值，即每一个分量都必须是不可分的数据项</p>
<p><strong>这些规范条件中最基本的一条就是，关系的每一个分量必须是一个不可分的数据项。规范化的关系简称为范式(NF)。</strong></p>
</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>关系模式</p>
<ul>
<li>关系的描述称为关系模式。它可以形式化的表示为R(U,D,DOM,F)。其中R为关系名，U为组成改关系的属性名集合，D为U中属性所来自的域，DOM为属性向域的映像集合，F为属性间数据的依赖关系集合。</li>
</ul>
</li>
<li><p>关系数据库</p>
<ul>
<li>关系数据库也有型和值之分。关系数据库的型也称为关系数据库模式，是对关系数据库的描述。关系数据库的值是这些关系模式在某一时刻对应的关系的集合，通常就称为关系数据库。</li>
</ul>
</li>
</ul>
<h3 id="关系操作"><a href="#关系操作" class="headerlink" title="关系操作"></a>关系操作</h3><ul>
<li><p>基本的关系操作：关系模型中常用的关系操作包括<strong>查询操作</strong>和<strong>插入、删除、修改操作</strong>两大部分。</p>
<ul>
<li><p>关系的查询表达能力很强，是关系操作中最主要的部分。查询操作又可以分为旋转、投影、连接、除、并、差、交、笛卡尔积等。其中<strong>选择、投影、并、差、笛卡尔积是5种基本操作</strong>。</p>
</li>
<li><p>关系操作的特点是集合操作方式，即操作的对象和结果都是集合。这种操作方式也称为一次一集合的方式。相应的非关系数据模型的数据操作方式则为一次一记录的方式。</p>
</li>
</ul>
</li>
<li><p>关系数据语言的分类</p>
<ul>
<li><p>早期的关系操作能力通常用代数方式或逻辑方式来表示，分别称为<strong>关系代数和关系演算</strong>。关系代数用对关系的运算来表达查询要求，关系演算则用谓词来表达查询要求。关系演算又可按谓词变元的基本对象是元组变量还是域变量分为<strong>元组关系演算和域关系演算</strong>。</p>
</li>
<li><p>还有一种介于关系代数和关系演算之间的<strong>结构化查询语言(SQL)</strong>。SQL是<strong>集查询、数据定义语言、数据操纵语言和数据控制语言于一体的关系数据语言。</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="关系的完整性"><a href="#关系的完整性" class="headerlink" title="关系的完整性"></a>关系的完整性</h3><ul>
<li><p>关系模型中有三类完整性约束：<strong>实体完整性、参照完整性和用户定义的完整性。</strong>其中实体完整性和参照完整性是关系模型必须满足的完整性约束条件，被称作<strong>关系的两个不变性。</strong></p>
<ol>
<li><p>实体完整性：实体完整性规则，若属性(指一个或一组属性)A是基本关系R的主属性，则A不能取空值。所谓空值就是“不知道”或“不存在”或“无意义”的值。</p>
<p><em>对实体完整性规则说明：</em></p>
<ul>
<li><p>实体完整性规则是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集。</p>
</li>
<li><p>现实世界中的实体是可区分的，即它们具有某种唯一性标识。例如每个学生都是独立的个体，是不一样的。</p>
</li>
<li><p>相应的，关系模型中以主码作为唯一性标识。</p>
</li>
<li><p>主码中的属性不能取空值。</p>
</li>
</ul>
</li>
<li><p>参照完整性：<strong>设F是基本关系R的一个或一组属性，但不是关系R的码，Ks是基本关系S的码。如果F与Ks相对应，则称F是R的外码，并称基本关系R为参照关系，基本关系S为被参照关系或目标关系。</strong></p>
<p><img src="/images/参照关系.jpg" alt="参照关系与被参照关系"></p>
<ul>
<li><p>参照完整性规则：若属性(或属性组)F是基本关系R的外码，它与基本关系S的主码Ks相对应(基本关系R和S不一定是不同的关系)，则对于R中每个元组在F上的值必须：</p>
<ol>
<li><p>或者取空值(F的每个属性值均为空值)</p>
</li>
<li><p>或者等于S中某个元组的主码值。</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>用户定义的完整性</p>
<p><em>用户定义的完整性就是针对某一具体关系数据库的约束条件，它反映某一具体应用所涉及的数据必须满足的语义要求。</em></p>
</li>
</ol>
</li>
</ul>
<h3 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h3><p>  关系代数是一种抽象的查询语言，它用对关系的运算来表达查询。</p>
<p>  任何一种运算都是将一定的运算符作用于一定的运算对象上，得到预期的运算结果。所以运算对象、运算符、运算结果是运算的三大要素。</p>
<p>  关系代数用到的运算符包括两类：集合运算符和专门的关系运算符</p>
<p>  关系代数的运算按运算符的不同可分为传统的集合运算和专门的关系运算两类。</p>
<ul>
<li><p>传统的集合运算</p>
<p><strong>传统的集合运算是二目运算，包括并、差、交、笛卡尔积四种运算</strong></p>
<p>定义如下：</p>
<ol>
<li><p>并：R∪S ={t|t属于R V t属于S}    其结果仍为n目关系，由属于R或属于S的元组组成。</p>
</li>
<li><p>差：R-S = {t|t属于R ∧ t不属于S}  其即结果关系仍为n目关系，由属于R而不属于S的所有元组组成。</p>
</li>
<li><p>交：R∩S = {t|t属于R ∧ t属于S}    其结果关系仍为n目关系，由既属于R又属于S的元组组成。关系的交可以用差来表示，即</p>
<p>R∩S = R - (R - S)</p>
</li>
<li><p>笛卡尔积：R*S = {tr 连ts|tr属于R ∧ ts属于S}</p>
<p><img src="/images/传统集合运算举例.jpg" alt="传统集合运算举例"></p>
</li>
</ol>
</li>
<li><p>专门的关系运算</p>
<p><strong>专门的关系运算包括选择、投影、连接、除运算</strong></p>
<p> 记号：</p>
<ol>
<li><p>设关系模式为R(A1,A2,…,An)，它的一个关系设为R。t属于R表示t是R的一个元组。t[Ai]则表示元组t中相应于属性Ai的一个分量。</p>
</li>
<li><p>若A = {Ai1,Ai2,…,Aik}，其中Ai1，Ai2，…，Aik是A1，A2，…，An中的一部分，则A称为属性列或属性组。t[A] = (t[Ai1],t[Ai2],…,t[Aik])表示元组t在属性列A上诸分量的集合，A反则表示{A1,A2,…,An}中去掉{Ai1,Ai2,…,Aik}后剩余的属性组。</p>
</li>
<li><p>R为n目关系，S为m目关系。tr属于R，ts属于S，tr连接ts称为元组的连接或元组的串接。他是一个n+m列的元组前n个分量为R中的一个n元组，后m个分量为S中的一个m元组。</p>
</li>
<li><p>给定一个关系R(X,Z),X和Z为属性组。当t[X] = x时，x在R<strong>象集</strong>定义为</p>
<p>​    Zx = {t[Z]|t属于R，t[X] = x}</p>
<p>它表示R中属性组X上值为x的诸元组在Z上分量的集合。</p>
</li>
</ol>
<ul>
<li><p>选择：选择又称为限制。它是在关系R中选择满足给定条件的诸元组，记作   的塔F(R) = {t|t属于R ∧ F(t)= ‘真’}</p>
</li>
<li><p>投影：关系R上的投影是从R中选择出若干属性列组成新的关系。记作   pi A(R) = {t[A]|t属于R} 其中A为R中的属性列。投影是从列的角度进行的运算。</p>
</li>
<li><p>连接：连接也称为 θ连接。他是从两个关系的笛卡尔积中选取属性间满足一定条件的元组。记作：</p>
<p> <img src="/images/连接.jpg" alt="连接"> </p>
<ul>
<li><p>连接运算中有两种最为重要也最为常用的连接，一种是等值连接，另一种是自然连接。θ为“=”的连接运算称为<strong>等值连接</strong>是从关系R与S的广义笛卡尔积中选取A、B属性值相等的那些元组。<strong>自然连接</strong>是一种特殊的等值连接，它要求两个关系中进行比较的分量必须是同名的属性组，并且在结果中把重复的属性列去掉。即若R和S中具有相同的属性组B,U为R和S的全体属性集合。一般的连接操作是从行的角度进行运算，但自然连接还需要取消重复列，所以是<strong>同时从行和列的角度进行运算</strong>。</p>
</li>
<li><p>两个关系R和S在做自然连接时，选择两个关系在公共属性上值相等的元组构成新的关系。此时，关系R中某些元组有可能在S中不存在公共属性上值相等的元组，从而造成R中这些元组在操作时被舍弃，同样，S中某些元组也可能被舍弃。<strong>这些被舍弃的元组称为悬浮元组</strong>。</p>
</li>
<li><p>如果把悬浮元组也保存在结果关系中，而在其他属性上填空值(NULL)，那么这种连接就叫做外连接，记作R =&gt;&lt;= S;如果只保留左边关系R中的悬浮元组就叫做左外连接R=&gt;&lt;S;如果只保留右边关系S中的悬浮元组就叫做右外连接，记作R&gt;&lt;=S</p>
</li>
</ul>
</li>
<li><p>除运算：设关系R除以关系S的结果为关系T，则<strong>T包含所有在R但不在S中的属性及其值，且T的元组与S的元组的所有组合都在R中。</strong></p>
<ul>
<li>下面用象集来定义除法：给定关系R(X,Y)和S(Y,Z)，其中X,Y,Z为属性组。R中的Y与S中的Y可以有不同的属性名，但必须出自相同的域集。</li>
<li>R与S的除运算得到一个新的关系P(X)，P是R中满足下列条件的元组在X属性列上的投影：元组在X上分量值x的象集Yx包含S在Y上投影的集合。记作：R/S = {Tr[X]|tr属于R ∧ piY(S)包含于Yx} 其中Yx为x在R中的象集，x = tr[X]。除操作是同时从行和列角度进行运算。</li>
<li>R/S -&gt;投影-&gt;象集-&gt;包含</li>
</ul>
</li>
</ul>
</li>
<li><p>其中并，差，笛卡尔积，选择和投影这五种运算为基本的运算。其他三种运算，即交，连接和除，均可以用这5种基本运算来表达。引进他们并不增加语言的能力，但可以简化表达</p>
</li>
<li><p>关系代数中，这些运算经有限次复合后形成的表达式称为关系代数表达式。</p>
</li>
</ul>
<hr>
<h2 id="第三章-关系数据库标准语言SQL"><a href="#第三章-关系数据库标准语言SQL" class="headerlink" title="第三章 关系数据库标准语言SQL"></a>第三章 关系数据库标准语言SQL</h2><h3 id="SQL-概述"><a href="#SQL-概述" class="headerlink" title="SQL 概述"></a>SQL 概述</h3><ul>
<li><p>SQL 的产生与发展</p>
<p>目前，没有一个数据库系统能够支持SQL标准的所有概念和特性。大部分数据库系统能支持SQL/92标准中的大部分功能以及SQL99、SQL2003中的部分新概念。同时，许多软件厂商对SQL基本命令集还进行了不同程度的扩展和修改，又可以支持标准以外的一些功能特性。</p>
</li>
<li><p>SQL的特点</p>
<ol>
<li><p>综合统一</p>
</li>
<li><p>高度非过程化</p>
<p>只要提出“做什么”，而无须指明“怎么做”，因此无须了解存取路径。存取路径的选择以及SQL的操作过程由系统自动完成。</p>
</li>
<li><p>面向集合的操作方式</p>
</li>
<li>以同一种语法结构提供多种使用方式</li>
<li>语言简洁，易学易用 </li>
</ol>
</li>
</ul>
<h3 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h3><p><em>一个关系数据库管理系统的实例中可以建立多个数据库，一个数据库中可以建立多个模式，一个模式下通常包括多个表、视图和索引等数据库对象。</em></p>
<p><img src="/images/数据库对象命名机制的层次结构.jpg" alt="数据库对象命名机制的层次结构"></p>
<ul>
<li><p>模式的定义与删除</p>
<ul>
<li><p>定义模式：在SQL中，模式定义语句如下：create schema &lt;模式名&gt; authorization &lt;用户名&gt; </p>
<p>​                                                     <em>如果没有指定&lt;模式名&gt;，那么&lt;模式名&gt;隐含为&lt;用户名&gt;</em></p>
<p><em>要创建模式，调用该命令的用户必须拥有数据库管理员权限，或者获得了数据库管理员授予的create schema 的权限</em></p>
</li>
<li><p>目前，create chema 中可以接受 create table，create view和grant 子句。也就是说用户可以在创建模式的同时在这个模式定义中进一步创建基本表、视图。定义授权。即：create schema &lt;模式名&gt; authorization &lt;用户名&gt; [&lt;表定义子句&gt;|&lt;视图定义子句&gt;|&lt;授权定义子句&gt;]</p>
</li>
<li><p>删除模式：在SQL中，删除模式语句如下，drop schema &lt;模式名&gt;&lt;cascade|restrict&gt; </p>
<p><em>其中cascade和restrict两者必选其一。选择了cascade(级联)，表示在删除模式的同时把该模式中所有的数据库对象全部删除；选择了restrict(限制)，表示如果该模式中已经定义了下属的数据库对象(如表，视图等)，则拒绝该删除语句的执行。只有当该模式中没有任何下属的对象时才能执行 drop schema语句。</em></p>
</li>
</ul>
</li>
<li><p>基本表的定义、删除与修改</p>
<ul>
<li><p>定义基本表：创建了一个模式就建立了一个数据库的命名空间，一个框架。在这个空间中首先要定义的是该模式包含的数据库基本表。SQL语言使用create table 语句定义基本表，其基本格式如下：</p>
<p><em>create table &lt;表名&gt;(&lt;列名&gt;&lt;数据类型&gt;[列级完整性约束条件][,&lt;列名&gt;&lt;数据类型&gt;[列级完整性约束条件]][,表级完整性约束条件])</em></p>
<p><em>参照表和被参照表可以是同一个表</em></p>
</li>
<li><p>数据类型：</p>
<p><img src="/images/数据类型1.jpg" alt="数据类型1"><br><img src="/images/数据类型2.jpg" alt="数据类型1"></p>
</li>
<li><p>模式与表</p>
<p>每一给基本表都属于某一个模式，一个模式包含多个基本表。当定义基本表时一般可以有三种方法定义它所属的模式，现在要在S-T中定义Student、Course、SC等基本表。</p>
<ol>
<li><p>方法一：在表名中明显的给出模式名。 create table ”S-T“.Student(…);<em>Student所属的模式是S-T</em></p>
</li>
<li><p>方法二：在创建模式语句中同时创建表</p>
</li>
<li><p>方法三：设置所属的模式，这样在创建表时表名中不必给出模式名。</p>
<p>当用户创建基本表(其他数据库对象也一样)时若没有指定模式，系统根据搜索路径来确定该对象所属的模式。</p>
<p>搜索路径包含一组模式列表，关系数据库管理系统会使用模式列表中第一个存在的模式作为数据库对象的模式名。若搜索路径中的模式名都不存在，系统将给出错误。</p>
<p><em>使用下面的语句可以显示当前的搜索路径： show search_path</em></p>
<p><em>搜索路径当前默认值是$user，PUBLIC。其含义是首先搜索与用户名相同的模式名，如果该模式名不存在，则使用PUBLIC模式</em></p>
<p><em>数据库管理员也可以设置搜索路径，如：SET search_path TO “S-T”,PUBLIC; 然后，定义基本表。实际结果是建立了S-T.Student基本表。因为关系数据库管理系统发现路径中第一个模式名S-T存在，就把该模式作为基本表Studnt所属的模式。</em></p>
</li>
</ol>
</li>
<li><p>修改基本表</p>
<p>SQL语言用alter table语句修改基本表，其一般格式为</p>
<p>alter table &lt;表名&gt;</p>
<p>[add [column] &lt;新列名&gt;&lt;数据类型&gt;[完整性约束]]</p>
<p>[add &lt;表级完整性约束&gt;]</p>
<p>[drop [column] &lt;列名&gt;[cascade|restrict]]</p>
<p>[drop constraint &lt;完整性约束名&gt; [restrict|cascade]]</p>
<p>[alter column &lt;列名&gt;&lt;数据类型&gt;]</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>删除基本表</p>
<p>drop table &lt;表名&gt;[restrict|cascade]</p>
<p>若选择restrict，则该表的删除是有限制条件的。欲删除的基本表不能被其他表的约束所引用(如cheack，foreign key等约束)，不能有视图，不能有触发器，不能有存储过程或函数等。如果存在这些依赖该表的对象，则此表不能被删除。</p>
<p>若选择cascade，则该表的删除没有限制条件。在删除基本表的同时，相关的依赖对象，例如视图，都将被一起删除。</p>
<p><em>默认情况是restrict</em></p>
</li>
<li><p>索引的建立与删除</p>
<p>数据库索引有多种类型，常见索引包括顺序文件上的索引、B+树索引、散列索引、位图索引等。<strong>顺序文件上的索引</strong>是针对按指定属性值升序或降序存储的关系，在该属性上建立一个顺序索引文件，索引文件由属性值和相应的元组指针组成。<strong>B+树索引</strong>是将索引属性组织成B+树形式，B+树的叶结点为属性值和相应的元组指针。B+树索引具有动态平衡的优点。<strong>散列索引</strong>是建立若干个桶，将索引属性按照其散列函数值映射到相应桶中，桶中存放索引属性值和相应的元组指针。散列索引具有查找速度快的特点。<strong>位图索引</strong>是用位向量记录所有属性中可能出现的值，每个位向量对于一个可能值。</p>
<p><em>关系数据库管理系统在执行查询时会自动选择合适的索引作为存取路径，用户不必也不能显式的选择索引。</em></p>
<ol>
<li><p>建立索引：在SQL语言中，建立索引使用 create index 语句，一般格式为</p>
<p>create [unique][cluster] index &lt;索引名&gt;</p>
<p>on &lt;表名&gt;(&lt;列名&gt;[&lt;次序&gt;][,&lt;列名&gt;[&lt;次序&gt;]]…)</p>
<p>其中，&lt;表名&gt;是要建索引的基本表的名字。索引可以建立在该表的一列或多列上，各列名之间用逗号分隔。每个&lt;列名&gt;后面还可以用&lt;次序&gt;指定索引值的排列次序，可选ASC(升序)或DESC(降序)，默认值为ASC.</p>
<p>UNIQUE表明此索引每一个索引值只对应唯一的数据记录。</p>
<p>CLUSTER 表示要建立的索引是聚簇索引。</p>
</li>
<li><p>修改索引</p>
<p>对于已经建立的索引，如果需要对其重新命名，可以使用ALTER INDEX 语句。其一般格式为：</p>
<p>ALTER INDEX &lt;旧索引名&gt; RENAME TO &lt;新索引名&gt;</p>
</li>
<li><p>删除索引</p>
<p>在SQL中，删除索引使用DROP INDEX语句，其一般格式为</p>
<p>DROP INDEX &lt;索引名&gt;</p>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>数据字典</p>
<p>数据字典是关系数据库管理系统内部的一组系统表，它记录了数据库中所有的定义信息，包括关系模式定义，视图定义，索引定义，完整性约束定义，各类用户对数据库的操作权限，统计信息等。</p>
</li>
</ul>
<h3 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h3><ul>
<li><p>数据查询是数据库的核心操作。SQL提供了SELECT语句进行数据查询，该语句具有灵活的使用方式和丰富的功能。其一般格式为</p>
<p>select [all|distinct] &lt;目标列表达式&gt;[,&lt;目标列表达式&gt;]…</p>
<p>from &lt;表名或视图名&gt; [,&lt;表名或视图名&gt;…]|(&lt;select语句&gt;)[AS]&lt;别名&gt;</p>
<p>[where&lt;条件表达式&gt;]</p>
<p>[group by &lt;列名1&gt;[having&lt;条件表达式&gt;]]</p>
<p>[order by&lt;列名2&gt;[asc|desc]]</p>
<p>整个select语句的含义是，根据where子句的条件表达式从from子句指定的基本表、视图或派生表中找出满足条件的元组，再按select子句中的目标列表达式选出元组中的属性值形成结果表。</p>
<p>如果由group by 子句，则将结果按&lt;列名1&gt;的值进行分组，该属性列值相等的元组为一组。通常会在每组中作用聚集函数。如果 group by子句带having短语，则只有满足指定条件的组才予以输出。</p>
<p>如果有order by子句，则结果表还有按&lt;列名2&gt;的值升序或降序排序。</p>
<p>select语句既可以完成简单的单表查询，也可以完成复杂的连接查询和嵌套查询。</p>
</li>
<li><p>单表查询</p>
<ol>
<li><p>选择表中的若干列</p>
<ul>
<li><p>查询指定列：如select Sno，Sname from Student。各个列的顺序可以与表中的顺序不一致</p>
</li>
<li><p>查询全部列：如select * from Student</p>
</li>
<li><p>查询经过计算的值：select 子句的&lt;目标列表达式&gt;不仅可以使表中的属性列，也可以是表达式。如：select Sname，‘Year of Birth：’，2014-Sage BIRTHDAY from Student</p>
</li>
</ul>
</li>
<li><p>选择表中的若干元组</p>
<ul>
<li><p>消除取值重复的行</p>
<p>两个本科并不完全相同的元组在投影到指定的某些列上后，可能会变成相同的行。可以使用distinct消除他们。</p>
<p>如：select distinct Sno from SC</p>
</li>
<li><p>查询满足条件的元组</p>
<p>查询满足条件的元组可以通过where子句实现。where子句常用的查询条件</p>
<ol>
<li><p>比较大小</p>
</li>
<li><p>确定范围：谓词between…and…和not between…and…可以用来查找属性值在(或不在)指定范围内的元组，其中<strong>between后是范围的下限(即低值)，and后是范围的上限(即高值)。</strong></p>
</li>
<li><p>字符匹配</p>
<p>谓词like可以用来进行字符串的匹配。其一般语法格式如下：</p>
<p>[not] like ‘&lt;匹配串&gt;’ [escape’&lt;换码字符&gt;’]</p>
<p>其含义是查找指定的属性列值与&lt;匹配串&gt;相匹配的元组。&lt;匹配串&gt;可以是一个完整的字符串，也可以含有通配符%和_。其中：</p>
<p>%(百分号)代表任意长度(长度可以为0)的字符串。例如a%b表示以a开头，以b结尾的任意长度的字符串。</p>
<p>_(下横线)代表任意单个字符</p>
<p><strong>如果用户要查询的字符串本身就含有通配符%或_,这是就要使用escape ‘&lt;换码字符&gt;’ 短语对通配符进行转义了。</strong></p>
</li>
<li><p>涉及空值的查询</p>
<p>IS和NOT IS</p>
</li>
<li><p>多重条件查询</p>
<p>AND 和 OR</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>order by子句</p>
<p>用户可以用order by子句对查询结果按照一个或多个属性列的升序(asc)或降序(desc)排列，默认值为升序。</p>
<p>对于空值，排序时显示的次序由具体系统实现来决定。例如按升序排，含空值的元组最后显示；按降序排，空值的元组则最先显示。各个系统的实现可以不同，只要保持一致就行。</p>
</li>
<li><p>聚集函数</p>
<p>为了进一步方便用户，增强检索功能，SQL提供了许多聚集函，主要有：</p>
</li>
</ol>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">聚集函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">count(*)</td>
<td>统计元组个数</td>
</tr>
<tr>
<td style="text-align:center">count([distinct\</td>
<td>all]&lt;列名&gt;)</td>
<td>统计一列中值的个数</td>
</tr>
<tr>
<td style="text-align:center">sum([distinct\</td>
<td>all]&lt;列名&gt;)</td>
<td>计算一列值的总和(此列必须是数值型)</td>
</tr>
<tr>
<td style="text-align:center">sum([distinct\</td>
<td>all]&lt;列名&gt;)</td>
<td>计算一列值的平均值(此列必须是数值型)</td>
</tr>
<tr>
<td style="text-align:center">max([distinct\</td>
<td>all]&lt;列名&gt;)</td>
<td>求一列值中的最大值</td>
</tr>
<tr>
<td style="text-align:center">min([distinct\</td>
<td>all]&lt;列名&gt;)</td>
<td>求一列值中的最小值</td>
</tr>
</tbody>
</table>
<p>   如果指定distinct短语，则表示在计算时要取消指定列中的重复值。如果不指定distinct短语或指定all短语(all为默认值)，则表示不取消重复值。</p>
<p>  <strong>当聚集函数遇到空值时，除count(*)外，都跳过空值而只处理非空值。聚集函数只能用于select子句和group by中的having子句。</strong></p>
<ol start="5">
<li><p>group by子句</p>
<p>group by子句将查询结果按某一列或多列的值分组，值相等的为一组。</p>
<p>对查询结果分组的目的是为了细化聚集函数的作用对象。如果未对查询结果分组，聚集函数将作用于整个查询结果。分组后聚集函数将作用于每一个组，即每一组都有一个函数值。</p>
<p>例子：见课本P99 例3.48</p>
</li>
</ol>
<ul>
<li><p>连接查询</p>
<p>若一个查询同时涉及两个以上的表，则称之为连接查询。连接查询是关系数据库中最主要的查询，包括等值连接查询、自然连接查询、非等值连接查询、自身连接查询、外连接查询和复合条件连接查询等。</p>
<ol>
<li><p>等值与非等值连接查询</p>
<ul>
<li><p>连接查询的where子句中用来连接两个表的条件称为<strong>连接条件或连接谓词</strong>其一般格式为</p>
<p>[&lt;表名1&gt;.]&lt;列名1&gt;&lt;比较运算符&gt;[&lt;表名2&gt;.]&lt;列名2&gt;</p>
<p>此外连接谓词还可以使用下面形式：</p>
<p>[&lt;表名1&gt;.]&lt;列名1&gt; between [&lt;表名2&gt;.]&lt;列名2&gt; and [&lt;表名3&gt;.]&lt;列名3&gt;</p>
<p><strong>当连接运算符为=时，称为等值连接。使用其他运算符称为非等值连接。</strong></p>
<p>连接谓词中的列名称为连接字段。连接条件中的各连接字段类型必须是可比的，但名字不必相同。</p>
</li>
<li><p>关系数据库管理系统执行该连接操作的一种可能过程是：首先在表Student中找到第一个元组，然后从头开始扫描SC表，逐一查找与Student第一个元组的Sno相等的SC元组，找到后就将Student中的第一个元组与该元组拼接起来，形成结果表中的一个元组。SC全部查找完后，再找Student中第二个元组，然后再从头开始扫描SC，逐一查找满足连接条件的元组，找到后就将Student中的第二个元组与该元组拼接起来，形成结果表中一个元组。重复以上操作。<strong>这就是嵌套循环连接算法的基本思想。</strong></p>
</li>
<li><p>如果在SC表Sno上建立了索引的化，就不用每次全表扫描SC表了，而是根据Sno值通过索引找到相应的SC元组。用索引查询SC中满足条件的元组一般会比全表扫描快。若在等值连接中<strong>把目标列中重复的属性列去掉则为自然连接。</strong></p>
</li>
<li><p>一条SQL语句可以同时完成选择和连接查询，这时where子句是由连接谓词和选择谓词组成的复合条件。</p>
</li>
</ul>
</li>
<li><p>自身连接</p>
<p>连接操作不仅可以在两个表之间进行，也可以是一个表与其自己进行连接，称为表的<strong>自身连接。</strong>例：select FIRST.Cno，SECOND.Cpno</p>
<p>​                from Course FIRST,Course SECOND</p>
<p>​                where FIRST.Cpno = SECOND.Cno</p>
</li>
<li><p>外连接</p>
<p>若某个学生没有选课，<strong>仍把Student的悬浮元组保存在结果关系中</strong>，而在SC表的属性上填空值NULL，这时就需要使用外连接。</p>
<p><strong>左外连接</strong>列出左边关系中所有的元组，<strong>右外连接</strong>列出右边关系中所有的元组。</p>
</li>
<li><p>多表连接</p>
<p>连接操作处理可以是<strong>两表连接</strong>、一个表与其自身连接外，还可以是两个以上的表进行连接，猴子通常称为<strong>多表连接</strong>。</p>
</li>
</ol>
</li>
<li><p>嵌套查询</p>
<p>在SQL语言中，<strong>一个select-from-where语句称为一个查询块</strong>。将一个查询块嵌套在另一个查询块的where子句或having短语的条件中的查询称为嵌套查询。上层的查询块称为外层查询或父查询，下层查询块称为内层查询或子查询。</p>
<p>SQL语言允许多层嵌套查询，即一个子查询中还可以嵌套其他子查询。需要特别指出的是，<strong>子查询的select语句中不能使用order by子句</strong>，order by子句只能对最终查询结果排序。</p>
<p>嵌套查询使用户可以用多个简单查询构成复杂的查询，从而增强SQL的查询能力。以层层嵌套的方式来构造程序正是SQL中”结构化“的含义所在。</p>
<ol>
<li><p>带有in谓词的子查询</p>
<p>子查询的查询条件不依赖于父查询，称为<strong>不相关子查询</strong></p>
<p>实现同一个查询请求可以有多种方法，当然不同的方法其执行效率可能会有差别，甚至会差别很大。这就是数据库编程人员应该掌握的数据库性能调优技术。</p>
<p>有些嵌套查询可以用连接运算代替，有些是不能替代的。</p>
<p>查询的查询条件不依赖于父查询，这类子查询称为不相关子查询。不相关子查询是较简单的一类子查询。<strong>如果子查询的查询条件依赖于父查询，这类子查询称为相关子查询，整个查询语句称为相关嵌套查询语句。</strong></p>
</li>
<li><p>带有比较运算符的子查询</p>
<p><img src="/images/相关子查询.jpg" alt="相关子查询"></p>
<p>x是表SC的别名，又称为元组变量，可以用来表示SC的元组。内层查询是求一个学生所有选修课程平均成绩的，至于是哪个学生的平均成绩要看<strong>参数x.Sno的值，而该值是与父查询相关的，因此这类查询称为相关子查询。</strong></p>
<p><strong>求解相关子查询不能像求解不相关子查询那样一次将子查询求解出来，然后求解父查询。</strong>内层查询由于与外层查询有关，因此必须反复求值。</p>
</li>
<li><p>带有any(some) 或 all 谓词的子查询</p>
<p>子查询返回单值时可以用比较运算符，但返回多值时要用any(有的系统用some)或all谓词修饰符。而使用any或all谓词时则必须同时使用比较运算符。</p>
<ul>
<li><em>&gt;any  大于子查询结果中的某个值</em></li>
<li><em>&gt;all  大于子查询结果中的所有值</em></li>
</ul>
<p>例子见课本P107 例3.58</p>
<p>例子中的查询也可以用聚集函数来实现，事实上，用聚集函数实现子查询通常比直接用any或all查询效率要高。</p>
<p><img src="/images/any与all和聚集函数对应关系表.jpg" alt="any与all和聚集函数对应关系表"></p>
</li>
<li><p>带有exists谓词的子查询</p>
<ul>
<li><p>exists代表存在量词∃。带有exists谓词的子查询不返回任何数据，只产生逻辑真值”true”或逻辑假值”false”。</p>
<p>例子：课本P109 例3.60</p>
</li>
<li><p>使用存在量词exists后，若内层查询结果非空，则外层的where子句返回真值，否则返回假值。</p>
</li>
<li><p>由exists引出的子查询，其目标列表达式通常都用*，因为带exists的子查询只返回真值或假值，给出列名无实际意义。</p>
</li>
<li><p>与exists谓词相对应的是not exists谓词。使用存在量词not exists后，若内层查询结果为空，则外层的where子句返回真值，否则返回假值。</p>
</li>
<li><p><strong>一些带exists 或 not exists谓词的子查询不能被其他形式的子查询等价替换，但所有带in谓词、比较运算符、any和all谓词的子查询都能用带exists谓词的子查询等价替换。</strong></p>
</li>
<li><p>SQL中没有全称量词，但是可以把带有全称量词的谓词转换为等价的带有存在量词的谓词</p>
<p>例子：课本P110 例3.62、3.63</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>集合查询</p>
<p>select 语句的查询结果是元组的集合，所以多个select语句的结果可进行集合操作。<strong>集合操作主要包括并操作union、交操作intersect和差操作except。</strong></p>
<p><em>使用union将多个查询结果合并起来时，系统会自动去掉重复元组。如果要保留重复元组则用union all操作符。</em></p>
</li>
<li><p>基于派生表的查询</p>
<p>子查询不仅可以出现在where子句中，还可以出现在from子句中，这时子查询生成的临时派生表成为主查询的查询对象。</p>
<p>select Sno,Cno</p>
<p>from SC,(select Sno,Avg(Grade) from SC group by Sno) as Avg_sc(avg_sno,avg_grade)</p>
<p>where SC.Sno = Avg_sc.avg_sno and SC.Grade &gt;= Avg_grade</p>
<p>这里from子句中的子查询将生成一个派生表Avg_sc。该表由avg_sno和avg_grade两个属性组成，记录了每个学生的学号及平均成绩。主查询将SC表与Avg_sc按学号相等进行连接，选出选修课成绩大于其平均成绩的课程号。</p>
<p><strong>通过from子句生成派生表时，as关键字可以省略，但必须为派生关系指定一个别名。</strong></p>
</li>
<li><p>select 语句的一般格式：</p>
<p>select [ALL|DISTINCT]&lt;目标列表达式&gt;[别名][,&lt;目标列表达式&gt;[别名]]…</p>
<p>from &lt;表名或视图名&gt;[别名][,&lt;表名或视图名&gt;[别名]]…|(<select 语句>)[as]&lt;别名&gt;</select></p>
<p>[where &lt;条件表达式&gt;]</p>
<p>[group by&lt;列名1&gt;[having1&lt;条件表达式&gt;]]</p>
<p>[order by&lt;列名2&gt;[asc|desc]]</p>
<ol>
<li><p>目标列表达式的可选格式</p>
<p><img src="/images/目标列表达式的可选格式.jpg" alt="目标列表达式的可选格式"></p>
</li>
<li><p>聚集函数的一般格式</p>
<p><img src="/images/聚集函数的一般格式.jpg" alt="聚集函数的一般格式"></p>
</li>
<li><p>where子句的条件表达式的可选格式</p>
<p><img src="/images/where子句的条件表达式的可选格式.jpg" alt="where子句的条件表达式的可选格式"></p>
</li>
</ol>
</li>
</ul>
<h3 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h3><p>数据更新操作有三种:向表中添加若干行数据、修改表中的数据和删除表中的若干行数据。</p>
<ul>
<li><p>插入数据</p>
<ol>
<li><p>插入元组</p>
<p>insert into &lt;表名&gt;[(&lt;属性列1&gt;[,&lt;属性列2&gt;]…)]values(&lt;常量1&gt;[,常量2]…)</p>
<p>在into子句中指出了表名Student，并指出了新增加的元组在哪些属性上要赋值，属性的顺序可以与create table中的顺序不一样。values子句对新元组的各属性赋值，字符串常数要用单引号(英文符合)括起来。</p>
<p>例：</p>
<p>insert into SC(Sno,Cno) values(‘201215128’,’1’)</p>
<p><strong>关系数据库管理系统将在新插入记录的Grade列上自动的赋空值。</strong></p>
<p>或 insert into SC values(‘201215128’,’1’,NULL)</p>
<p><strong>因为没有指出SC的属性名，在Grade列上要明确给出空值。</strong></p>
</li>
<li><p>插入子查询结果</p>
<p>插入子查询结果的insert 语句格式为</p>
<p>insert into &lt;表名&gt;[(&lt;属性列1&gt;[,&lt;属性列2&gt;…]） 子查询；</p>
</li>
</ol>
</li>
<li><p>修改数据</p>
<p>修改操作又称为更新操作，其语句的一般格式为</p>
<p>update &lt;表名&gt;</p>
<p>set &lt;列名&gt;=&lt;表达式&gt;[，&lt;列名&gt;=&lt;表达式&gt;]…</p>
<p>[where &lt;条件&gt;]</p>
<p>其功能是修改指定表中满足where子句条件的元组。其中set子句给出&lt;表达式&gt;的值用于取代相应的属性列值。如果省略where子句，则表示要修改表中的所有元组。</p>
<ol>
<li><p>修改某一个元组的值</p>
<p>例3.73 将学生201215121的年龄改为22岁</p>
<p>update Student set Sage=22 where Sno=’201215121’</p>
</li>
<li><p>修改多个元组的值</p>
<p>例 3.74 将所有学生的年龄增加1岁</p>
<p>update Student set Sage=Sage+1</p>
</li>
<li><p>带子查询的修改语句</p>
<p>子查询也可以嵌套在update语句中，用以构造修改的条件</p>
<p>例 3.75 将计算机科学系全体学生的成绩置零。</p>
<p>update SC set Grade=0</p>
<p>where Sno in(select Sno from Student where Sdept=’CS’)</p>
</li>
</ol>
</li>
<li><p>删除数据</p>
<p>删除语句的一般格式为</p>
<p>delete from &lt;表名&gt; [where &lt;条件&gt;]；</p>
<ol>
<li>删除某一个元组的值</li>
<li>删除多个元组的值</li>
<li>带子查询的删除语句</li>
</ol>
</li>
</ul>
<h3 id="空值的处理"><a href="#空值的处理" class="headerlink" title="空值的处理"></a>空值的处理</h3><p>所谓的空值就是”不知道”或”不存在”或”无意义”的值。 SQL语言中允许某些元组的某些属性在一定情况下取空值。</p>
<p>一般有以下几种情况：</p>
<ul>
<li>该属性应该有一个值，但目前不知道它的具体值。</li>
<li>该属性不应该有值。</li>
<li>由于某种原因不便于填写。</li>
</ul>
<ol>
<li><p>空值的产生</p>
<p>插入和连接会产生空值。空值的关系运算也会产生空值。</p>
</li>
<li><p>空值的判断</p>
<p>判断一个属性的值是否为空值，用 IS NULL或IS NOT NULL来表示。</p>
</li>
<li><p>空值的约束条件</p>
<p>属性定义(或者域定义)中有 NOT NULL约束条件的不能取空值，码属性不能取空值。</p>
</li>
<li><p>空值的算术运算、比较运算和逻辑运算</p>
<p>空值与另一个值(包括另一个空值)的算术运算的结果为空值，空值与另一个值(包括另一个空值)的比较运算的结果为unknow。<strong>有了unknown后，传统的逻辑运算中二值(true,false)逻辑就扩展成了三值逻辑。</strong></p>
<p><img src="/images/逻辑运算符真值表.jpg" alt="逻辑运算符真值表"></p>
</li>
</ol>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>视图是从一个或几个基本表(或视图)导出的表。它与基本表不同，是一个虚表。数据库中只存放视图的定义，二不存放视图对应的数据，这些数据仍存放在原来的基本表中。所以一旦基本表中的数据发生变化，从视图中查询出的数据也就随之改变了。视图一经定义，就可以和基本表一样被查询、被删除。</p>
<ul>
<li><p>定义视图</p>
<ol>
<li><p>建立视图</p>
<p>SQL语言用create view命令建立视图，其一般格式为</p>
<p>create view &lt;视图名&gt;[(&lt;列名&gt;[,&lt;列名&gt;]…)]</p>
<p>as &lt;子查询&gt;</p>
<p>[with check option]</p>
<p>其中，子查询可以是任意的select语句，是否可以含有order by子句和distinct短语，则取决于具体系统的实现。</p>
<p><strong>with check option 表示对视图进行update、insert和delete操作时要保证更新、插入或删除的行满足视图定义中的谓词条件(即子查询中的条件表达式)。</strong></p>
<p>组成视图的属性列名或者全部省略或者全部指定，没有第三种选择。如果省略了视图的各个属性列名，则隐含该视图由子查询中select子句目标列中的诸字段组成。但在下列三种情况下必须明确指定组成视图的所有列名:</p>
<ol>
<li>某个目标列不是单纯的属性名，而是聚集函数或列表达式</li>
<li>多表连接时选出了几个同名列作为视图的字段</li>
<li>需要在视图中为某个列启用新的更合适的名字</li>
</ol>
<ul>
<li>关系数据库管理系统执行create view语句的结果<strong>只是把视图的定义存入数据字典，并不执行其中的select语句。</strong>只是在对视图查询时，才按视图的定义从基本表中将数据查出。</li>
<li>由于在定义IS_Student视图时加上了with check option子句，以后对该视图进行插入、修改和删除操作时，<strong>关系数据库管理系统会自动加上Sdept=’IS‘的条件</strong>。P122 例：3.85</li>
<li>若一个视图是<strong>从单个基本表导出的，并且只是去掉了基本表的某些行和某些列，但保留了主码，则称这类视图为行列子集视图。</strong></li>
<li>视图不仅可以建立在一个或多个基本表上，也<strong>可以建立在一个或多个已定义好的视图上，或建立在基本表与视图上。</strong></li>
<li>定义基本表时，为了减少数据库中的冗余数据，表中只存放基本数据，由基本数据经过各种计算派生吃的数据一般是不存储的。由于视图中的数据并不实际存储，所以定义视图时可以根据应用的需要设置一些派生属性列。这些派生属性由于在基本表中并不实际存在，也称它们为虚拟列。<strong>带虚拟列的视图也称为带表达式的视图。</strong>例 P123 例3.88</li>
</ul>
</li>
<li><p>删除视图</p>
<ul>
<li>该语句的格式为 drop view &lt;视图名&gt;[cascade];</li>
<li>视图删除后视图的定义将从数据字典中删除。如果该视图上还导出了其他视图，则使用cascade级联删除语句把该视图和由它导出的所有视图一起删除。</li>
<li>基本表删除后，由该基本表导出的所有视图均无法使用，但是视图的定义没有从字典中清除。删除这些视图定义需要显式的使用drop view语句。</li>
</ul>
</li>
</ol>
</li>
<li><p>查询视图</p>
<ul>
<li>关系数据库管理系统执行对视图的查询时，首先进行有效性检查，检查查询中涉及的表、视图等是否存在。如果存在，则<strong>从数据字典中取出视图的定义，把定义中的子查询和用户的查询结合起来，转换成等价的对基本表的查询，然后再执行修正了的查询。这一转换过程称为视图消解。</strong></li>
<li>目前多数关系数据库系统对行列子集视图的查询均能进行正确转换。但对非行列子集视图的查询就不一定能做转换了，因此这类查询应该直接对基本表进行。</li>
<li>但<strong>定义视图并查询视图与基于派生表的查询是有区别的。</strong>视图一旦定义，其定义将永久保存在数据字典中，之后的所有查询都可以直接引用该视图。而<strong>派生表只是在语句执行时临时定义，语句执行后该定义即被删除。</strong></li>
</ul>
</li>
<li><p>更新视图</p>
<ul>
<li>更新视图是指通过视图来插入、删除和修改数据。</li>
<li>由于视图是不实际存储数据的虚表，因此对视图的更新最终要转换为对基本表的更新。像查询视图那样，对视图的更新操作也是通过视图消解，转换为对基本表的更新操作。</li>
<li>为防止用户通过视图对数据进行增加、删除、修改时，有意无意的对不属于视图范围内的基本表数据进行操作，可在定义视图时加上with check option子句。这样在视图上增、删、改数据时，关系数据库管理系统会检查视图定义中的条件，若不满足条件则拒绝执行该操作。</li>
<li>在关系数据库中，并不是所有的视图都是可更新的，因为有些视图的更新不能唯一的有意义的转换成对相应基本表的更新。</li>
<li>一般的，行列子集视图是可更新的。除行列子集视图外，有些视图理论上是可更新的，但他们的确切特征还是尚待研究的课题。还有些视图从理论上就是不可更新的。</li>
<li>目前，各个关系数据库管理系统一般都只允许对行列子集视图进行更新，而且各个系统对视图的更新还有更进一步的规定。由于各系统实现方法上的差异，这些规定也不尽相同。</li>
<li>一个不允许更新的视图上定义的视图也不允许更新，不可更新的视图与不允许更新的视图是两个不同的概念。</li>
</ul>
</li>
<li><p>视图的作用</p>
</li>
</ul>
<p>视图最终是定义在基本表之上的，对视图的一起操作最终也要转换为对基本表的操作。</p>
<ol>
<li><p>视图能够简化用户的操作</p>
<ol start="2">
<li><p>视图能够是用户以多种角度看待同一组数据</p>
</li>
<li><p>视图对重构数据库提供了一定程度的逻辑独立性</p>
<p>这样尽管数据库的逻辑结构改变了(变为SX和SY两个表)，但应用程序不必修改，因为新建立的视图定义为用户原来的关系，使用户的外模式保持不变，用户的应用程序通过视图仍然能够查找数据。</p>
</li>
<li><p>视图能够对机密数据提供安全保护</p>
</li>
<li><p>适当利用视图可以更清晰的表达查询</p>
</li>
</ol>
</li>
</ol>
<h2 id="第四章-数据库安全性"><a href="#第四章-数据库安全性" class="headerlink" title="第四章 数据库安全性"></a>第四章 数据库安全性</h2><h3 id="数据库安全性概述"><a href="#数据库安全性概述" class="headerlink" title="数据库安全性概述"></a>数据库安全性概述</h3><p>数据库的安全性是指保护数据库以防止不合法使用所造成的数据泄露、更改或破坏。</p>
<ul>
<li><p>数据库的不安全因素</p>
<ol>
<li>非授权用户对数据库的恶意存取和破坏</li>
<li>数据库中重要或敏感的数据被泄漏</li>
<li>安全环境的脆弱性</li>
</ol>
</li>
<li><p>安全标准简介</p>
<p>为满足全球IT市场上互认标准化安全评估结果的需要，CTCPEC、FC、TCSEC和ITSEC的发起组织于1993年起开始联合行动，解决标准中概念和技术上的差异，将各自独立的准则集合成一组单一的、能被广泛使用的IT安全准则，这一行动被称为通用准则(CC)项目。项目发起组织的代表建立了专门的委员会来开发通用准则，经历多次讨论和修订，CCV2.1版于1999年被ISO采用为国际标准，<strong>2001年被我国采用为国家标准。</strong></p>
<p><strong>TCSEC又称桔皮书。</strong>1991年4月，美国国家计算机安全中心颁布了《可信计算机系统评估准则关于可信数据库系统的解释》(即紫皮书)，将TCSEC扩展到数据库管理系统。TCSEC/TDI中定义了数据库管理系统的设计与实现中需满足和用以进行安全性级别评估的标准，从4个方面来描述安全性级别划分的指标，即安全策略、责任、保证和文档。每个方面又细分为若干项。</p>
<p><img src="/images/信息安全标准的发展简史.jpg" alt="信息安全标准的发展简史"></p>
<p>根据计算机系统对各项指标的支持情况，TCSEC/TDI将系统划分为4组7个等级，依次是D、C(C1,C2)、B(B1,B2,B3)、A(A1),按系统可靠或可信程度逐渐增高</p>
<p><img src="/images/安全级别划分.jpg" alt="TCSEC/TDI安全级别划分"></p>
<ul>
<li>D级：该级是最低级别。保留D级的目的是为了将一切不符合更高标准的系统统统归于D组。如DOS就是操作系统中安全标准为D级的典型例子，它具有操作系统的基本功能，如文件系统、进程调度等，但在安全性方面几乎没有什么专门的机制来保障。</li>
<li>C1级：该级只提供了非常初级的自主安全保护，能够实现对用户和数据的分离，进行<strong>自主存取控制(DAC)</strong>,保护或限制用户权限的传播。现有的商业系统往往稍作改进即可满足要求。</li>
<li>C2级：该级实际上是安全产品的最低档，提供受控的存取保护，即将C1级的DAC进一步细化，以个人身份注册负责，并实施审计和资源隔离。达到C2级的产品在其名称中往往不突出”安全”这一特色，如操作系统中的window 2000、数据库产品中的Oracle 7等。</li>
<li>B1级：标记安全保护。对系统的数据加以标记，并<strong>对标记的主体和客体实施强制存取控制(MAC)以及审计等安全机制。B1级别的产品才被认为是真正意义上的安全产品，</strong>满足此级别的产品前一般多冠以”安全”或可信的字样，作为区别于普通产品的安全产品出售。</li>
<li>B2级：结构化保护。建立形式化的安全策略模型，并对系统内的所有主体和客体实施DAC和MAC。</li>
<li>B3级：安全域。该级的TCB必须满足访问监控器的要求，审计跟踪能力更强，并提供系统恢复过程。</li>
<li>A1级：验证设计，即提供B3级保护的同时给出系统的形式化设计说明和验证，以确信各安全保护真正实现。</li>
</ul>
<p>CC评估保障即的划分</p>
<p><img src="/images/CC评估保证级(EAL" alt="CC评估保证级(EAL)的划分">的划分.jpg)</p>
<p><strong>粗略而言，TCSEC的C1和C2级分别相当于EAL2和EAL3；B1、B2和B3分别相当于EAL4、EAL5和EAL6；A1对应于EAL7。</strong></p>
</li>
</ul>
<h3 id="数据库安全性控制"><a href="#数据库安全性控制" class="headerlink" title="数据库安全性控制"></a>数据库安全性控制</h3><p>在一般计算机系统中，安全措施是一级一级层层设置的。</p>
<p>下面讨论与数据库有关的安全性，主要包括用户身份鉴别、多层存取控制、审计、视图和数据加密等安全技术。</p>
<p><img src="/images/计算机系统的安全模型.jpg" alt="计算机系统的安全模型"></p>
<ul>
<li><p>用户身份鉴别</p>
<ol>
<li>静态口令鉴别</li>
<li>动态口令鉴别</li>
<li>生物特征鉴别</li>
<li>智能卡鉴别</li>
</ol>
</li>
<li><p>存取控制</p>
<p>数据库安全最重要的一点就是确保只授权给有资格的用户访问数据库的权限，同时令所有未被授权的人员无法接近数据，这主要通过数据库系统的存取控制机制实现。</p>
<p><strong>存取控制机制主要包括定义用户权限和合法权限检查两部分。</strong></p>
<ol>
<li><p>定义用户权限，并将用户权限登记到数据字典中</p>
<p>用户对某一数据对象的操作权力称为权限。某个用户应该具有何种权限是个管理问题和政策问题，而不是技术问题。数据库管理系统的功能是保证这些决定的执行。为此，数据库管理系统必须提供适当的语言来定义用户权限，这些定义经过编译后存储在数据字典中，被称做安全规则活授权规则</p>
</li>
<li><p>合法权限检查</p>
<p>每当用户发送存取数据库的操作请求后(请求一般包括操作类型、操作对象和操作用户等信息)，数据库管理系统查找数据字典，根据安全规则进行合法权限检查，若用户的操作请求超出了定义的权限，系统将拒绝执行此操作。</p>
<p><strong>定义用户权限和合法权限检查机制一起组成了数据库管理系统的窜去控制子系统。</strong></p>
<p>C2级的数据库管理系统支持自主存取控制，B1级的数据库管理系统支持强制存取控制。</p>
<p>两类方法的简单定义：</p>
<ul>
<li>在自主存取控制方法中，用户对于不同的数据库对象有不同的存取权限，不同的用户对同一对象也有不同的权限，而且用户还可将其拥有的存取权限转授给其他用户。因此自主存取控制非常灵活。</li>
<li>在强制存取控制方法中，每一个数据库对象被标以一定的密级，每一个用户也被授予某一个级别的许可证。对于任意一个对象，只有具有合法许可证的用户才可以存取。因此强制存取控制因此相对比较严格。</li>
</ul>
</li>
</ol>
</li>
<li><p>自主存取控制方法</p>
<p>大型数据库管理系统都支持自主存取控制，SQL标准也对自主存取控制提供支持，这主要通过SQL的GTANT语句和REVOKE语句来实现。</p>
<p><strong>用户权限是由两个要素组成的:数据库对象和操作类型。</strong>定义一个用户的存取权限就是要定义这个用户可以在哪些数据库对象上进行哪些类型的操作。在数据库系统中，<strong>定义存取权限称为授权</strong>。</p>
<p>在非关系系统中，用户只能对数据进行操作，存取控制的对象不仅有数据本身(基本表中的数据、属性列上的数据)，还有数据库模式(包括模式、基本表、视图和所有的创建等)</p>
</li>
<li><p><img src="/images/关系数据库系统中的存取权限.jpg" alt="关系数据库系统中的存取权限"></p>
</li>
<li><p>授权：授予与收回</p>
<p>SQL中使用GRANT和REVOKE语句向用户授予或收回对数据的操作权限。GRANT语句向用户授予权限，REVOKE语句收回以及授予用户的权限。</p>
<ol>
<li><p>GRANT</p>
<p>GRANT语句的一般格式为</p>
<p>GRANT &lt;权限&gt;[,&lt;权限&gt;]…</p>
<p>ON &lt;对象类型&gt;&lt;对象名&gt;[,&lt;对象类型&gt;&lt;对象名&gt;]…</p>
<p>TO &lt;用户&gt;[,&lt;用户&gt;]…</p>
<p>[WITH GRANT OPTION]</p>
<p>其语义为：将对指定操作对象的指定操作权限授予指定的用户。发出该GRANT语句的可以是数据库管理员，也可以是该数据库对象创建者(即属主owner)，还可以是已经拥有该权限的用户。接受权限的用户可以是一个或多个具体用户，也可以是PUBLIC，即全体用户。</p>
<p>如果指定了 with grant option子句，则获得某种权限的用户还可以把这种权限再授予其他的用户。没有指定with grant option子句，则获得某种权限的用户只能使用该权限，不能传播该权限。</p>
<p>SQL标准允许具有with grant option的用户把相应权限或其子集传递授予其他用户，但不允许循环授权，即被授权者不能把权限再授回给授权者或其祖先。</p>
</li>
<li><p>REVOKE</p>
<p>授予用户的权限可以由数据库管理员或其他授权者用revoke 语句收回，revoke语句的一般格式为</p>
<p>REVOKE &lt;权限&gt;[,&lt;权限&gt;]…</p>
<p>ON &lt;对象类型&gt;&lt;对象名&gt;[,&lt;对象类型&gt;&lt;对象名&gt;]…</p>
<p>FROM &lt;用户&gt;[,&lt;用户&gt;]…[cascade|restrict]</p>
<p>所有授予出去的权力在必要时又都可以用revoke语句收回。</p>
<p>可见，<strong>用户可以”自主“的决定将数据的存取权限授予何人、决定是否也将”授权“的权限授予别人。因此称这一的存取控制是自主存取控制。</strong></p>
</li>
</ol>
</li>
</ul>
<ol start="3">
<li><p>创建数据库模式的权限</p>
<p>GRANT和REVOKE语句向用户授予或收回对数据的操作权限。对创建数据库模式的一类的数据库对象的授权则由数据库管理员在创建用户时实现。</p>
<p>create user语句一般格式如下：</p>
<p>create user <username> [with][DBA|RESOURCE|CONNECT]</username></p>
<p>对create user语句说明如下：</p>
<ul>
<li><p>只有系统的超级用户才有权创建一个新的数据库用户</p>
</li>
<li><p>新创建的数据库用户有三种权限：connec他、resource和dba。</p>
</li>
<li><p>create user命令中如果没有指定创建的新用户的权限，默认该用户拥有connect权限。拥有connect权限的用户不能创建新用户，不能创建模式，也不能创建基本表，只能登入数据库。由数据库管理员或其他用户授予它应由的权限，根据获得的授权情况他可以对数据库对象进行权限范围内的操作。</p>
</li>
<li><p>拥有resource权限的用户能创建基本表和视图，成为所创建对象的属主但不能创建新的用户。数据库对象的属主可以使用grant语句把该对象上的存取权限授予其他用户。</p>
</li>
<li><p>拥有DBA权限的用户是系统中的超级用户，可以创建新的用户、创建模式、创建基本表和视图等；DBA拥有对所有数据库对象的存取权限，还可以把这些权限授予一般用户。</p>
<p><img src="/images/权限与可执行的操作对照表.jpg" alt="权限与可执行的操作对照表"></p>
<p><em>注意：create user语句不上SQL标准，因此不同的关系数据库管理系统的语法和内容相差甚远。</em></p>
</li>
</ul>
</li>
</ol>
<ul>
<li>数据库角色</li>
</ul>
<p>数据库角色是被命名的一组与数据库操作相关的权限，角色是权限的集合。</p>
<ol>
<li><p>角色的创建</p>
<p>创建角色的SQL语句格式是</p>
<p>create role &lt;角色名&gt;</p>
<p>刚刚创建的角色是空的，没有任何内容。可以用grant为角色授权。</p>
</li>
<li><p>给角色授权</p>
<p>grant &lt;权限&gt;[,&lt;权限&gt;]…</p>
<p>on &lt;对象类型&gt;对象名</p>
<p>to &lt;角色&gt;[,&lt;角色&gt;]…</p>
<p>数据库管理员和用户可以利用grant语句将权限授予某一个或几个角色。</p>
</li>
<li><p>将一个角色授予其他的角色或用户</p>
<p>grant &lt;角色1&gt;[,&lt;角色2&gt;]…</p>
<p>to &lt;角色3&gt;[,&lt;用户1&gt;]…</p>
<p>[with admin option]</p>
<p>该语句把角色授予某用户，或授予另一角色。这样，一个角色所拥有的权限就是授予它的全部角色所包含的权限的总和。</p>
<p>授予者或者是角色的创建者忙活着拥有在这个角色上的admin option。</p>
<p>如果指定了with admin option子句，则获得某种权限的角色或用户还可以把这种权限再授予其他的角色</p>
<p>一个角色包含的权限包括直接授予这个角色的全部权限加上其他角色授予这个角色的全部权限。</p>
</li>
<li><p>角色权限的收回</p>
<p>revoke &lt;权限&gt;[,&lt;权限&gt;]…</p>
<p>on &lt;对象类型&gt;&lt;对象名&gt;</p>
<p>from &lt;角色&gt;[,&lt;角色&gt;]…</p>
<p>用户可以收回角色的权限，从而修改角色拥有的权限。</p>
<p>revoke 动作的执行者或者是角色的创建者，或者拥有在这个(些)角色上的ADMIN OPTION.</p>
</li>
</ol>
<ul>
<li><p>强制存取控制方法</p>
<p>在强制存取控制中，数据库管理系统所管理的全部视图被分为主体和客体两大类。</p>
<p>主体是系统中的获得实体，既包括数据库该你了系统所管理的实际用户，也包括代表用户的各进程。客体是系统中的被动实体，是受主体操作的，包括文件、基本表、索引、视图等。对于主体和客体，数据库管理系统为他们每个实例指派一个，敏感度标记。</p>
<p>敏感度标记被分成若干级别，例如绝密(TS)、机密(S)、可信(C)、公开(P)等。密级的次序是TS&gt;=S&gt;=C&gt;=P。主体的敏感度标记称为许可证级别，客体的敏感度标记称为密级。强制存取控制机制就是通过对比主体的敏感度标记和客体的敏感度标记，最终确定主体是否能够存取客体。</p>
<p>当某以用户以标记label注册入系统时，系统要求他对任何客体的存取必须遵循如下规则：</p>
<ol>
<li><p>仅当主体的许可证级别大于或等同于客体的密级时，该主体才能读取相应的客体。</p>
</li>
<li><p>仅当主体的许可证级别小于或等同于客体的密级时，该主体才能写相应的客体。</p>
<p>如果违反了规则2，就有可能把数据的密级从高流向低，造成数据的泄漏。</p>
</li>
</ol>
<p>强制存取控制是对数据本身进行密级标记，无论数据如何复制，标记与数据是一个不可分的整体，只有符合密级要求的用户才可以操作数据，从而提供了更高级别的安全性。</p>
</li>
</ul>
<h3 id="视图机制"><a href="#视图机制" class="headerlink" title="视图机制"></a>视图机制</h3><p>可以为不同的用户定义不同的视图,把数据对象限制在一定的范围内。也就是说，通过视图机制把要保密的数据对无权存取的用户隐藏起来，从而自动对数据提供一定程度的安全保护。</p>
<p>视图机制间接的实现支持存取谓词的用户权限定义。</p>
<h3 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h3><p>审计功能把用户对数据库的所有操作自动记录下来，放入审计日志中。审计员可以利用审计日志监控数据库中的各种行为，重现导致数据库现有状况的一系列事件，找出非法存取数据的人、时间和内容等。</p>
<ol>
<li><p>审计事件</p>
<p>审计事件一般有多个类别</p>
<p>服务器事件:审计数据库服务器发生的事件，包含数据库服务器的启动、停止、数据库服务器配置文件的重新加载。</p>
<p>系统权限：对系统拥有的结构或模式对象进行操作的审计，要求该操作的权限是通过系统权限获得的。</p>
<p>语句事件：对SQL语句，如DDL、DML、DQL及DCL语句的审计</p>
<p>模式对象事件：对特定模式对象上进行的select 或dml操作的审计。模式对象包括表、视图、存储过程、函数等。模式对象不包括依附于表的索引、约束、触发器、分区表等。</p>
</li>
<li><p>审计功能</p>
<p>审计功能主要包括以下几个方面：</p>
<ul>
<li>基本功能，提供多种审计查阅方式：基本的、可选的、有限的，等等。</li>
<li>提供多套审计规则，审计规则一般在数据库初始化时设定，以方便审计员管理。</li>
<li>提供审计分析和报表功能</li>
<li>审计日志管理功能</li>
<li>系统提供查询审计设置及审计记录信息的专门视图。</li>
</ul>
</li>
<li><p>audit语句和noaudit语句</p>
<p>audit语句用来设置审计功能，noaudit语句则取消审计功能。</p>
<p>审计一般可以分为用户级审计和系统级审计。</p>
<p>例：audit alter，update on SC和noaudit alter，update on SC</p>
<p>审计设置以及审计日志一般都存储在数据字典中。必须把审计开关打开，才可以在系统表SYS_AUDITTRAIL中查看到审计信息。</p>
<p>数据库安全审计系统提供了一种事后检查的安全机制。</p>
</li>
</ol>
<h3 id="数据加密"><a href="#数据加密" class="headerlink" title="数据加密"></a>数据加密</h3><p>加密的基本思想是根据一定的算法将原始数据——明文变换为不可直接识别的格式——密文，从而使得不知道界面算法的人无法获知数据的内容.</p>
<ol>
<li><p>存储加密</p>
<p>对于存储加密，一般提供透明和非透明两种存储加密方式。透明存储加密是内核级加密保护方式，对用户完全透明；非透明存储加密则是通过多个加密函数实现的。</p>
</li>
<li><p>传输加密</p>
<p>常见的传输加密方式如链路加密和端到端加密</p>
<p>安全套接层协议SSL，端到端</p>
<p>实现思路包括：</p>
<ol>
<li><p>确认通信双方端点的可靠性</p>
</li>
<li><p>协商加密算法和密钥</p>
</li>
<li><p>可信数据传输</p>
</li>
</ol>
</li>
</ol>
<h3 id="其他安全性保护"><a href="#其他安全性保护" class="headerlink" title="其他安全性保护"></a>其他安全性保护</h3><p>在自主存取控制和强制存取控制之外，还有推理控制以及数据库应用中隐蔽信道和数据隐私保护等技术。</p>
<ul>
<li>推理控制除了的是强制存取控制为解决的问题。数据库推荐控制机制用来避免用户利用其能够访问的数据推知更高密级的数据。</li>
<li>隐蔽信道处理内容也是强制存取控制为解决的问题。</li>
<li>数据隐私成为数据库应用中新的数据保护模式。所谓数据隐私是控制不愿被他人知道或他人不便知道的个人数据的能力。</li>
</ul>
<hr>
<h2 id="第五章-数据库完整性"><a href="#第五章-数据库完整性" class="headerlink" title="第五章 数据库完整性"></a>第五章 数据库完整性</h2><p>数据库的完整性是指数据的正确性和相容性</p>
<p>为维护数据库的完整性，数据库管理系统必须能够实现以下功能：</p>
<ol>
<li>提供定义完整性约束条件的机制</li>
<li>提供完整性检查的方法</li>
<li>进行违约处理</li>
</ol>
<p>关系数据库管理系统使得完整性控制成为其核心支持的功能，从而能够为所有用户和应用提供一致的数据库完整性。</p>
<h3 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h3><ul>
<li><p>定义实体完整性</p>
<p>关系模型的实体完整性在create table中用primary key定义。对单属性构成的码有两种说明方法，一种是定义为劣迹约束条件，另一种是定义为标记约束条件。对于多个属性构成的码只有一种说明方法，即定义为表级约束条件。</p>
</li>
<li><p>实体完整性检查和违约处理</p>
<p>用primary key短语定义了关系的主码后，每当用户程序对级别表插入一条记录或对主码列进行更新操作时，关系数据库管理系统将按照实体完整性规则进行自动检查。</p>
<ol>
<li>检查主码值是否唯一，如果不唯一则拒绝插入或修改。</li>
<li>检查主码的各个属性是否为空，只要有一个为空就拒绝插入或修改。</li>
</ol>
<p>全表扫描是十分好事都。为了避免对基本表进行全表扫描，关系数据库管理系统一般都在主码上自动建立一个索引。</p>
</li>
</ul>
<h3 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h3><ul>
<li><p>定义参照完整性</p>
<p>关系模型的按照完整性在create table中用foreign key短语定义哪些列为外码，用references短语芝麻这些外码参照哪些表的主码。</p>
</li>
<li><p>参照完整性检查和违约处理</p>
<p>参照完整性将两个表中的相应元组联系起来了。因此，对被参照表和参照表进行增、删、改操作时有可能破坏参照完整性，必须进行检查以保证这两个表的相容性。</p>
<p><img src="/images/可能破坏参照完整性的情况及违约处理.jpg" alt="可能破坏参照完整性的情况及违约处理"></p>
<p>当上述的不一致发生时，系统可以采用以下策略加以处理</p>
<ol>
<li><p>拒绝(no action)执行：不允许该操作。该策略一般设置为默认策略。</p>
</li>
<li><p>级联(cascade)操作：当删除或修改被参照表中的一个元组导致与参照表的不一致时，删除或修改参照表中的所有不一致的元组。</p>
</li>
<li><p>设置为空值：当删除或修改被参照表的一个元组时造成了不一致，则将参照表中所有曹操不一致的元组的对应属性设置为空值。</p>
</li>
</ol>
</li>
</ul>
<h3 id="用户定义的完整性"><a href="#用户定义的完整性" class="headerlink" title="用户定义的完整性"></a>用户定义的完整性</h3><ul>
<li><p>属性上的约束条件</p>
<ol>
<li><p>属性上约束条件的定义</p>
<ul>
<li>列值非空(not null)</li>
<li>列值唯一(unique)</li>
<li>检查列值是否满足一个条件表达式(check短语)</li>
</ul>
</li>
<li><p>属性上约束条件的检查和违约处理</p>
<p>不满足条件拒绝执行</p>
</li>
</ol>
</li>
<li><p>元组上的约束条件</p>
<ol>
<li><p>元组上约束条件的定义</p>
<p>与属性上约束条件的定义类似，在create table语句中可以用check 短语定义元组上的约束条件，即元组级的限制。同属性值限制相比，元组级的限制可以设置不同的属性之间的取值的相互约束条件。</p>
</li>
<li><p>属性上约束条件的检查和违约处理</p>
<p>不满足条件拒绝执行</p>
</li>
</ol>
</li>
</ul>
<h3 id="完整性约束命名子句"><a href="#完整性约束命名子句" class="headerlink" title="完整性约束命名子句"></a>完整性约束命名子句</h3><ol>
<li><p>完整性约束命名子句</p>
<p>constraint &lt;完整性约束条件名&gt;&lt;完整性约束条件&gt;</p>
<p>&lt;完整性约束条件&gt;包括not null、unique、primary key、foreign key、check等</p>
</li>
<li><p>修改表中的完整性限制</p>
<p>可以使用alter table语句修改表中的完整性限制</p>
<p>alter table Student drop constraint C4</p>
</li>
</ol>
<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>在SQL中可以使用数据定义语言中的create assertion语句，通过声明性断言来指定更具一般性的约束。可以定义设计多个表或聚集操作的笔记复制的完整性约束。任何断言不为真的都拒绝执行</p>
<ol>
<li><p>创建断言的语句格式</p>
<p>create assertion &lt;断言名&gt;<check 子句></check></p>
<p>每一断言都被赋予一个名字，<check 子句>中的约束条件与where子句的条件表达式类似。</check></p>
</li>
<li><p>删除断言的语句格式</p>
<p>drop assertion&lt;断言名&gt;</p>
</li>
</ol>
<h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p>触发器是用户定义在关系表上的一类由事件驱动的特殊过程。</p>
<ul>
<li><p>定义触发器</p>
<p>触发器又叫做事件-条件-动作规则。其一般格式为</p>
<p>create trigger &lt;触发器名&gt;</p>
<p>{before|after} &lt;触发器事件&gt; on &lt;表名&gt;</p>
<p>referencing  new|old  row as &lt;变量&gt;</p>
<p>for each{row|statement}</p>
<p>[when&lt;触发条件&gt;]&lt;触发动作体&gt;</p>
<p>各部分详细说明</p>
<ul>
<li>只有表的拥有者，即创建表的用户才可以在表上创建触发器，并且一个表上只能创建一定数量的触发器。触发器的具体数量由具体的关系数据库管理系统在设计时确定。</li>
<li>触发器名：触发器名可以保护模式名，也可以不包含模式名。同以模式下，触发器名必须是唯一的，并且触发器名与表名必须在同一模式下。</li>
<li>表名：触发器只能定义在基本表上，不能定义在视图上。当基本表的数据发生变化时，将激活定义在改表上相应触发事件的触发器，因此该表也称为触发器表。</li>
<li>触发事件：出发时间可以是insert、delete或update，也可以是这几个事件的组合，如insert or delete等，还可以是update of&lt;触发列，…&gt;即进一步指名修改哪些列时激活触发器。after/before是触发的时机。after表示在触发事件的操作执行之后激活触发器；before表示在触发事件的操作执行之前激活触发器。</li>
<li>触发器类型：触发器按照所触发动作的间隔尺寸可以分为行级触发器和语句级触发器。</li>
<li>触发条件：触发器被激活时，只有当触发条件为真时触发动作体才执行，否则触发动作体不执行。如果省略when触发条件，则触发动作体在触发器激活后立即执行。</li>
<li>触发动作体：触发动作体既可以是一个匿名PL/SQL过程块，也可以是对已创建存储过程的调用。</li>
</ul>
</li>
<li><p>激活触发器</p>
<p>触发器的执行是由触发事件激活，并由数据库服务器自动执行的。一个数据表上可能定义了多个触发器，如多个before触发器、多个after触发器等，同一个表上的多个触发器激活时遵循如下的执行顺序：</p>
<ol>
<li><p>执行该表上的before触发器</p>
</li>
<li><p>激活触发器的SQL语句</p>
</li>
<li><p>执行该表上的after触发器</p>
<p>对于同一个表的多个before(after)触发器，遵循“谁先创建谁先执行”的原则。</p>
</li>
</ol>
</li>
<li><p>删除触发器</p>
<p>删除触发器的SQL语法如下：</p>
<p>drop trigger &lt;触发器名&gt; on &lt;表名&gt;</p>
<hr>
</li>
</ul>
<h2 id="第六章-关系数据理论"><a href="#第六章-关系数据理论" class="headerlink" title="第六章 关系数据理论"></a>第六章 关系数据理论</h2><h3 id="问题的提出"><a href="#问题的提出" class="headerlink" title="问题的提出"></a>问题的提出</h3><ul>
<li>由于关系模型有严格的数学理论基础，并且可以向别的数据模式转换，因此，人们就以关系模型为背景来讨论这个问题，形成了数据库逻辑设计的一个有力工具——关系数据库的规范化理论。</li>
<li>作为一个二维表，关系要符合一个最基本的条件：每一个分量必须是不可分的数据项。满足了这个条件的关系模式就属于<strong>第一范式(1NF)。</strong></li>
<li>数据依赖是一个关系内部属性于属性之间的一种约束关系。这种约束关系是通过属性间值的相等与否体现出来的数据间相关关系。</li>
<li>人们已经提出了多种类型的数据依赖，其中最重要的是<strong>函数依赖和多值依赖。</strong></li>
<li>一个好的模式应当不会发生插入异常、删除异常和更新异常，数据冗余尽可能少。</li>
</ul>
<h3 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h3><ul>
<li><p>函数依赖</p>
<p>定义：设R(U)是属性集U上的关系模式，X,Y是U的子集。若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等，则称X函数确定Y或Y函数依赖于X，记作X-&gt;Y.</p>
<p>函数依赖和别的数据依赖一样是语义范畴的概念，只能根据语义来确定一个函数依赖。</p>
<ul>
<li>X-&gt;Y,但Y不包含于X，则称X-&gt;Y是<strong>非平凡的函数依赖</strong></li>
<li>X-&gt;Y但Y包含于X，则称X-&gt;Y是平凡的函数依赖。对于任一关系模式，平凡函数依赖都是必然成立的，它不反应新的语义。若不特别声明，总是讨论非平凡的函数依赖。</li>
<li>若X-&gt;,则X称为这个函数依赖的决定属性组，也称为决定因素。</li>
<li>若X-&gt;Y,Y-&gt;X,则记作X<-->Y</--></li>
<li>若Y不函数依赖于X,则记作X!-&gt;Y</li>
<li>在R(U)中，如果X-&gt;Y，并且对于X的任何一个真子集X’，都有X’!-&gt;Y,则称Y对X<strong>完全函数依赖</strong>，记作X  F-&gt;Y</li>
<li>若X-&gt;,但Y不完全函数依赖于X，则称Y对X<strong>部分函数依赖</strong>，记作X P-&gt;Y</li>
<li>在R(U)中，如果X-&gt;Y(Y不包含于X),Y!-&gt;X,Y-&gt;Z,Z不包含于Y则称Z对X<strong>传递函数依赖</strong>。记作X 传递-&gt; Y</li>
</ul>
</li>
<li><p>码</p>
<ul>
<li>码是关系模式中的一个重要概念</li>
<li>设K为R&lt;U,F&gt;中的属性或属性组合，若K F-&gt;U,则K为R的<strong>候选码</strong>。</li>
<li>若候选码多于一个，则选定其中的一个为<strong>主码</strong></li>
<li>不包含在任何候选码中的属性称为<strong>非主属性或非码属性</strong>。最简单的情况，单个属性是码；最极端的情况，整个属性组是码，称为全码。</li>
<li>关系模式R中属性或属性组X并非R的码，但X是另一个关系模式的码，则称X是R的外部码，也称<strong>外码</strong>。</li>
</ul>
</li>
<li><p>范式</p>
<ul>
<li>关系数据库中的关系是要满足一定要求的，满足不同程度要求的为不同范式。</li>
<li>一个低一级范式的关系模式通过模式分解可以转换为若干个高一级范式的关系模式的集合，这种过程就叫规范化。</li>
</ul>
</li>
<li><p>2NF</p>
<ul>
<li><p>若R属于1NF，且每一个非主属性完全函数依赖于任何一个候选码，则R属于2NF。</p>
</li>
<li><p>一个关系模式R不属于2NF，就会产生以下几个问题：</p>
<ol>
<li>插入异常</li>
<li>删除异常</li>
<li>修改异常</li>
</ol>
</li>
</ul>
</li>
<li><p>3NF</p>
<ul>
<li>设关系模式R&lt;U,F&gt;属于1NF，若R中不存在这样的码X，属性组Y及非主属性Z使得X-&gt;Y,Y-&gt; 成立，Y!-&gt;,则称R&lt;U,F&gt;属于3NF</li>
<li>由定义可以证明，若R属于3NF,则每一个非主属性既不传递依赖于码，也不部分依赖于码。也就是说，可以证明如果R属于3NF，则必有R属于2NF</li>
</ul>
</li>
<li><p>BCNF</p>
<ul>
<li>关系模式R&lt;U,F&gt;属于1NF，若X-&gt;Y且Y不包含于X时X必含有码，则R&lt;U,F&gt;属于BCNF</li>
<li>也就是说，关系模式R&lt;U,F&gt;中，若每一个决定因素都包含码，则R&lt;U,F&gt;属于BCNF</li>
<li>由BCNF的定义可以得到结论，一个满足BCNF的关系模式由<ol>
<li>所有非主属性对每一个码都是完全函数依赖。</li>
<li>所有主属性对每一个不包含它的码也是完全函数依赖</li>
<li>没有任何属性完全函数依赖于非码的任何一组属性。</li>
</ol>
</li>
</ul>
</li>
<li><p>规范化小结</p>
<ul>
<li>规范化的基本思想是逐步消除数据依赖中不合适的部分，使模式中的各个关系模式达到某种程度的“分离”，即“一事一地”的模式设计原则。让一个关系描述一个概念，一个实体或者实体间的一种联系。若多于一个概念就把它“分离”出去。因此所谓规范化实质上是概念的单一化。</li>
<li><img src="/images/规范化过程.jpg" alt="规范化过程"></li>
<li>关系模式的规范化过程是通过对关系模式的分解来实现的，即把低一级的关系模式分解为若干个高以级的关系模式。</li>
</ul>
</li>
</ul>
<h3 id="数据依赖的公理系统"><a href="#数据依赖的公理系统" class="headerlink" title="数据依赖的公理系统"></a>数据依赖的公理系统</h3><p>下面首先讨论函数依赖的一个有效而完备的公理系统——Armstrong公理系统。</p>
<ul>
<li>定义：对于满足一组函数依赖F的关系模式R&lt;U,F&gt;,其任何一个关系r，若函数依赖X-&gt;Y都成立(即r中任意两元组t、s，若t[X]=s[X],则t[Y]=s[Y]),则称F逻辑蕴含X-&gt;Y.</li>
<li><p>Armstrong公理系统   设U为属性集总体，F是U上的一组函数依赖，于是有关系模式R&lt;U,F&gt;,对R&lt;U,F&gt;来说有以下的推理规则：</p>
<ul>
<li><p>A1自反律：若Y包含于X包含于U，则X-&gt;Y为所蕴含。</p>
</li>
<li><p>A2增广律：若X-&gt;Y为F所蕴含，且Z包含于U,则XZ-&gt;YZ为F所蕴含。</p>
</li>
<li><p>A3传递律：若X-&gt;Y及Y-&gt;Z为F所蕴含，则X-&gt;Z为F所蕴含</p>
<p><em>注意：由自反律所得到的函数依赖均是平凡的函数依赖，自反律的使用并不依赖于F。</em></p>
</li>
<li><p>定理 6.1：Armstrong推理规则是正确的。</p>
<ul>
<li>根据A1,A2,A3这三条推理规则可以得到下面三条很有用的推理规则<ol>
<li>合并规则：由X-&gt;Y,X-&gt;Z,有X-&gt;YZ</li>
<li>伪传递规则：X-&gt;Y,WY-&gt;Z,有XW-&gt;Z</li>
<li>分解规则：由X-&gt;Y及Z包含于Y，有X-&gt;Z</li>
</ol>
</li>
<li>定义6.12 在关系模式R&lt;U,F&gt;中为F所逻辑蕴含的函数依赖的全体叫作F的闭包，记为F+.</li>
<li>人们把自反律、传递律和增广律称为Armstrong公理系统。Armstrong公理系统是有效的、完备的。Armstrong公理的有效性指的是：由F出发根据Armstrong公理推导出来的每一个函数依赖一定在F+中；完备性指的是F+中的每一个函数依赖，必定可以由F出发根据Armstrong公理推导出来。</li>
</ul>
</li>
<li><p>定义6.13 设F为属性集U上的一组函数依赖，X、Y包含于U，XF+ = {A|X-&gt;A能由F根据Armstrong公理导出}，XF+称为属性集X关于函数依赖集F的闭包。</p>
</li>
<li><p>引理 6.2：设F为属性集U上的一组函数依赖，X,Y包含于U，X-&gt;Y能由F根据Armstrong公理导出的充分必要条件是Y包含于XF+。</p>
</li>
<li><p>定理6.2 Armstrong公理系统是有效的、完备的。</p>
</li>
<li><p>如果函数依赖集F满足下列条件，则称F为一个极小函数依赖集，亦称为最小依赖集或最小覆盖。</p>
<ol>
<li>F中任一函数依赖右部仅含有一个属性。</li>
<li>F中不存在这样的函数依赖X-&gt;A,使得F与F-{X-&gt;A}等价</li>
<li>F中不存在这样的函数依赖X-&gt;A,X有真子集Z使得F-{X-&gt;A}并{Z-&gt;A}与F等价。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="模式的分解"><a href="#模式的分解" class="headerlink" title="模式的分解"></a>模式的分解</h3><ul>
<li><p>模式分解的三个定义</p>
<ul>
<li><p>分解具有<strong>无损连接性</strong></p>
</li>
<li><p>分解要<strong>保持函数依赖</strong></p>
</li>
<li><p>分解既要保持函数依赖，又要无损连接性</p>
<p>这三个定义是实行分解的三条不同的准则。按照不同的分解准则，模式所能达到的分离程度各不相同，各种范式就是对分离程度的测度。</p>
</li>
</ul>
</li>
<li><p>模式分解的算法</p>
<ul>
<li>关于模式分解保持函数依赖，那么模式分离总可以达到3NF，但不一定能达到BCNF</li>
<li>若要求分解既保持函数依赖，又具有无损连接性，可以达到3NF，但不一定能达到BCNF</li>
<li>若要求分解具有无损连接性，那么一定可达到4NF</li>
<li>算法6.3(合成法)转换为3NF的保持函数依赖的分解(课本P198 6.4.3)</li>
<li>算法6.4 转换为3NF既有无损连接性又保持函数依赖的分解(课本P198 6.4.3)</li>
<li>算法6.5(分解法)转换为BCNF的无损连接分解 (课本P198 6.4.3)</li>
</ul>
</li>
</ul>
<h2 id="第七章-数据库设计"><a href="#第七章-数据库设计" class="headerlink" title="第七章 数据库设计"></a>第七章 数据库设计</h2><h3 id="数据库设计概述"><a href="#数据库设计概述" class="headerlink" title="数据库设计概述"></a>数据库设计概述</h3><p>数据库设计，广义的讲，是数据库及其应用系统的设计，即设计整个数据库应用系统；狭义的讲，是设计数据库本身，即设计数据库的各级模式并建立数据库，这是数据库应用系统设计的一部分。</p>
<p>下面给出数据库设计的一般定义.</p>
<p>数据库设计是指对于一个给定的应用环境，构造(设计)优化的数据库逻辑模式和物理结构，并据此建立数据库及其应用系统，使之能够有效的存储和管理数据，满足各种用户的应用需求，包括信息管理要求和数据操作要求。</p>
<ul>
<li><p>数据库设计的特点</p>
<ol>
<li><p>数据库减少的基本规律</p>
<p>“三分技术，七分管理，十二分基础数据”是数据库设计的特点之一。</p>
<p>“十二分基础数据”则强调了数据的手机、整理、组织和不断更新是数据库建设中的重要环节。</p>
</li>
<li><p>结构(数据)设计和行为(处理)设计相结合</p>
<p>数据库设计应该和应用系统设计相结合。也就是说，整个设计过程中要把数据库结构设计和对数据的处理设计密切结合起来。这是数据库设计的特点之二。</p>
</li>
</ol>
</li>
<li><p>数据库设计犯法</p>
<p>它要求从事数据库设计的专业人员具备多方面的知识和技术。主要包括：</p>
<ul>
<li>计算机的基础知识</li>
<li>程序设计的方法和技巧</li>
<li>数据库的基本知识</li>
<li>数据库设计技术</li>
<li>应用领域的知识</li>
</ul>
</li>
<li><p>数据库设计的基本步骤</p>
<ol>
<li><p>需求分析阶段</p>
</li>
<li><p>概念结构设计阶段</p>
</li>
<li><p>逻辑结构设计阶段</p>
</li>
<li><p>物理结构设计阶段</p>
</li>
<li><p>数据库实施阶段</p>
</li>
<li><p>数据库运行和维护阶段</p>
<p><img src="/images/数据库设计步骤.jpg" alt="数据库设计步骤"></p>
</li>
</ol>
</li>
<li><p>数据库设计过程中的各级模式</p>
<p><img src="/images/数据库的各级模式.jpg" alt="数据库的各级模式"></p>
</li>
</ul>
<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><ul>
<li><p>需求分析的任务</p>
<p>调查的重点是“数据”和“处理”，通过调查、收集与分析，获得用户对数据库的如下要求：</p>
<ol>
<li>信息要求。指用户需要从数据库中获得信息的内容与性质。由信息要求可以导出数据要求，即在数据库中需要存储哪些数据。</li>
<li>处理要求。指用户要完成的数据处理功能，对处理性能的要求。</li>
<li>安全性与完整性要求。</li>
</ol>
</li>
<li><p>需求分析分析的方法</p>
<p>调查用户需求的具体步骤是：</p>
<ol>
<li>调查组织机构情况。</li>
<li>调查各部门的业务活动情况。</li>
<li>在熟悉业务活动的基础上，协助用户明确对新系统的各种要求，包括信息要求、处理要求、安全性与完整性要求，这是调查的又一个重点。</li>
<li>确定新系统的边界。</li>
</ol>
<p>调查常用的方法：</p>
<ol>
<li>跟班作业。</li>
<li>开调查会</li>
<li>请专人介绍。</li>
<li>询问。</li>
<li>设计调查表请用户填写</li>
<li>查阅记录</li>
</ol>
</li>
<li><p>数据字典</p>
<p>数据字典是进行详细的数据收集和数据分析所获得的主要成果。它是关于数据库中数据的描述，即元数据，而不是数据本身。数据字典是在需求分析阶段建立，在数据库设计过程中不断修改，充实，完善的。它在数据库设计中占有很重要的地位。</p>
<ol>
<li><p>数据项</p>
<p>数据项是不可再分的数据单位。对数据项的描述通常包括以下内容。</p>
<p>数据项描述 = {数据项名，数据项含义说明，别名，数据类型，长度，取值范围，取值含义，与其他数据项的逻辑关系，数据项之间的联系}</p>
<p>其中，“取值范围”、“与其他数据项的逻辑关系”(如该数据项等于其他几个数据项的和、该数据项值等于另一数据项的值等)定义了数据的完整性约束条件，是设计数据检验功能的依据。</p>
</li>
<li><p>数据结构</p>
<p>数据结构反映了数据之间的组合关系。一个数据结构可以由若干给数据项组成，也可以由若干个数据结构组成，或由若干个数据项和数据结构混合组成。对数据结构的描述通常包括以下内容：</p>
<p>数据结构描述 = {数据结构名，含义说明，组成：{数据项或数据结构}}</p>
</li>
<li><p>数据流</p>
<p>数据流是数据结构在系统内传输的路径。对数据流的描述通常包括以下内容：</p>
<p>数据流描述 = {数据流名，说明，数据流来源，数据流去向，组成：{数据结构}，平均流量，高峰期流量}</p>
<p>其中，“数据流来源”是说明该数据流来自哪个过程；“数据流去向”是说明该数据流将导哪个过程取；“平均流量”是指在单位时间(每天、每周、每月等)里的传输次数；“高峰期流量”则是指在高峰时期的数据流量。</p>
</li>
<li><p>数据存储</p>
<p>数据存储是数据结构停留或保存的地方，也是数据流的来源和去向之一。它可以是手工文档或手工凭单，也可以是计算机文档，对数据存储的描述通常包括以下内容：</p>
<p>数据存储描述 = {数据存储名，说明，编号，输入的数据流，输出的数据流，组成：{数据结构}，数据量，存储频率，存取方式}</p>
<p>其中，“存取频度”指每小时、每天或每周存取次数及每次存取的数据量等信息；</p>
</li>
<li><p>处理过程</p>
<p>处理过程的具体处理逻辑一般用判定表或判定树来描述。数据字典中只需要描述处理过程的说明信息即可，通常包括以下内容：</p>
<p>处理过程描述 = {处理过程名，说明，输入：{数据流}，输出：{数据流}，处理：{简要说明}}</p>
<p>最后要强调两点：</p>
<ol>
<li>需求分析阶段的一个重要而困难的任务是收集将来应用所涉及的数据，设计人员应充分考虑到可能的扩充和改变，使设计易于更改、系统易于扩充。</li>
<li>必须强调用户的参与，这是数据库应用系统设计的特点。</li>
</ol>
</li>
</ol>
</li>
</ul>
<h3 id="概念结构设计"><a href="#概念结构设计" class="headerlink" title="概念结构设计"></a>概念结构设计</h3><ul>
<li><p>概念模型</p>
<p>概念模型的主要特点是：</p>
<ol>
<li>能真实、充分的反映现实世界，包括事物和事物之间的联系，能满足用户对数据的处理要求，是现实世界的一个真实模型。</li>
<li>易于理解，可以用它和不熟悉计算机多用户交换意见。用户的积极参与是数据库设计成功的关键。</li>
<li>易于更改，当应用环境和应用要求改变时容易对概念模型修改和扩充。</li>
<li>易于向关系、网状、层次等各种数据模型转换。</li>
</ol>
</li>
<li><p>E-R模型</p>
<ol>
<li><p>实体之间的联系</p>
<ul>
<li>两个实体型之间的联系：一对一联系(1:1)、一对多联系(1:n)、多对多联系(m:n)</li>
<li>两个以上的实体型之间的联系：两个以上的实体型之间也存在着一对一、一对多和多对多联系。</li>
<li>单个实体型内的联系：同一个实体集内的各实体之间也可以存在一对一、一对多和多对多的联系。</li>
</ul>
<p>一般的，把参与联系的实体型的数目称为联系的度。两个实体型之间的联系度为2，也称为二元联系；三个实体型之间的联系度为3，称为三元联系；N个实体型之间的联系度为N，也成为N元联系。</p>
</li>
<li><p>E-R图</p>
<p>E-R图提供了表示实体型、属性和联系的方法。</p>
<ol>
<li>实体型用矩形表示，矩形框内写明实体名。</li>
<li>属性用椭圆表示，并用无向边将其与相应的实体型连接起来</li>
<li>联系用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体型来南京起来，同时在无向边旁标上联系的类型(1：1、1：n、m:n)</li>
</ol>
</li>
<li><p>一个实例</p>
<p><img src="/images/工厂物资管理E-R图.jpg" alt="工厂物资管理E-R图"></p>
</li>
</ol>
</li>
<li><p>扩展的E-R模型</p>
<ol>
<li><p>ISA联系</p>
<p>用E-R方法构建一个项目的模型时，经常会遇到某些实体型的子类型。例如，研究生和本科生是学生的子类型，学生是父类型。这种父类-子类联系称为ISA联系，表示“is a”的语义。联系用三角形来表示。</p>
<ol>
<li><p>分类属性</p>
<p>根据分类属性的值把父实体型中的实体分派到子实体型中。</p>
<p><img src="/images/学生的两个子类型和分类属性.jpg" alt="学生的两个子类型和分类属性"></p>
</li>
<li><p>不相交约束与可重叠约束</p>
<p>不相交约束描述父类中的一个实体不能同时属于多个子类中的实体集，即一个父类中的实体最多属于一个子类实体集，用ISA联系三角形符号内加一个叉号“X“来表示。</p>
<p><img src="/images/子类不相交约束.jpg" alt="子类不相交约束"></p>
</li>
<li><p>完备性约束</p>
<p>完备性约束描述父类中的一个实体是否必须是某一个子类中的实体，如果是，则叫做完全特化，否则叫做部分特化。完全特化用父类到子类的双线连接来表示，单线连接则表示部分特化。</p>
</li>
</ol>
</li>
<li><p>基数约束</p>
<p>基数约束是对实体之间一对一，一对多和多对多来呢西的细化。参与联系的每个实体型用基数约束来说明实体型中的任何一个实体可以在联系中出现的最少次数和最多次数。</p>
<p>约束用一个数对min..max表示，0&lt;=min&lt;=max。例如，0..1、1..3、1..<em>(\</em>代表无穷大)。min=1的约束叫做强制参与约束，即被施加基数约束的实体型中的每个实体都要参与联系；min=0的约束叫做非强制参与约束，被世家基数约束的实体型中的实体可以出现在联系中，也可以不出现在联系中。</p>
<p><img src="/images/一对一、一对多、多对多的基数约束示例.jpg" alt="一对一、一对多、多对多的基数约束示例"></p>
</li>
</ol>
</li>
</ul>
<ol start="3">
<li><p>Part-of联系</p>
<p>Part-of联系即部分联系，它表明某个实体型是另外一个实体型的一部分。非独占的Part-of联系可以通过基数约束来表达(非强制参与联系)。与非独占联系相反，还有一种Part-of联系是独占联系。即整体实体如果被破坏，部分实体不能存在，在E-R图中用弱实体类型和识别联系来表示独占联系。<strong>如果一个实体型的存在依赖于其他实体型的存在，则这个实体型叫做弱实体型，否则叫做强实体型。</strong>如果不能从一个实体型的属性中找出可以作为码的属性，则这个实体型是弱实体型。在E-R图中用双矩形表示弱实体型，用双菱形表示识别联系。</p>
<p><img src="\images\弱实体型.jpg" alt="弱实体型"></p>
</li>
</ol>
<ul>
<li><p>概念结构设计</p>
<ol>
<li><p>实体与属性的划分原则</p>
<p>在调整中遵循的一条原则是：为了简化E-R图的处置，现实世界的事物能作为属性对待的尽量作为属性对待。</p>
<p>符合什么条件的事物可以作为属性对待，可以给出两条准则：</p>
<ol>
<li><strong>作为属性，不能再具有需要描述的性质</strong>，即属性必须是不可分的数据项，不能包含其他属性。</li>
<li><strong>属性不能与其他实体具有联系</strong>，即E-R图中所表示的联系是实体之间的联系。</li>
</ol>
</li>
<li><p>E-R图的集成</p>
<p>E-R图的集成一般需要两步走:</p>
<ul>
<li><p>合并。解决各分E-R图之间的冲突，将分E-R图合并起来生成初步E-R图。</p>
</li>
<li><p>修改和重构。消除不必要的冗余，生成基本E-R图。</p>
<ol>
<li><p>合并E-R图生成初步E-R图</p>
<p>合理消除各E-R图的冲突是合并E-R如的主要工作与关键所在。</p>
<ul>
<li><p>属性冲突</p>
<ul>
<li>属性域冲突，即属性值的类型、取值范围或取值集合不同</li>
<li>属性取值单位冲突</li>
</ul>
</li>
<li><p>命名冲突</p>
<ul>
<li>同名异义，即不同意义的对象在不同的局部应用中具有相同的名字</li>
<li>异名同义，即同一意义的对象在不同的局部应用中具有不同的名字</li>
</ul>
</li>
<li><p>结构冲突</p>
<p>结构冲突主要包含以下三类冲突：</p>
<ul>
<li>同一对象在不同应用中具有不同的抽象。</li>
<li>同一实体在不同子系统的E-R图中所包含的属性个数和数学排列次序不完全相同。</li>
<li>实体间的联系在不同的E-R图中为不同的类型。</li>
</ul>
</li>
</ul>
</li>
<li><p>消除不必要的冗余，设计基本E-R图</p>
<p>在初步E-R图中可能存在一些冗余的数据和实体间冗余的联系。</p>
<ul>
<li><p>消除冗余主要采用分析方法，即以数据字典和数据流图为依据，根据数据字典中关于数据项之间逻辑关系的说明来消除冗余。</p>
</li>
<li><p>除分析方法外，还可以用规范化理论来消除冗余。在规范化理论中，函数依赖的概念提供了消除冗余联系的形式化工具。具体方法如下：</p>
<ol>
<li><p>确定分E-R图实体之间的数据依赖。</p>
</li>
<li><p>求FL的最小覆盖GL，差集为D=FL-GL。</p>
<p>由于规范化理论受到泛关系假设的限制，应注意下面两个问题：</p>
<ul>
<li>冗余的联系一定在D中，而D中的联系不一定是冗余的。</li>
<li>当实体之间存在多种联系时，要将实体之间的联系在形式上加以区分。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="逻辑结构设计"><a href="#逻辑结构设计" class="headerlink" title="逻辑结构设计"></a>逻辑结构设计</h3><p>逻辑结构设计的任务就是把概念呢结构设计阶段设计好的基本E-R图转换为与选用数据库管理系统产品所支持的数据模型相符合的逻辑结构。</p>
<ul>
<li><p>E-R图向关系模型的转换</p>
<p>下面介绍转换的一般原则。<strong>一个实体型转换为一个关系模式</strong>，关系的属性就是实体的属性，关系的码就是实体的码。对于实体型间的联系有以下不同的情况：</p>
<ol>
<li>一个1:1联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并。</li>
<li>一个1:n 联系可以转换为一个独立的关系模式，也可以与n端对应的关系模式合并。</li>
<li>一个m:n联系转换为一个关系模式，与该联系相连的各实体的码以及联系本身的数据均转换为关系的属性，各实体的码组成关系的码或关系码的一部分。</li>
<li>三个或三个以上实体间的一个多元联系可以转换为一个关系模式。</li>
<li>具有相同码的关系模式可合并。</li>
</ol>
</li>
<li><p>数据模型的优化</p>
<p>数据库逻辑设计的结果不是唯一的。关系数据模型的优化通常以规范化理论为指导，方法为：</p>
<ol>
<li><p>确定数据依赖</p>
</li>
<li><p>对于各个关系模式之间的数据依赖进行极小化除了，消除冗余的联系</p>
</li>
<li><p>按照数据依赖的理论对关系模式逐一进行分析，考察是否存在部分函数依赖、传递函数依赖、多值依赖等，确定各关系模式分别属于第几范式。</p>
</li>
<li><p>根据需求分析阶段得到的处理要求分析对于这样的应用环境这些模式是否合适，确定是否要对某些模式进行合并或分解。</p>
<p>必须注意的是，并不是规范化程度越高的关系就越优。</p>
</li>
<li><p>对关系模式进行必要分解，提高数据操作效率和存储空间利用率。常用的两种分解方法是水平分解和垂直分解。</p>
</li>
</ol>
</li>
<li><p>设计用户子模式</p>
<p>由于用户外模式与模式是相对独立的，因此在定义用户外模式时可以注重考虑用户的习惯与方便。具体包括以下几个方面：</p>
<ol>
<li>使用更符合用户习惯的别名。</li>
<li>可以对不同级别的用户定义不同的视图，以保证系统的安全性。</li>
<li>简化用户对系统的使用。</li>
</ol>
</li>
</ul>
<h3 id="物理结构设计"><a href="#物理结构设计" class="headerlink" title="物理结构设计"></a>物理结构设计</h3><p>为一个给定的逻辑数据模型选取一个最适合应用要求的物理结构的过程，就是数据库的物理设计。</p>
<p>数据库的物理设计通常分为两步：</p>
<ol>
<li>确定数据库的物理结构，在关系数据库中主要指存取方法和存储结构。</li>
<li>对物理结构进行评价，评价的重点是时间和空间效率。</li>
</ol>
<ul>
<li><p>数据库物理设计的内容和方法</p>
<p>对于数据库查询事务，需要得到如下信息：</p>
<ul>
<li>查询的关系</li>
<li>查询条件所涉及的属性</li>
<li>连接条件所涉及的属性</li>
<li>查询的投影属性</li>
</ul>
<p>对于数据更新事务，需要得到如下信息：</p>
<ul>
<li>被更新的关系</li>
<li>每个关系上的更新操作条件所涉及的属性</li>
<li>修改操作要改变的属性值</li>
</ul>
<p>通常关系数据库物理涉及的内容主要包括为关系模式选择存取方法，以上设计关系、索引等数据库文件的物理存储结构。</p>
</li>
<li><p>关系模式存取方法选择</p>
<p>存取方法是快速存取数据库中数据的基数。数据库管理系统一般提供多种存取方法。常用的存取方法为索引方法和聚簇方法。</p>
<ol>
<li><p>B+树索引存取方法的选择</p>
</li>
<li><p>hash索引存取方法的选择</p>
</li>
<li><p>聚簇存取方法的选择</p>
<p>为了提高某个属性(或属性组)的查询速度，把这个或这些属性上具有相同值的元组集中存放在连续的物理块中称为聚簇。该属性(或属性组)称为聚簇码。</p>
</li>
</ol>
</li>
<li><p>确定数据库的存储结构</p>
<ol>
<li>确定数据的存放位置</li>
<li>确定系统配置</li>
</ol>
</li>
<li><p>评价物理结构</p>
</li>
</ul>
<h3 id="数据库的实施和维护"><a href="#数据库的实施和维护" class="headerlink" title="数据库的实施和维护"></a>数据库的实施和维护</h3><ul>
<li><p>数据的载入和应用程序的调试</p>
<p>数据库应用程序的设计应该与数据库设计同时进行，因此在组织数据入库的同时还要调试应用程序。</p>
</li>
<li><p>数据库的试运行</p>
<p>这里特别要强调两点。第一上面已经讲到组织数据入库是十分费时、费力的事，如果试运行后还要修改数据库的设计，还要重新组织数据入库。因此应分期分批的组织数据入库，先输入小批量数据做调试用，带试运行基本合格后再大批量输入数据，逐步增加数据量，组别完成评价。第二，再数据库试运行阶段，由于系统还不稳定，硬、软件故障随时都可能发生；而系统的操作人员对新系统还不熟悉，误操作也不可避免，因此要做好数据库的转储和恢复工作。</p>
</li>
<li><p>数据库的运行和维护</p>
<ol>
<li>数据库的转储和恢复</li>
<li>数据库的安全性、完整性控制</li>
<li>数据库性能的监督分析和改造</li>
<li>数据库的重组织与重构造</li>
</ol>
</li>
</ul>
<hr>
<h2 id="数据库编程"><a href="#数据库编程" class="headerlink" title="数据库编程"></a>数据库编程</h2><p>未完待续。。。</p>
<p>—&gt;                    </p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">24</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  


  
    <script src="/js/cursor/cherry.js"></script>
  
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/z16.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body>
</html>



