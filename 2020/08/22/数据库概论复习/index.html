<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="版权所有  数据库第一章 绪论数据库系统概述 数据库四个基本概念：数据库系统(DBS)包括 数据库管理系统(DBMA)，数据库管理员(DBA)，数据库(DB)。 数据管理技术的产生和发展：数据管理技术经历了人工管理、文件管理、数据库系统三个阶段。      数据库系统的特点   数据结构化 共享性高、冗余度低且易扩充 数据独立性高：数据独立性、物理独立性、逻辑独立性 数据由数据库管理系统统一管理和">
<meta property="og:type" content="article">
<meta property="og:title" content="数据库概论复习">
<meta property="og:url" content="http://zehwakaka.github.io/2020/08/22/数据库概论复习/index.html">
<meta property="og:site_name" content="Alice&#39;s blog">
<meta property="og:description" content="版权所有  数据库第一章 绪论数据库系统概述 数据库四个基本概念：数据库系统(DBS)包括 数据库管理系统(DBMA)，数据库管理员(DBA)，数据库(DB)。 数据管理技术的产生和发展：数据管理技术经历了人工管理、文件管理、数据库系统三个阶段。      数据库系统的特点   数据结构化 共享性高、冗余度低且易扩充 数据独立性高：数据独立性、物理独立性、逻辑独立性 数据由数据库管理系统统一管理和">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://zehwakaka.github.io/images/数据库系统的三级模式结构.jpg">
<meta property="og:image" content="http://zehwakaka.github.io/images/参照关系.jpg">
<meta property="og:image" content="http://zehwakaka.github.io/images/传统集合运算举例.jpg">
<meta property="og:image" content="http://zehwakaka.github.io/images/连接.jpg">
<meta property="og:image" content="http://zehwakaka.github.io/images/数据库对象命名机制的层次结构.jpg">
<meta property="og:image" content="http://zehwakaka.github.io/images/数据类型1.jpg">
<meta property="og:image" content="http://zehwakaka.github.io/images/数据类型2.jpg">
<meta property="og:image" content="http://zehwakaka.github.io/images/相关子查询.jpg">
<meta property="og:image" content="http://zehwakaka.github.io/images/any与all和聚集函数对应关系表.jpg">
<meta property="og:image" content="http://zehwakaka.github.io/images/目标列表达式的可选格式.jpg">
<meta property="og:image" content="http://zehwakaka.github.io/images/聚集函数的一般格式.jpg">
<meta property="og:image" content="http://zehwakaka.github.io/images/where子句的条件表达式的可选格式.jpg">
<meta property="og:image" content="http://zehwakaka.github.io/images/逻辑运算符真值表.jpg">
<meta property="og:image" content="http://zehwakaka.github.io/images/信息安全标准的发展简史.jpg">
<meta property="og:image" content="http://zehwakaka.github.io/images/安全级别划分.jpg">
<meta property="og:image" content="http://zehwakaka.github.io/images/CC评估保证级(EAL">
<meta property="og:image" content="http://zehwakaka.github.io/images/计算机系统的安全模型.jpg">
<meta property="og:image" content="http://zehwakaka.github.io/images/关系数据库系统中的存取权限.jpg">
<meta property="og:image" content="http://zehwakaka.github.io/images/权限与可执行的操作对照表.jpg">
<meta property="og:image" content="http://zehwakaka.github.io/images/可能破坏参照完整性的情况及违约处理.jpg">
<meta property="og:image" content="http://zehwakaka.github.io/images/规范化过程.jpg">
<meta property="og:image" content="http://zehwakaka.github.io/images/数据库设计步骤.jpg">
<meta property="og:image" content="http://zehwakaka.github.io/images/数据库的各级模式.jpg">
<meta property="og:image" content="http://zehwakaka.github.io/images/工厂物资管理E-R图.jpg">
<meta property="og:image" content="http://zehwakaka.github.io/images/学生的两个子类型和分类属性.jpg">
<meta property="og:image" content="http://zehwakaka.github.io/images/子类不相交约束.jpg">
<meta property="og:image" content="http://zehwakaka.github.io/images/一对一、一对多、多对多的基数约束示例.jpg">
<meta property="og:image" content="http://zehwakaka.github.io/images/弱实体型.jpg">
<meta property="og:updated_time" content="2020-08-28T15:43:49.649Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="数据库概论复习">
<meta name="twitter:description" content="版权所有  数据库第一章 绪论数据库系统概述 数据库四个基本概念：数据库系统(DBS)包括 数据库管理系统(DBMA)，数据库管理员(DBA)，数据库(DB)。 数据管理技术的产生和发展：数据管理技术经历了人工管理、文件管理、数据库系统三个阶段。      数据库系统的特点   数据结构化 共享性高、冗余度低且易扩充 数据独立性高：数据独立性、物理独立性、逻辑独立性 数据由数据库管理系统统一管理和">
<meta name="twitter:image" content="http://zehwakaka.github.io/images/数据库系统的三级模式结构.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://zehwakaka.github.io/2020/08/22/数据库概论复习/">





  <title>数据库概论复习 | Alice's blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="default">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Alice's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">郑</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://zehwakaka.github.io/2020/08/22/数据库概论复习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Alice's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">数据库概论复习</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-08-22T15:10:42+08:00">
                2020-08-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><em>版权所有</em></p>
<hr>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h2><h3 id="数据库系统概述"><a href="#数据库系统概述" class="headerlink" title="数据库系统概述"></a>数据库系统概述</h3><ul>
<li>数据库四个基本概念：数据库系统(DBS)包括 数据库管理系统(DBMA)，数据库管理员(DBA)，数据库(DB)。</li>
<li>数据管理技术的产生和发展：数据管理技术经历了人工管理、文件管理、数据库系统三个阶段。     </li>
<li>数据库系统的特点</li>
</ul>
<ol>
<li>数据结构化<ol start="2">
<li>共享性高、冗余度低且易扩充</li>
<li>数据独立性高：数据独立性、物理独立性、逻辑独立性</li>
<li>数据由数据库管理系统统一管理和控制</li>
</ol>
</li>
</ol>
<h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><ul>
<li><p>据模型也是一种模型，它是对现实世界数据特征的抽象。数据模型是数据库系统的核心和基础。</p>
</li>
<li><p>两类数据模型：第一类是概念模型，第二类是逻辑模型和物理模型。 首先将现实世界抽象为信息世界，然后将信息世界转换为机器世界。</p>
</li>
<li><p>概念模型：概念模型最常用的方法是实体-联系方法，E-R方法也称为E-R模型</p>
<ol>
<li>实体：客观存在并可互相区别的事物称为实体。</li>
<li>属性：实体所具有的某一特性称为属性。</li>
<li>码：唯一标识实体的属性集称为码。</li>
<li>实体型：用实体名及其属性名集合来抽象和刻画同类实体，称为实体型。</li>
<li>实体集：同一类型实体的集合称为实体集</li>
<li>联系：实体之间的联系通常是指不同实体集之间的联系。实体之间的联系有一对一、一对多和多对多等多种类型。<br>数据模型的组成要素</li>
</ol>
</li>
<li><p>数据结构：数据结构描述数据库的组成对象以及对象之间的联系。</p>
</li>
<li><p>数据操作：数据操作是指对数据库中各种对象（型）的实例（值）允许执行的操作的集合，包括操作及有关的操作规则。</p>
</li>
<li><p>数据的完整性约束条件：数据的完整性约束条件是一组完整性规则。</p>
</li>
<li><p>常用的数据模型</p>
<ol>
<li><p>层次模型</p>
</li>
<li><p>网状模型</p>
</li>
<li><p><strong>关系模型</strong></p>
<ol>
<li><p>关系模型的数据结构</p>
<ul>
<li><p>关系：一个关系对应通常说的一张表</p>
</li>
<li><p>元组：表中的一行即为一个元组</p>
</li>
<li><p>属性：表中的一列即为一个属性，给每一个属性起一个名称即属性名</p>
</li>
<li><p>码：也称码键。表中的某个属性组，它可以唯一确定一个元组</p>
</li>
<li><p>域：域是一组具有相同数据类型的值的集合</p>
</li>
<li><p>分量：元组中的一个属性值</p>
<p><em>关系模型要求关系必须是规范的，关系的每一个分量必须是一个不可分的数据项</em></p>
</li>
</ul>
</li>
<li><p>关系模型的数据操纵与完整性约束</p>
<p><em>关系模型中的数据操作是集合操作，操作对象和操作结果都是关系。关系模型把存取路径向用户隐蔽起来</em></p>
</li>
<li><p>关系模型的优缺点</p>
<ul>
<li>关系模型与格式化模型不同，他是建立在严格的数学基础上的。</li>
<li>关系模型的概念单一</li>
<li>关系模型的存取路径对用户透明</li>
</ul>
</li>
</ol>
</li>
<li><p>面向对象数据模型</p>
</li>
<li><p>对象关系数据模型</p>
</li>
<li><p>半结构化数据模型</p>
</li>
</ol>
</li>
</ul>
<h3 id="数据库系统的结构"><a href="#数据库系统的结构" class="headerlink" title="数据库系统的结构"></a>数据库系统的结构</h3><ul>
<li><p>数据库系统模式的概念：在数据模型中有“型”和“值”的概念。型是指对某一类数据的结构和属性的说明，值是型的一个具体赋值。</p>
<p><em>模式是相对稳定的，而实例是相对变动的。</em></p>
</li>
<li><p><strong>数据库系统的三级模式结构图：</strong></p>
</li>
<li><p><img src="/images/数据库系统的三级模式结构.jpg" alt="数据库系统的三级模式结构" style="zoom:25%;transform:rotate(-90deg);">    </p>
</li>
<li><p><strong>三级模式</strong></p>
<ol>
<li><p>模式：模式也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。</p>
</li>
<li><p>外模式：外模式也称子模式或用户模式，它是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。</p>
</li>
<li><p>内模式：内模式也称存储模式，一个数据库只有一个内模式。它是数据物理结构和存储方式的描述，是数据在数据库内部的组织方式。</p>
</li>
</ol>
</li>
<li><p><strong>数据库的二级映像功能与数据独立性</strong></p>
<ol>
<li><p>外模式/模式映像：当模式改变时(例如增加新的关系、新的属性、改变属性的数据类型等)，由数据库管理员对各个外模式/模式的映像作相应改变，可以使外模式保持不变。应用程序是依据数据的外模式编写的，从而应用程序不必修改，<strong>保证了数据与程序的逻辑独立性，简称数据的逻辑独立性。</strong></p>
</li>
<li><p>模式/内模式映像：当数据库的存储结构改变时(例如选用了另一种存储结构)，由数据库管理员对模式/内模式映像作相应改变，可以使模式保持不变，从而应用程序也不必改变。<strong>保证了数据与程序的物理独立性，简称数据的物理独立性。</strong></p>
<p><em>数据与程序之间的独立性使得数据的定义和描述可以从应用程序中分离出去。另外，由于数据的存取由数据库管理系统管理，从而简化了应用程序的编制，大大减少了应用程序的维护和修改。</em></p>
</li>
</ol>
</li>
<li><p>据库系统的组成</p>
<ul>
<li><p>包括硬件平台及数据库、软件、人员。</p>
</li>
<li><p>数据库管理员(DBA)职责：</p>
<ul>
<li>决定数据库中的信息内容和结构</li>
<li>决定数据库的存储结构和存储策略</li>
<li>定义数据的安全性要求和完整性约束条件</li>
<li>监控数据库的使用和运行</li>
<li>数据库的改进和重组、重构</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="第二章-关系数据库"><a href="#第二章-关系数据库" class="headerlink" title="第二章 关系数据库"></a>第二章 关系数据库</h2><h3 id="关系数据结构及形式化定义"><a href="#关系数据结构及形式化定义" class="headerlink" title="关系数据结构及形式化定义"></a>关系数据结构及形式化定义</h3><ul>
<li><p>关系</p>
<ol>
<li><p>域：域是一组具有相同数据类型的值的集合。</p>
</li>
<li><p><strong>笛卡尔积</strong>：笛卡尔积定义，给定一组域D1,D2,…,Dn，允许其中某些域是相同的，D1,D2,…,Dn的笛卡尔积为</p>
<p>​                                                        <em>D1\</em>D2*…*Dn = {(d1,d2,…,dn)|di属于Di,i=1,2,…,n}*<br>​                           其中，每一个元素(d1,d2,…,dn)叫作一个n元组，或简称元组。元素中的每一个值di叫作一个分量。<br>​                           一个域允许的不同取值个数称为这个域的基数。</p>
</li>
<li><p><strong>关系：</strong>定义，D1*D2*…*Dn的子集叫做在域D1,D2,…,Dn上的关系，表示为R(D1,D2,…,Dn)这里R表示关系的名字,n是关系的<strong>目或度</strong>。当n = 1时，称该关系为一元关系。当n = 2时，称该关系为二元关系。</p>
<ul>
<li><p>某一属性组的值能唯一的标识一个元组，而其子集不能，则称该属性组为<strong>候选码</strong>。若一个关系有多个候选码，则选定其中一个为<strong>主码</strong>。候选码的诸属性称为<strong>主属性</strong>。不包含在任何候选码中的属性称为<strong>非主属性或非码属性</strong>。在最简单的情况下，候选码只包含一个属性。在最极端的情况下，关系模式的所有属性是这个关系模式的候选码，称为<strong>全码</strong>。</p>
</li>
<li><p>关系可以有三种类型：基本关系(通常又称为基本表或基表)、查询表和视图表。</p>
</li>
<li><p>关系的性质：</p>
<ol>
<li><p>列是同质的，即每一列中的分量是同一类型的数据，来自同一个域。</p>
</li>
<li><p>不同的列可出自同一个域，称其中的每一列为一个属性，不同的属性要给予不同的属性名。</p>
</li>
<li><p>列的顺序无所谓，即列的次序可以任意交换。</p>
</li>
<li><p>任意两个元组的候选码不能取相同的值。</p>
</li>
<li><p>行的顺序无所谓，即行的次序可以任意交换。</p>
</li>
<li><p>分量必须取原子值，即每一个分量都必须是不可分的数据项</p>
<p><strong>这些规范条件中最基本的一条就是，关系的每一个分量必须是一个不可分的数据项。规范化的关系简称为范式(NF)。</strong></p>
</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>关系模式</p>
<ul>
<li>关系的描述称为关系模式。它可以形式化的表示为R(U,D,DOM,F)。其中R为关系名，U为组成改关系的属性名集合，D为U中属性所来自的域，DOM为属性向域的映像集合，F为属性间数据的依赖关系集合。</li>
</ul>
</li>
<li><p>关系数据库</p>
<ul>
<li>关系数据库也有型和值之分。关系数据库的型也称为关系数据库模式，是对关系数据库的描述。关系数据库的值是这些关系模式在某一时刻对应的关系的集合，通常就称为关系数据库。</li>
</ul>
</li>
</ul>
<h3 id="关系操作"><a href="#关系操作" class="headerlink" title="关系操作"></a>关系操作</h3><ul>
<li><p>基本的关系操作：关系模型中常用的关系操作包括<strong>查询操作</strong>和<strong>插入、删除、修改操作</strong>两大部分。</p>
<ul>
<li><p>关系的查询表达能力很强，是关系操作中最主要的部分。查询操作又可以分为旋转、投影、连接、除、并、差、交、笛卡尔积等。其中<strong>选择、投影、并、差、笛卡尔积是5种基本操作</strong>。</p>
</li>
<li><p>关系操作的特点是集合操作方式，即操作的对象和结果都是集合。这种操作方式也称为一次一集合的方式。相应的非关系数据模型的数据操作方式则为一次一记录的方式。</p>
</li>
</ul>
</li>
<li><p>关系数据语言的分类</p>
<ul>
<li><p>早期的关系操作能力通常用代数方式或逻辑方式来表示，分别称为<strong>关系代数和关系演算</strong>。关系代数用对关系的运算来表达查询要求，关系演算则用谓词来表达查询要求。关系演算又可按谓词变元的基本对象是元组变量还是域变量分为<strong>元组关系演算和域关系演算</strong>。</p>
</li>
<li><p>还有一种介于关系代数和关系演算之间的<strong>结构化查询语言(SQL)</strong>。SQL是<strong>集查询、数据定义语言、数据操纵语言和数据控制语言于一体的关系数据语言。</strong></p>
</li>
</ul>
</li>
</ul>
<h3 id="关系的完整性"><a href="#关系的完整性" class="headerlink" title="关系的完整性"></a>关系的完整性</h3><ul>
<li><p>关系模型中有三类完整性约束：<strong>实体完整性、参照完整性和用户定义的完整性。</strong>其中实体完整性和参照完整性是关系模型必须满足的完整性约束条件，被称作<strong>关系的两个不变性。</strong></p>
<ol>
<li><p>实体完整性：实体完整性规则，若属性(指一个或一组属性)A是基本关系R的主属性，则A不能取空值。所谓空值就是“不知道”或“不存在”或“无意义”的值。</p>
<p><em>对实体完整性规则说明：</em></p>
<ul>
<li><p>实体完整性规则是针对基本关系而言的。一个基本表通常对应现实世界的一个实体集。</p>
</li>
<li><p>现实世界中的实体是可区分的，即它们具有某种唯一性标识。例如每个学生都是独立的个体，是不一样的。</p>
</li>
<li><p>相应的，关系模型中以主码作为唯一性标识。</p>
</li>
<li><p>主码中的属性不能取空值。</p>
</li>
</ul>
</li>
<li><p>参照完整性：<strong>设F是基本关系R的一个或一组属性，但不是关系R的码，Ks是基本关系S的码。如果F与Ks相对应，则称F是R的外码，并称基本关系R为参照关系，基本关系S为被参照关系或目标关系。</strong></p>
<p><img src="/images/参照关系.jpg" alt="参照关系与被参照关系"></p>
<ul>
<li><p>参照完整性规则：若属性(或属性组)F是基本关系R的外码，它与基本关系S的主码Ks相对应(基本关系R和S不一定是不同的关系)，则对于R中每个元组在F上的值必须：</p>
<ol>
<li><p>或者取空值(F的每个属性值均为空值)</p>
</li>
<li><p>或者等于S中某个元组的主码值。</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>用户定义的完整性</p>
<p><em>用户定义的完整性就是针对某一具体关系数据库的约束条件，它反映某一具体应用所涉及的数据必须满足的语义要求。</em></p>
</li>
</ol>
</li>
</ul>
<h3 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h3><p>  关系代数是一种抽象的查询语言，它用对关系的运算来表达查询。</p>
<p>  任何一种运算都是将一定的运算符作用于一定的运算对象上，得到预期的运算结果。所以运算对象、运算符、运算结果是运算的三大要素。</p>
<p>  关系代数用到的运算符包括两类：集合运算符和专门的关系运算符</p>
<p>  关系代数的运算按运算符的不同可分为传统的集合运算和专门的关系运算两类。</p>
<ul>
<li><p>传统的集合运算</p>
<p><strong>传统的集合运算是二目运算，包括并、差、交、笛卡尔积四种运算</strong></p>
<p>定义如下：</p>
<ol>
<li><p>并：R∪S ={t|t属于R V t属于S}    其结果仍为n目关系，由属于R或属于S的元组组成。</p>
</li>
<li><p>差：R-S = {t|t属于R ∧ t不属于S}  其即结果关系仍为n目关系，由属于R而不属于S的所有元组组成。</p>
</li>
<li><p>交：R∩S = {t|t属于R ∧ t属于S}    其结果关系仍为n目关系，由既属于R又属于S的元组组成。关系的交可以用差来表示，即</p>
<p>R∩S = R - (R - S)</p>
</li>
<li><p>笛卡尔积：R*S = {tr 连ts|tr属于R ∧ ts属于S}</p>
<p><img src="/images/传统集合运算举例.jpg" alt="传统集合运算举例"></p>
</li>
</ol>
</li>
<li><p>专门的关系运算</p>
<p><strong>专门的关系运算包括选择、投影、连接、除运算</strong></p>
<p> 记号：</p>
<ol>
<li><p>设关系模式为R(A1,A2,…,An)，它的一个关系设为R。t属于R表示t是R的一个元组。t[Ai]则表示元组t中相应于属性Ai的一个分量。</p>
</li>
<li><p>若A = {Ai1,Ai2,…,Aik}，其中Ai1，Ai2，…，Aik是A1，A2，…，An中的一部分，则A称为属性列或属性组。t[A] = (t[Ai1],t[Ai2],…,t[Aik])表示元组t在属性列A上诸分量的集合，A反则表示{A1,A2,…,An}中去掉{Ai1,Ai2,…,Aik}后剩余的属性组。</p>
</li>
<li><p>R为n目关系，S为m目关系。tr属于R，ts属于S，tr连接ts称为元组的连接或元组的串接。他是一个n+m列的元组前n个分量为R中的一个n元组，后m个分量为S中的一个m元组。</p>
</li>
<li><p>给定一个关系R(X,Z),X和Z为属性组。当t[X] = x时，x在R<strong>象集</strong>定义为</p>
<p>​    Zx = {t[Z]|t属于R，t[X] = x}</p>
<p>它表示R中属性组X上值为x的诸元组在Z上分量的集合。</p>
</li>
</ol>
<ul>
<li><p>选择：选择又称为限制。它是在关系R中选择满足给定条件的诸元组，记作   的塔F(R) = {t|t属于R ∧ F(t)= ‘真’}</p>
</li>
<li><p>投影：关系R上的投影是从R中选择出若干属性列组成新的关系。记作   pi A(R) = {t[A]|t属于R} 其中A为R中的属性列。投影是从列的角度进行的运算。</p>
</li>
<li><p>连接：连接也称为 θ连接。他是从两个关系的笛卡尔积中选取属性间满足一定条件的元组。记作：</p>
<p> <img src="/images/连接.jpg" alt="连接"> </p>
<ul>
<li><p>连接运算中有两种最为重要也最为常用的连接，一种是等值连接，另一种是自然连接。θ为“=”的连接运算称为<strong>等值连接</strong>是从关系R与S的广义笛卡尔积中选取A、B属性值相等的那些元组。<strong>自然连接</strong>是一种特殊的等值连接，它要求两个关系中进行比较的分量必须是同名的属性组，并且在结果中把重复的属性列去掉。即若R和S中具有相同的属性组B,U为R和S的全体属性集合。一般的连接操作是从行的角度进行运算，但自然连接还需要取消重复列，所以是<strong>同时从行和列的角度进行运算</strong>。</p>
</li>
<li><p>两个关系R和S在做自然连接时，选择两个关系在公共属性上值相等的元组构成新的关系。此时，关系R中某些元组有可能在S中不存在公共属性上值相等的元组，从而造成R中这些元组在操作时被舍弃，同样，S中某些元组也可能被舍弃。<strong>这些被舍弃的元组称为悬浮元组</strong>。</p>
</li>
<li><p>如果把悬浮元组也保存在结果关系中，而在其他属性上填空值(NULL)，那么这种连接就叫做外连接，记作R =&gt;&lt;= S;如果只保留左边关系R中的悬浮元组就叫做左外连接R=&gt;&lt;S;如果只保留右边关系S中的悬浮元组就叫做右外连接，记作R&gt;&lt;=S</p>
</li>
</ul>
</li>
<li><p>除运算：设关系R除以关系S的结果为关系T，则<strong>T包含所有在R但不在S中的属性及其值，且T的元组与S的元组的所有组合都在R中。</strong></p>
<ul>
<li>下面用象集来定义除法：给定关系R(X,Y)和S(Y,Z)，其中X,Y,Z为属性组。R中的Y与S中的Y可以有不同的属性名，但必须出自相同的域集。</li>
<li>R与S的除运算得到一个新的关系P(X)，P是R中满足下列条件的元组在X属性列上的投影：元组在X上分量值x的象集Yx包含S在Y上投影的集合。记作：R/S = {Tr[X]|tr属于R ∧ piY(S)包含于Yx} 其中Yx为x在R中的象集，x = tr[X]。除操作是同时从行和列角度进行运算。</li>
<li>R/S -&gt;投影-&gt;象集-&gt;包含</li>
</ul>
</li>
</ul>
</li>
<li><p>其中并，差，笛卡尔积，选择和投影这五种运算为基本的运算。其他三种运算，即交，连接和除，均可以用这5种基本运算来表达。引进他们并不增加语言的能力，但可以简化表达</p>
</li>
<li><p>关系代数中，这些运算经有限次复合后形成的表达式称为关系代数表达式。</p>
</li>
</ul>
<hr>
<h2 id="第三章-关系数据库标准语言SQL"><a href="#第三章-关系数据库标准语言SQL" class="headerlink" title="第三章 关系数据库标准语言SQL"></a>第三章 关系数据库标准语言SQL</h2><h3 id="SQL-概述"><a href="#SQL-概述" class="headerlink" title="SQL 概述"></a>SQL 概述</h3><ul>
<li><p>SQL 的产生与发展</p>
<p>目前，没有一个数据库系统能够支持SQL标准的所有概念和特性。大部分数据库系统能支持SQL/92标准中的大部分功能以及SQL99、SQL2003中的部分新概念。同时，许多软件厂商对SQL基本命令集还进行了不同程度的扩展和修改，又可以支持标准以外的一些功能特性。</p>
</li>
<li><p>SQL的特点</p>
<ol>
<li><p>综合统一</p>
</li>
<li><p>高度非过程化</p>
<p>只要提出“做什么”，而无须指明“怎么做”，因此无须了解存取路径。存取路径的选择以及SQL的操作过程由系统自动完成。</p>
</li>
<li><p>面向集合的操作方式</p>
</li>
<li>以同一种语法结构提供多种使用方式</li>
<li>语言简洁，易学易用 </li>
</ol>
</li>
</ul>
<h3 id="数据定义"><a href="#数据定义" class="headerlink" title="数据定义"></a>数据定义</h3><p><em>一个关系数据库管理系统的实例中可以建立多个数据库，一个数据库中可以建立多个模式，一个模式下通常包括多个表、视图和索引等数据库对象。</em></p>
<p><img src="/images/数据库对象命名机制的层次结构.jpg" alt="数据库对象命名机制的层次结构"></p>
<ul>
<li><p>模式的定义与删除</p>
<ul>
<li><p>定义模式：在SQL中，模式定义语句如下：create schema &lt;模式名&gt; authorization &lt;用户名&gt; </p>
<p>​                                                     <em>如果没有指定&lt;模式名&gt;，那么&lt;模式名&gt;隐含为&lt;用户名&gt;</em></p>
<p><em>要创建模式，调用该命令的用户必须拥有数据库管理员权限，或者获得了数据库管理员授予的create schema 的权限</em></p>
</li>
<li><p>目前，create chema 中可以接受 create table，create view和grant 子句。也就是说用户可以在创建模式的同时在这个模式定义中进一步创建基本表、视图。定义授权。即：create schema &lt;模式名&gt; authorization &lt;用户名&gt; [&lt;表定义子句&gt;|&lt;视图定义子句&gt;|&lt;授权定义子句&gt;]</p>
</li>
<li><p>删除模式：在SQL中，删除模式语句如下，drop schema &lt;模式名&gt;&lt;cascade|restrict&gt; </p>
<p><em>其中cascade和restrict两者必选其一。选择了cascade(级联)，表示在删除模式的同时把该模式中所有的数据库对象全部删除；选择了restrict(限制)，表示如果该模式中已经定义了下属的数据库对象(如表，视图等)，则拒绝该删除语句的执行。只有当该模式中没有任何下属的对象时才能执行 drop schema语句。</em></p>
</li>
</ul>
</li>
<li><p>基本表的定义、删除与修改</p>
<ul>
<li><p>定义基本表：创建了一个模式就建立了一个数据库的命名空间，一个框架。在这个空间中首先要定义的是该模式包含的数据库基本表。SQL语言使用create table 语句定义基本表，其基本格式如下：</p>
<p><em>create table &lt;表名&gt;(&lt;列名&gt;&lt;数据类型&gt;[列级完整性约束条件][,&lt;列名&gt;&lt;数据类型&gt;[列级完整性约束条件]][,表级完整性约束条件])</em></p>
<p><em>参照表和被参照表可以是同一个表</em></p>
</li>
<li><p>数据类型：</p>
<p><img src="/images/数据类型1.jpg" alt="数据类型1"><br><img src="/images/数据类型2.jpg" alt="数据类型1"></p>
</li>
<li><p>模式与表</p>
<p>每一给基本表都属于某一个模式，一个模式包含多个基本表。当定义基本表时一般可以有三种方法定义它所属的模式，现在要在S-T中定义Student、Course、SC等基本表。</p>
<ol>
<li><p>方法一：在表名中明显的给出模式名。 create table ”S-T“.Student(…);<em>Student所属的模式是S-T</em></p>
</li>
<li><p>方法二：在创建模式语句中同时创建表</p>
</li>
<li><p>方法三：设置所属的模式，这样在创建表时表名中不必给出模式名。</p>
<p>当用户创建基本表(其他数据库对象也一样)时若没有指定模式，系统根据搜索路径来确定该对象所属的模式。</p>
<p>搜索路径包含一组模式列表，关系数据库管理系统会使用模式列表中第一个存在的模式作为数据库对象的模式名。若搜索路径中的模式名都不存在，系统将给出错误。</p>
<p><em>使用下面的语句可以显示当前的搜索路径： show search_path</em></p>
<p><em>搜索路径当前默认值是$user，PUBLIC。其含义是首先搜索与用户名相同的模式名，如果该模式名不存在，则使用PUBLIC模式</em></p>
<p><em>数据库管理员也可以设置搜索路径，如：SET search_path TO “S-T”,PUBLIC; 然后，定义基本表。实际结果是建立了S-T.Student基本表。因为关系数据库管理系统发现路径中第一个模式名S-T存在，就把该模式作为基本表Studnt所属的模式。</em></p>
</li>
</ol>
</li>
<li><p>修改基本表</p>
<p>SQL语言用alter table语句修改基本表，其一般格式为</p>
<p>alter table &lt;表名&gt;</p>
<p>[add [column] &lt;新列名&gt;&lt;数据类型&gt;[完整性约束]]</p>
<p>[add &lt;表级完整性约束&gt;]</p>
<p>[drop [column] &lt;列名&gt;[cascade|restrict]]</p>
<p>[drop constraint &lt;完整性约束名&gt; [restrict|cascade]]</p>
<p>[alter column &lt;列名&gt;&lt;数据类型&gt;]</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>删除基本表</p>
<p>drop table &lt;表名&gt;[restrict|cascade]</p>
<p>若选择restrict，则该表的删除是有限制条件的。欲删除的基本表不能被其他表的约束所引用(如cheack，foreign key等约束)，不能有视图，不能有触发器，不能有存储过程或函数等。如果存在这些依赖该表的对象，则此表不能被删除。</p>
<p>若选择cascade，则该表的删除没有限制条件。在删除基本表的同时，相关的依赖对象，例如视图，都将被一起删除。</p>
<p><em>默认情况是restrict</em></p>
</li>
<li><p>索引的建立与删除</p>
<p>数据库索引有多种类型，常见索引包括顺序文件上的索引、B+树索引、散列索引、位图索引等。<strong>顺序文件上的索引</strong>是针对按指定属性值升序或降序存储的关系，在该属性上建立一个顺序索引文件，索引文件由属性值和相应的元组指针组成。<strong>B+树索引</strong>是将索引属性组织成B+树形式，B+树的叶结点为属性值和相应的元组指针。B+树索引具有动态平衡的优点。<strong>散列索引</strong>是建立若干个桶，将索引属性按照其散列函数值映射到相应桶中，桶中存放索引属性值和相应的元组指针。散列索引具有查找速度快的特点。<strong>位图索引</strong>是用位向量记录所有属性中可能出现的值，每个位向量对于一个可能值。</p>
<p><em>关系数据库管理系统在执行查询时会自动选择合适的索引作为存取路径，用户不必也不能显式的选择索引。</em></p>
<ol>
<li><p>建立索引：在SQL语言中，建立索引使用 create index 语句，一般格式为</p>
<p>create [unique][cluster] index &lt;索引名&gt;</p>
<p>on &lt;表名&gt;(&lt;列名&gt;[&lt;次序&gt;][,&lt;列名&gt;[&lt;次序&gt;]]…)</p>
<p>其中，&lt;表名&gt;是要建索引的基本表的名字。索引可以建立在该表的一列或多列上，各列名之间用逗号分隔。每个&lt;列名&gt;后面还可以用&lt;次序&gt;指定索引值的排列次序，可选ASC(升序)或DESC(降序)，默认值为ASC.</p>
<p>UNIQUE表明此索引每一个索引值只对应唯一的数据记录。</p>
<p>CLUSTER 表示要建立的索引是聚簇索引。</p>
</li>
<li><p>修改索引</p>
<p>对于已经建立的索引，如果需要对其重新命名，可以使用ALTER INDEX 语句。其一般格式为：</p>
<p>ALTER INDEX &lt;旧索引名&gt; RENAME TO &lt;新索引名&gt;</p>
</li>
<li><p>删除索引</p>
<p>在SQL中，删除索引使用DROP INDEX语句，其一般格式为</p>
<p>DROP INDEX &lt;索引名&gt;</p>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>数据字典</p>
<p>数据字典是关系数据库管理系统内部的一组系统表，它记录了数据库中所有的定义信息，包括关系模式定义，视图定义，索引定义，完整性约束定义，各类用户对数据库的操作权限，统计信息等。</p>
</li>
</ul>
<h3 id="数据查询"><a href="#数据查询" class="headerlink" title="数据查询"></a>数据查询</h3><ul>
<li><p>数据查询是数据库的核心操作。SQL提供了SELECT语句进行数据查询，该语句具有灵活的使用方式和丰富的功能。其一般格式为</p>
<p>select [all|distinct] &lt;目标列表达式&gt;[,&lt;目标列表达式&gt;]…</p>
<p>from &lt;表名或视图名&gt; [,&lt;表名或视图名&gt;…]|(&lt;select语句&gt;)[AS]&lt;别名&gt;</p>
<p>[where&lt;条件表达式&gt;]</p>
<p>[group by &lt;列名1&gt;[having&lt;条件表达式&gt;]]</p>
<p>[order by&lt;列名2&gt;[asc|desc]]</p>
<p>整个select语句的含义是，根据where子句的条件表达式从from子句指定的基本表、视图或派生表中找出满足条件的元组，再按select子句中的目标列表达式选出元组中的属性值形成结果表。</p>
<p>如果由group by 子句，则将结果按&lt;列名1&gt;的值进行分组，该属性列值相等的元组为一组。通常会在每组中作用聚集函数。如果 group by子句带having短语，则只有满足指定条件的组才予以输出。</p>
<p>如果有order by子句，则结果表还有按&lt;列名2&gt;的值升序或降序排序。</p>
<p>select语句既可以完成简单的单表查询，也可以完成复杂的连接查询和嵌套查询。</p>
</li>
<li><p>单表查询</p>
<ol>
<li><p>选择表中的若干列</p>
<ul>
<li><p>查询指定列：如select Sno，Sname from Student。各个列的顺序可以与表中的顺序不一致</p>
</li>
<li><p>查询全部列：如select * from Student</p>
</li>
<li><p>查询经过计算的值：select 子句的&lt;目标列表达式&gt;不仅可以使表中的属性列，也可以是表达式。如：select Sname，‘Year of Birth：’，2014-Sage BIRTHDAY from Student</p>
</li>
</ul>
</li>
<li><p>选择表中的若干元组</p>
<ul>
<li><p>消除取值重复的行</p>
<p>两个本科并不完全相同的元组在投影到指定的某些列上后，可能会变成相同的行。可以使用distinct消除他们。</p>
<p>如：select distinct Sno from SC</p>
</li>
<li><p>查询满足条件的元组</p>
<p>查询满足条件的元组可以通过where子句实现。where子句常用的查询条件</p>
<ol>
<li><p>比较大小</p>
</li>
<li><p>确定范围：谓词between…and…和not between…and…可以用来查找属性值在(或不在)指定范围内的元组，其中<strong>between后是范围的下限(即低值)，and后是范围的上限(即高值)。</strong></p>
</li>
<li><p>字符匹配</p>
<p>谓词like可以用来进行字符串的匹配。其一般语法格式如下：</p>
<p>[not] like ‘&lt;匹配串&gt;’ [escape’&lt;换码字符&gt;’]</p>
<p>其含义是查找指定的属性列值与&lt;匹配串&gt;相匹配的元组。&lt;匹配串&gt;可以是一个完整的字符串，也可以含有通配符%和_。其中：</p>
<p>%(百分号)代表任意长度(长度可以为0)的字符串。例如a%b表示以a开头，以b结尾的任意长度的字符串。</p>
<p>_(下横线)代表任意单个字符</p>
<p><strong>如果用户要查询的字符串本身就含有通配符%或_,这是就要使用escape ‘&lt;换码字符&gt;’ 短语对通配符进行转义了。</strong></p>
</li>
<li><p>涉及空值的查询</p>
<p>IS和NOT IS</p>
</li>
<li><p>多重条件查询</p>
<p>AND 和 OR</p>
</li>
</ol>
</li>
</ul>
</li>
<li><p>order by子句</p>
<p>用户可以用order by子句对查询结果按照一个或多个属性列的升序(asc)或降序(desc)排列，默认值为升序。</p>
<p>对于空值，排序时显示的次序由具体系统实现来决定。例如按升序排，含空值的元组最后显示；按降序排，空值的元组则最先显示。各个系统的实现可以不同，只要保持一致就行。</p>
</li>
<li><p>聚集函数</p>
<p>为了进一步方便用户，增强检索功能，SQL提供了许多聚集函，主要有：</p>
</li>
</ol>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">聚集函数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">count(*)</td>
<td>统计元组个数</td>
</tr>
<tr>
<td style="text-align:center">count([distinct\</td>
<td>all]&lt;列名&gt;)</td>
<td>统计一列中值的个数</td>
</tr>
<tr>
<td style="text-align:center">sum([distinct\</td>
<td>all]&lt;列名&gt;)</td>
<td>计算一列值的总和(此列必须是数值型)</td>
</tr>
<tr>
<td style="text-align:center">sum([distinct\</td>
<td>all]&lt;列名&gt;)</td>
<td>计算一列值的平均值(此列必须是数值型)</td>
</tr>
<tr>
<td style="text-align:center">max([distinct\</td>
<td>all]&lt;列名&gt;)</td>
<td>求一列值中的最大值</td>
</tr>
<tr>
<td style="text-align:center">min([distinct\</td>
<td>all]&lt;列名&gt;)</td>
<td>求一列值中的最小值</td>
</tr>
</tbody>
</table>
<p>   如果指定distinct短语，则表示在计算时要取消指定列中的重复值。如果不指定distinct短语或指定all短语(all为默认值)，则表示不取消重复值。</p>
<p>  <strong>当聚集函数遇到空值时，除count(*)外，都跳过空值而只处理非空值。聚集函数只能用于select子句和group by中的having子句。</strong></p>
<ol start="5">
<li><p>group by子句</p>
<p>group by子句将查询结果按某一列或多列的值分组，值相等的为一组。</p>
<p>对查询结果分组的目的是为了细化聚集函数的作用对象。如果未对查询结果分组，聚集函数将作用于整个查询结果。分组后聚集函数将作用于每一个组，即每一组都有一个函数值。</p>
<p>例子：见课本P99 例3.48</p>
</li>
</ol>
<ul>
<li><p>连接查询</p>
<p>若一个查询同时涉及两个以上的表，则称之为连接查询。连接查询是关系数据库中最主要的查询，包括等值连接查询、自然连接查询、非等值连接查询、自身连接查询、外连接查询和复合条件连接查询等。</p>
<ol>
<li><p>等值与非等值连接查询</p>
<ul>
<li><p>连接查询的where子句中用来连接两个表的条件称为<strong>连接条件或连接谓词</strong>其一般格式为</p>
<p>[&lt;表名1&gt;.]&lt;列名1&gt;&lt;比较运算符&gt;[&lt;表名2&gt;.]&lt;列名2&gt;</p>
<p>此外连接谓词还可以使用下面形式：</p>
<p>[&lt;表名1&gt;.]&lt;列名1&gt; between [&lt;表名2&gt;.]&lt;列名2&gt; and [&lt;表名3&gt;.]&lt;列名3&gt;</p>
<p><strong>当连接运算符为=时，称为等值连接。使用其他运算符称为非等值连接。</strong></p>
<p>连接谓词中的列名称为连接字段。连接条件中的各连接字段类型必须是可比的，但名字不必相同。</p>
</li>
<li><p>关系数据库管理系统执行该连接操作的一种可能过程是：首先在表Student中找到第一个元组，然后从头开始扫描SC表，逐一查找与Student第一个元组的Sno相等的SC元组，找到后就将Student中的第一个元组与该元组拼接起来，形成结果表中的一个元组。SC全部查找完后，再找Student中第二个元组，然后再从头开始扫描SC，逐一查找满足连接条件的元组，找到后就将Student中的第二个元组与该元组拼接起来，形成结果表中一个元组。重复以上操作。<strong>这就是嵌套循环连接算法的基本思想。</strong></p>
</li>
<li><p>如果在SC表Sno上建立了索引的化，就不用每次全表扫描SC表了，而是根据Sno值通过索引找到相应的SC元组。用索引查询SC中满足条件的元组一般会比全表扫描快。若在等值连接中<strong>把目标列中重复的属性列去掉则为自然连接。</strong></p>
</li>
<li><p>一条SQL语句可以同时完成选择和连接查询，这时where子句是由连接谓词和选择谓词组成的复合条件。</p>
</li>
</ul>
</li>
<li><p>自身连接</p>
<p>连接操作不仅可以在两个表之间进行，也可以是一个表与其自己进行连接，称为表的<strong>自身连接。</strong>例：select FIRST.Cno，SECOND.Cpno</p>
<p>​                from Course FIRST,Course SECOND</p>
<p>​                where FIRST.Cpno = SECOND.Cno</p>
</li>
<li><p>外连接</p>
<p>若某个学生没有选课，<strong>仍把Student的悬浮元组保存在结果关系中</strong>，而在SC表的属性上填空值NULL，这时就需要使用外连接。</p>
<p><strong>左外连接</strong>列出左边关系中所有的元组，<strong>右外连接</strong>列出右边关系中所有的元组。</p>
</li>
<li><p>多表连接</p>
<p>连接操作处理可以是<strong>两表连接</strong>、一个表与其自身连接外，还可以是两个以上的表进行连接，猴子通常称为<strong>多表连接</strong>。</p>
</li>
</ol>
</li>
<li><p>嵌套查询</p>
<p>在SQL语言中，<strong>一个select-from-where语句称为一个查询块</strong>。将一个查询块嵌套在另一个查询块的where子句或having短语的条件中的查询称为嵌套查询。上层的查询块称为外层查询或父查询，下层查询块称为内层查询或子查询。</p>
<p>SQL语言允许多层嵌套查询，即一个子查询中还可以嵌套其他子查询。需要特别指出的是，<strong>子查询的select语句中不能使用order by子句</strong>，order by子句只能对最终查询结果排序。</p>
<p>嵌套查询使用户可以用多个简单查询构成复杂的查询，从而增强SQL的查询能力。以层层嵌套的方式来构造程序正是SQL中”结构化“的含义所在。</p>
<ol>
<li><p>带有in谓词的子查询</p>
<p>子查询的查询条件不依赖于父查询，称为<strong>不相关子查询</strong></p>
<p>实现同一个查询请求可以有多种方法，当然不同的方法其执行效率可能会有差别，甚至会差别很大。这就是数据库编程人员应该掌握的数据库性能调优技术。</p>
<p>有些嵌套查询可以用连接运算代替，有些是不能替代的。</p>
<p>查询的查询条件不依赖于父查询，这类子查询称为不相关子查询。不相关子查询是较简单的一类子查询。<strong>如果子查询的查询条件依赖于父查询，这类子查询称为相关子查询，整个查询语句称为相关嵌套查询语句。</strong></p>
</li>
<li><p>带有比较运算符的子查询</p>
<p><img src="/images/相关子查询.jpg" alt="相关子查询"></p>
<p>x是表SC的别名，又称为元组变量，可以用来表示SC的元组。内层查询是求一个学生所有选修课程平均成绩的，至于是哪个学生的平均成绩要看<strong>参数x.Sno的值，而该值是与父查询相关的，因此这类查询称为相关子查询。</strong></p>
<p><strong>求解相关子查询不能像求解不相关子查询那样一次将子查询求解出来，然后求解父查询。</strong>内层查询由于与外层查询有关，因此必须反复求值。</p>
</li>
<li><p>带有any(some) 或 all 谓词的子查询</p>
<p>子查询返回单值时可以用比较运算符，但返回多值时要用any(有的系统用some)或all谓词修饰符。而使用any或all谓词时则必须同时使用比较运算符。</p>
<ul>
<li><em>&gt;any  大于子查询结果中的某个值</em></li>
<li><em>&gt;all  大于子查询结果中的所有值</em></li>
</ul>
<p>例子见课本P107 例3.58</p>
<p>例子中的查询也可以用聚集函数来实现，事实上，用聚集函数实现子查询通常比直接用any或all查询效率要高。</p>
<p><img src="/images/any与all和聚集函数对应关系表.jpg" alt="any与all和聚集函数对应关系表"></p>
</li>
<li><p>带有exists谓词的子查询</p>
<ul>
<li><p>exists代表存在量词∃。带有exists谓词的子查询不返回任何数据，只产生逻辑真值”true”或逻辑假值”false”。</p>
<p>例子：课本P109 例3.60</p>
</li>
<li><p>使用存在量词exists后，若内层查询结果非空，则外层的where子句返回真值，否则返回假值。</p>
</li>
<li><p>由exists引出的子查询，其目标列表达式通常都用*，因为带exists的子查询只返回真值或假值，给出列名无实际意义。</p>
</li>
<li><p>与exists谓词相对应的是not exists谓词。使用存在量词not exists后，若内层查询结果为空，则外层的where子句返回真值，否则返回假值。</p>
</li>
<li><p><strong>一些带exists 或 not exists谓词的子查询不能被其他形式的子查询等价替换，但所有带in谓词、比较运算符、any和all谓词的子查询都能用带exists谓词的子查询等价替换。</strong></p>
</li>
<li><p>SQL中没有全称量词，但是可以把带有全称量词的谓词转换为等价的带有存在量词的谓词</p>
<p>例子：课本P110 例3.62、3.63</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p>集合查询</p>
<p>select 语句的查询结果是元组的集合，所以多个select语句的结果可进行集合操作。<strong>集合操作主要包括并操作union、交操作intersect和差操作except。</strong></p>
<p><em>使用union将多个查询结果合并起来时，系统会自动去掉重复元组。如果要保留重复元组则用union all操作符。</em></p>
</li>
<li><p>基于派生表的查询</p>
<p>子查询不仅可以出现在where子句中，还可以出现在from子句中，这时子查询生成的临时派生表成为主查询的查询对象。</p>
<p>select Sno,Cno</p>
<p>from SC,(select Sno,Avg(Grade) from SC group by Sno) as Avg_sc(avg_sno,avg_grade)</p>
<p>where SC.Sno = Avg_sc.avg_sno and SC.Grade &gt;= Avg_grade</p>
<p>这里from子句中的子查询将生成一个派生表Avg_sc。该表由avg_sno和avg_grade两个属性组成，记录了每个学生的学号及平均成绩。主查询将SC表与Avg_sc按学号相等进行连接，选出选修课成绩大于其平均成绩的课程号。</p>
<p><strong>通过from子句生成派生表时，as关键字可以省略，但必须为派生关系指定一个别名。</strong></p>
</li>
<li><p>select 语句的一般格式：</p>
<p>select [ALL|DISTINCT]&lt;目标列表达式&gt;[别名][,&lt;目标列表达式&gt;[别名]]…</p>
<p>from &lt;表名或视图名&gt;[别名][,&lt;表名或视图名&gt;[别名]]…|(<select 语句>)[as]&lt;别名&gt;</select></p>
<p>[where &lt;条件表达式&gt;]</p>
<p>[group by&lt;列名1&gt;[having1&lt;条件表达式&gt;]]</p>
<p>[order by&lt;列名2&gt;[asc|desc]]</p>
<ol>
<li><p>目标列表达式的可选格式</p>
<p><img src="/images/目标列表达式的可选格式.jpg" alt="目标列表达式的可选格式"></p>
</li>
<li><p>聚集函数的一般格式</p>
<p><img src="/images/聚集函数的一般格式.jpg" alt="聚集函数的一般格式"></p>
</li>
<li><p>where子句的条件表达式的可选格式</p>
<p><img src="/images/where子句的条件表达式的可选格式.jpg" alt="where子句的条件表达式的可选格式"></p>
</li>
</ol>
</li>
</ul>
<h3 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h3><p>数据更新操作有三种:向表中添加若干行数据、修改表中的数据和删除表中的若干行数据。</p>
<ul>
<li><p>插入数据</p>
<ol>
<li><p>插入元组</p>
<p>insert into &lt;表名&gt;[(&lt;属性列1&gt;[,&lt;属性列2&gt;]…)]values(&lt;常量1&gt;[,常量2]…)</p>
<p>在into子句中指出了表名Student，并指出了新增加的元组在哪些属性上要赋值，属性的顺序可以与create table中的顺序不一样。values子句对新元组的各属性赋值，字符串常数要用单引号(英文符合)括起来。</p>
<p>例：</p>
<p>insert into SC(Sno,Cno) values(‘201215128’,’1’)</p>
<p><strong>关系数据库管理系统将在新插入记录的Grade列上自动的赋空值。</strong></p>
<p>或 insert into SC values(‘201215128’,’1’,NULL)</p>
<p><strong>因为没有指出SC的属性名，在Grade列上要明确给出空值。</strong></p>
</li>
<li><p>插入子查询结果</p>
<p>插入子查询结果的insert 语句格式为</p>
<p>insert into &lt;表名&gt;[(&lt;属性列1&gt;[,&lt;属性列2&gt;…]） 子查询；</p>
</li>
</ol>
</li>
<li><p>修改数据</p>
<p>修改操作又称为更新操作，其语句的一般格式为</p>
<p>update &lt;表名&gt;</p>
<p>set &lt;列名&gt;=&lt;表达式&gt;[，&lt;列名&gt;=&lt;表达式&gt;]…</p>
<p>[where &lt;条件&gt;]</p>
<p>其功能是修改指定表中满足where子句条件的元组。其中set子句给出&lt;表达式&gt;的值用于取代相应的属性列值。如果省略where子句，则表示要修改表中的所有元组。</p>
<ol>
<li><p>修改某一个元组的值</p>
<p>例3.73 将学生201215121的年龄改为22岁</p>
<p>update Student set Sage=22 where Sno=’201215121’</p>
</li>
<li><p>修改多个元组的值</p>
<p>例 3.74 将所有学生的年龄增加1岁</p>
<p>update Student set Sage=Sage+1</p>
</li>
<li><p>带子查询的修改语句</p>
<p>子查询也可以嵌套在update语句中，用以构造修改的条件</p>
<p>例 3.75 将计算机科学系全体学生的成绩置零。</p>
<p>update SC set Grade=0</p>
<p>where Sno in(select Sno from Student where Sdept=’CS’)</p>
</li>
</ol>
</li>
<li><p>删除数据</p>
<p>删除语句的一般格式为</p>
<p>delete from &lt;表名&gt; [where &lt;条件&gt;]；</p>
<ol>
<li>删除某一个元组的值</li>
<li>删除多个元组的值</li>
<li>带子查询的删除语句</li>
</ol>
</li>
</ul>
<h3 id="空值的处理"><a href="#空值的处理" class="headerlink" title="空值的处理"></a>空值的处理</h3><p>所谓的空值就是”不知道”或”不存在”或”无意义”的值。 SQL语言中允许某些元组的某些属性在一定情况下取空值。</p>
<p>一般有以下几种情况：</p>
<ul>
<li>该属性应该有一个值，但目前不知道它的具体值。</li>
<li>该属性不应该有值。</li>
<li>由于某种原因不便于填写。</li>
</ul>
<ol>
<li><p>空值的产生</p>
<p>插入和连接会产生空值。空值的关系运算也会产生空值。</p>
</li>
<li><p>空值的判断</p>
<p>判断一个属性的值是否为空值，用 IS NULL或IS NOT NULL来表示。</p>
</li>
<li><p>空值的约束条件</p>
<p>属性定义(或者域定义)中有 NOT NULL约束条件的不能取空值，码属性不能取空值。</p>
</li>
<li><p>空值的算术运算、比较运算和逻辑运算</p>
<p>空值与另一个值(包括另一个空值)的算术运算的结果为空值，空值与另一个值(包括另一个空值)的比较运算的结果为unknow。<strong>有了unknown后，传统的逻辑运算中二值(true,false)逻辑就扩展成了三值逻辑。</strong></p>
<p><img src="/images/逻辑运算符真值表.jpg" alt="逻辑运算符真值表"></p>
</li>
</ol>
<h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><p>视图是从一个或几个基本表(或视图)导出的表。它与基本表不同，是一个虚表。数据库中只存放视图的定义，二不存放视图对应的数据，这些数据仍存放在原来的基本表中。所以一旦基本表中的数据发生变化，从视图中查询出的数据也就随之改变了。视图一经定义，就可以和基本表一样被查询、被删除。</p>
<ul>
<li><p>定义视图</p>
<ol>
<li><p>建立视图</p>
<p>SQL语言用create view命令建立视图，其一般格式为</p>
<p>create view &lt;视图名&gt;[(&lt;列名&gt;[,&lt;列名&gt;]…)]</p>
<p>as &lt;子查询&gt;</p>
<p>[with check option]</p>
<p>其中，子查询可以是任意的select语句，是否可以含有order by子句和distinct短语，则取决于具体系统的实现。</p>
<p><strong>with check option 表示对视图进行update、insert和delete操作时要保证更新、插入或删除的行满足视图定义中的谓词条件(即子查询中的条件表达式)。</strong></p>
<p>组成视图的属性列名或者全部省略或者全部指定，没有第三种选择。如果省略了视图的各个属性列名，则隐含该视图由子查询中select子句目标列中的诸字段组成。但在下列三种情况下必须明确指定组成视图的所有列名:</p>
<ol>
<li>某个目标列不是单纯的属性名，而是聚集函数或列表达式</li>
<li>多表连接时选出了几个同名列作为视图的字段</li>
<li>需要在视图中为某个列启用新的更合适的名字</li>
</ol>
<ul>
<li>关系数据库管理系统执行create view语句的结果<strong>只是把视图的定义存入数据字典，并不执行其中的select语句。</strong>只是在对视图查询时，才按视图的定义从基本表中将数据查出。</li>
<li>由于在定义IS_Student视图时加上了with check option子句，以后对该视图进行插入、修改和删除操作时，<strong>关系数据库管理系统会自动加上Sdept=’IS‘的条件</strong>。P122 例：3.85</li>
<li>若一个视图是<strong>从单个基本表导出的，并且只是去掉了基本表的某些行和某些列，但保留了主码，则称这类视图为行列子集视图。</strong></li>
<li>视图不仅可以建立在一个或多个基本表上，也<strong>可以建立在一个或多个已定义好的视图上，或建立在基本表与视图上。</strong></li>
<li>定义基本表时，为了减少数据库中的冗余数据，表中只存放基本数据，由基本数据经过各种计算派生吃的数据一般是不存储的。由于视图中的数据并不实际存储，所以定义视图时可以根据应用的需要设置一些派生属性列。这些派生属性由于在基本表中并不实际存在，也称它们为虚拟列。<strong>带虚拟列的视图也称为带表达式的视图。</strong>例 P123 例3.88</li>
</ul>
</li>
<li><p>删除视图</p>
<ul>
<li>该语句的格式为 drop view &lt;视图名&gt;[cascade];</li>
<li>视图删除后视图的定义将从数据字典中删除。如果该视图上还导出了其他视图，则使用cascade级联删除语句把该视图和由它导出的所有视图一起删除。</li>
<li>基本表删除后，由该基本表导出的所有视图均无法使用，但是视图的定义没有从字典中清除。删除这些视图定义需要显式的使用drop view语句。</li>
</ul>
</li>
</ol>
</li>
<li><p>查询视图</p>
<ul>
<li>关系数据库管理系统执行对视图的查询时，首先进行有效性检查，检查查询中涉及的表、视图等是否存在。如果存在，则<strong>从数据字典中取出视图的定义，把定义中的子查询和用户的查询结合起来，转换成等价的对基本表的查询，然后再执行修正了的查询。这一转换过程称为视图消解。</strong></li>
<li>目前多数关系数据库系统对行列子集视图的查询均能进行正确转换。但对非行列子集视图的查询就不一定能做转换了，因此这类查询应该直接对基本表进行。</li>
<li>但<strong>定义视图并查询视图与基于派生表的查询是有区别的。</strong>视图一旦定义，其定义将永久保存在数据字典中，之后的所有查询都可以直接引用该视图。而<strong>派生表只是在语句执行时临时定义，语句执行后该定义即被删除。</strong></li>
</ul>
</li>
<li><p>更新视图</p>
<ul>
<li>更新视图是指通过视图来插入、删除和修改数据。</li>
<li>由于视图是不实际存储数据的虚表，因此对视图的更新最终要转换为对基本表的更新。像查询视图那样，对视图的更新操作也是通过视图消解，转换为对基本表的更新操作。</li>
<li>为防止用户通过视图对数据进行增加、删除、修改时，有意无意的对不属于视图范围内的基本表数据进行操作，可在定义视图时加上with check option子句。这样在视图上增、删、改数据时，关系数据库管理系统会检查视图定义中的条件，若不满足条件则拒绝执行该操作。</li>
<li>在关系数据库中，并不是所有的视图都是可更新的，因为有些视图的更新不能唯一的有意义的转换成对相应基本表的更新。</li>
<li>一般的，行列子集视图是可更新的。除行列子集视图外，有些视图理论上是可更新的，但他们的确切特征还是尚待研究的课题。还有些视图从理论上就是不可更新的。</li>
<li>目前，各个关系数据库管理系统一般都只允许对行列子集视图进行更新，而且各个系统对视图的更新还有更进一步的规定。由于各系统实现方法上的差异，这些规定也不尽相同。</li>
<li>一个不允许更新的视图上定义的视图也不允许更新，不可更新的视图与不允许更新的视图是两个不同的概念。</li>
</ul>
</li>
<li><p>视图的作用</p>
</li>
</ul>
<p>视图最终是定义在基本表之上的，对视图的一起操作最终也要转换为对基本表的操作。</p>
<ol>
<li><p>视图能够简化用户的操作</p>
<ol start="2">
<li><p>视图能够是用户以多种角度看待同一组数据</p>
</li>
<li><p>视图对重构数据库提供了一定程度的逻辑独立性</p>
<p>这样尽管数据库的逻辑结构改变了(变为SX和SY两个表)，但应用程序不必修改，因为新建立的视图定义为用户原来的关系，使用户的外模式保持不变，用户的应用程序通过视图仍然能够查找数据。</p>
</li>
<li><p>视图能够对机密数据提供安全保护</p>
</li>
<li><p>适当利用视图可以更清晰的表达查询</p>
</li>
</ol>
</li>
</ol>
<h2 id="第四章-数据库安全性"><a href="#第四章-数据库安全性" class="headerlink" title="第四章 数据库安全性"></a>第四章 数据库安全性</h2><h3 id="数据库安全性概述"><a href="#数据库安全性概述" class="headerlink" title="数据库安全性概述"></a>数据库安全性概述</h3><p>数据库的安全性是指保护数据库以防止不合法使用所造成的数据泄露、更改或破坏。</p>
<ul>
<li><p>数据库的不安全因素</p>
<ol>
<li>非授权用户对数据库的恶意存取和破坏</li>
<li>数据库中重要或敏感的数据被泄漏</li>
<li>安全环境的脆弱性</li>
</ol>
</li>
<li><p>安全标准简介</p>
<p>为满足全球IT市场上互认标准化安全评估结果的需要，CTCPEC、FC、TCSEC和ITSEC的发起组织于1993年起开始联合行动，解决标准中概念和技术上的差异，将各自独立的准则集合成一组单一的、能被广泛使用的IT安全准则，这一行动被称为通用准则(CC)项目。项目发起组织的代表建立了专门的委员会来开发通用准则，经历多次讨论和修订，CCV2.1版于1999年被ISO采用为国际标准，<strong>2001年被我国采用为国家标准。</strong></p>
<p><strong>TCSEC又称桔皮书。</strong>1991年4月，美国国家计算机安全中心颁布了《可信计算机系统评估准则关于可信数据库系统的解释》(即紫皮书)，将TCSEC扩展到数据库管理系统。TCSEC/TDI中定义了数据库管理系统的设计与实现中需满足和用以进行安全性级别评估的标准，从4个方面来描述安全性级别划分的指标，即安全策略、责任、保证和文档。每个方面又细分为若干项。</p>
<p><img src="/images/信息安全标准的发展简史.jpg" alt="信息安全标准的发展简史"></p>
<p>根据计算机系统对各项指标的支持情况，TCSEC/TDI将系统划分为4组7个等级，依次是D、C(C1,C2)、B(B1,B2,B3)、A(A1),按系统可靠或可信程度逐渐增高</p>
<p><img src="/images/安全级别划分.jpg" alt="TCSEC/TDI安全级别划分"></p>
<ul>
<li>D级：该级是最低级别。保留D级的目的是为了将一切不符合更高标准的系统统统归于D组。如DOS就是操作系统中安全标准为D级的典型例子，它具有操作系统的基本功能，如文件系统、进程调度等，但在安全性方面几乎没有什么专门的机制来保障。</li>
<li>C1级：该级只提供了非常初级的自主安全保护，能够实现对用户和数据的分离，进行<strong>自主存取控制(DAC)</strong>,保护或限制用户权限的传播。现有的商业系统往往稍作改进即可满足要求。</li>
<li>C2级：该级实际上是安全产品的最低档，提供受控的存取保护，即将C1级的DAC进一步细化，以个人身份注册负责，并实施审计和资源隔离。达到C2级的产品在其名称中往往不突出”安全”这一特色，如操作系统中的window 2000、数据库产品中的Oracle 7等。</li>
<li>B1级：标记安全保护。对系统的数据加以标记，并<strong>对标记的主体和客体实施强制存取控制(MAC)以及审计等安全机制。B1级别的产品才被认为是真正意义上的安全产品，</strong>满足此级别的产品前一般多冠以”安全”或可信的字样，作为区别于普通产品的安全产品出售。</li>
<li>B2级：结构化保护。建立形式化的安全策略模型，并对系统内的所有主体和客体实施DAC和MAC。</li>
<li>B3级：安全域。该级的TCB必须满足访问监控器的要求，审计跟踪能力更强，并提供系统恢复过程。</li>
<li>A1级：验证设计，即提供B3级保护的同时给出系统的形式化设计说明和验证，以确信各安全保护真正实现。</li>
</ul>
<p>CC评估保障即的划分</p>
<p><img src="/images/CC评估保证级(EAL" alt="CC评估保证级(EAL)的划分">的划分.jpg)</p>
<p><strong>粗略而言，TCSEC的C1和C2级分别相当于EAL2和EAL3；B1、B2和B3分别相当于EAL4、EAL5和EAL6；A1对应于EAL7。</strong></p>
</li>
</ul>
<h3 id="数据库安全性控制"><a href="#数据库安全性控制" class="headerlink" title="数据库安全性控制"></a>数据库安全性控制</h3><p>在一般计算机系统中，安全措施是一级一级层层设置的。</p>
<p>下面讨论与数据库有关的安全性，主要包括用户身份鉴别、多层存取控制、审计、视图和数据加密等安全技术。</p>
<p><img src="/images/计算机系统的安全模型.jpg" alt="计算机系统的安全模型"></p>
<ul>
<li><p>用户身份鉴别</p>
<ol>
<li>静态口令鉴别</li>
<li>动态口令鉴别</li>
<li>生物特征鉴别</li>
<li>智能卡鉴别</li>
</ol>
</li>
<li><p>存取控制</p>
<p>数据库安全最重要的一点就是确保只授权给有资格的用户访问数据库的权限，同时令所有未被授权的人员无法接近数据，这主要通过数据库系统的存取控制机制实现。</p>
<p><strong>存取控制机制主要包括定义用户权限和合法权限检查两部分。</strong></p>
<ol>
<li><p>定义用户权限，并将用户权限登记到数据字典中</p>
<p>用户对某一数据对象的操作权力称为权限。某个用户应该具有何种权限是个管理问题和政策问题，而不是技术问题。数据库管理系统的功能是保证这些决定的执行。为此，数据库管理系统必须提供适当的语言来定义用户权限，这些定义经过编译后存储在数据字典中，被称做安全规则活授权规则</p>
</li>
<li><p>合法权限检查</p>
<p>每当用户发送存取数据库的操作请求后(请求一般包括操作类型、操作对象和操作用户等信息)，数据库管理系统查找数据字典，根据安全规则进行合法权限检查，若用户的操作请求超出了定义的权限，系统将拒绝执行此操作。</p>
<p><strong>定义用户权限和合法权限检查机制一起组成了数据库管理系统的窜去控制子系统。</strong></p>
<p>C2级的数据库管理系统支持自主存取控制，B1级的数据库管理系统支持强制存取控制。</p>
<p>两类方法的简单定义：</p>
<ul>
<li>在自主存取控制方法中，用户对于不同的数据库对象有不同的存取权限，不同的用户对同一对象也有不同的权限，而且用户还可将其拥有的存取权限转授给其他用户。因此自主存取控制非常灵活。</li>
<li>在强制存取控制方法中，每一个数据库对象被标以一定的密级，每一个用户也被授予某一个级别的许可证。对于任意一个对象，只有具有合法许可证的用户才可以存取。因此强制存取控制因此相对比较严格。</li>
</ul>
</li>
</ol>
</li>
<li><p>自主存取控制方法</p>
<p>大型数据库管理系统都支持自主存取控制，SQL标准也对自主存取控制提供支持，这主要通过SQL的GTANT语句和REVOKE语句来实现。</p>
<p><strong>用户权限是由两个要素组成的:数据库对象和操作类型。</strong>定义一个用户的存取权限就是要定义这个用户可以在哪些数据库对象上进行哪些类型的操作。在数据库系统中，<strong>定义存取权限称为授权</strong>。</p>
<p>在非关系系统中，用户只能对数据进行操作，存取控制的对象不仅有数据本身(基本表中的数据、属性列上的数据)，还有数据库模式(包括模式、基本表、视图和所有的创建等)</p>
</li>
<li><p><img src="/images/关系数据库系统中的存取权限.jpg" alt="关系数据库系统中的存取权限"></p>
</li>
<li><p>授权：授予与收回</p>
<p>SQL中使用GRANT和REVOKE语句向用户授予或收回对数据的操作权限。GRANT语句向用户授予权限，REVOKE语句收回以及授予用户的权限。</p>
<ol>
<li><p>GRANT</p>
<p>GRANT语句的一般格式为</p>
<p>GRANT &lt;权限&gt;[,&lt;权限&gt;]…</p>
<p>ON &lt;对象类型&gt;&lt;对象名&gt;[,&lt;对象类型&gt;&lt;对象名&gt;]…</p>
<p>TO &lt;用户&gt;[,&lt;用户&gt;]…</p>
<p>[WITH GRANT OPTION]</p>
<p>其语义为：将对指定操作对象的指定操作权限授予指定的用户。发出该GRANT语句的可以是数据库管理员，也可以是该数据库对象创建者(即属主owner)，还可以是已经拥有该权限的用户。接受权限的用户可以是一个或多个具体用户，也可以是PUBLIC，即全体用户。</p>
<p>如果指定了 with grant option子句，则获得某种权限的用户还可以把这种权限再授予其他的用户。没有指定with grant option子句，则获得某种权限的用户只能使用该权限，不能传播该权限。</p>
<p>SQL标准允许具有with grant option的用户把相应权限或其子集传递授予其他用户，但不允许循环授权，即被授权者不能把权限再授回给授权者或其祖先。</p>
</li>
<li><p>REVOKE</p>
<p>授予用户的权限可以由数据库管理员或其他授权者用revoke 语句收回，revoke语句的一般格式为</p>
<p>REVOKE &lt;权限&gt;[,&lt;权限&gt;]…</p>
<p>ON &lt;对象类型&gt;&lt;对象名&gt;[,&lt;对象类型&gt;&lt;对象名&gt;]…</p>
<p>FROM &lt;用户&gt;[,&lt;用户&gt;]…[cascade|restrict]</p>
<p>所有授予出去的权力在必要时又都可以用revoke语句收回。</p>
<p>可见，<strong>用户可以”自主“的决定将数据的存取权限授予何人、决定是否也将”授权“的权限授予别人。因此称这一的存取控制是自主存取控制。</strong></p>
</li>
</ol>
</li>
</ul>
<ol start="3">
<li><p>创建数据库模式的权限</p>
<p>GRANT和REVOKE语句向用户授予或收回对数据的操作权限。对创建数据库模式的一类的数据库对象的授权则由数据库管理员在创建用户时实现。</p>
<p>create user语句一般格式如下：</p>
<p>create user <username> [with][DBA|RESOURCE|CONNECT]</username></p>
<p>对create user语句说明如下：</p>
<ul>
<li><p>只有系统的超级用户才有权创建一个新的数据库用户</p>
</li>
<li><p>新创建的数据库用户有三种权限：connec他、resource和dba。</p>
</li>
<li><p>create user命令中如果没有指定创建的新用户的权限，默认该用户拥有connect权限。拥有connect权限的用户不能创建新用户，不能创建模式，也不能创建基本表，只能登入数据库。由数据库管理员或其他用户授予它应由的权限，根据获得的授权情况他可以对数据库对象进行权限范围内的操作。</p>
</li>
<li><p>拥有resource权限的用户能创建基本表和视图，成为所创建对象的属主但不能创建新的用户。数据库对象的属主可以使用grant语句把该对象上的存取权限授予其他用户。</p>
</li>
<li><p>拥有DBA权限的用户是系统中的超级用户，可以创建新的用户、创建模式、创建基本表和视图等；DBA拥有对所有数据库对象的存取权限，还可以把这些权限授予一般用户。</p>
<p><img src="/images/权限与可执行的操作对照表.jpg" alt="权限与可执行的操作对照表"></p>
<p><em>注意：create user语句不上SQL标准，因此不同的关系数据库管理系统的语法和内容相差甚远。</em></p>
</li>
</ul>
</li>
</ol>
<ul>
<li>数据库角色</li>
</ul>
<p>数据库角色是被命名的一组与数据库操作相关的权限，角色是权限的集合。</p>
<ol>
<li><p>角色的创建</p>
<p>创建角色的SQL语句格式是</p>
<p>create role &lt;角色名&gt;</p>
<p>刚刚创建的角色是空的，没有任何内容。可以用grant为角色授权。</p>
</li>
<li><p>给角色授权</p>
<p>grant &lt;权限&gt;[,&lt;权限&gt;]…</p>
<p>on &lt;对象类型&gt;对象名</p>
<p>to &lt;角色&gt;[,&lt;角色&gt;]…</p>
<p>数据库管理员和用户可以利用grant语句将权限授予某一个或几个角色。</p>
</li>
<li><p>将一个角色授予其他的角色或用户</p>
<p>grant &lt;角色1&gt;[,&lt;角色2&gt;]…</p>
<p>to &lt;角色3&gt;[,&lt;用户1&gt;]…</p>
<p>[with admin option]</p>
<p>该语句把角色授予某用户，或授予另一角色。这样，一个角色所拥有的权限就是授予它的全部角色所包含的权限的总和。</p>
<p>授予者或者是角色的创建者忙活着拥有在这个角色上的admin option。</p>
<p>如果指定了with admin option子句，则获得某种权限的角色或用户还可以把这种权限再授予其他的角色</p>
<p>一个角色包含的权限包括直接授予这个角色的全部权限加上其他角色授予这个角色的全部权限。</p>
</li>
<li><p>角色权限的收回</p>
<p>revoke &lt;权限&gt;[,&lt;权限&gt;]…</p>
<p>on &lt;对象类型&gt;&lt;对象名&gt;</p>
<p>from &lt;角色&gt;[,&lt;角色&gt;]…</p>
<p>用户可以收回角色的权限，从而修改角色拥有的权限。</p>
<p>revoke 动作的执行者或者是角色的创建者，或者拥有在这个(些)角色上的ADMIN OPTION.</p>
</li>
</ol>
<ul>
<li><p>强制存取控制方法</p>
<p>在强制存取控制中，数据库管理系统所管理的全部视图被分为主体和客体两大类。</p>
<p>主体是系统中的获得实体，既包括数据库该你了系统所管理的实际用户，也包括代表用户的各进程。客体是系统中的被动实体，是受主体操作的，包括文件、基本表、索引、视图等。对于主体和客体，数据库管理系统为他们每个实例指派一个，敏感度标记。</p>
<p>敏感度标记被分成若干级别，例如绝密(TS)、机密(S)、可信(C)、公开(P)等。密级的次序是TS&gt;=S&gt;=C&gt;=P。主体的敏感度标记称为许可证级别，客体的敏感度标记称为密级。强制存取控制机制就是通过对比主体的敏感度标记和客体的敏感度标记，最终确定主体是否能够存取客体。</p>
<p>当某以用户以标记label注册入系统时，系统要求他对任何客体的存取必须遵循如下规则：</p>
<ol>
<li><p>仅当主体的许可证级别大于或等同于客体的密级时，该主体才能读取相应的客体。</p>
</li>
<li><p>仅当主体的许可证级别小于或等同于客体的密级时，该主体才能写相应的客体。</p>
<p>如果违反了规则2，就有可能把数据的密级从高流向低，造成数据的泄漏。</p>
</li>
</ol>
<p>强制存取控制是对数据本身进行密级标记，无论数据如何复制，标记与数据是一个不可分的整体，只有符合密级要求的用户才可以操作数据，从而提供了更高级别的安全性。</p>
</li>
</ul>
<h3 id="视图机制"><a href="#视图机制" class="headerlink" title="视图机制"></a>视图机制</h3><p>可以为不同的用户定义不同的视图,把数据对象限制在一定的范围内。也就是说，通过视图机制把要保密的数据对无权存取的用户隐藏起来，从而自动对数据提供一定程度的安全保护。</p>
<p>视图机制间接的实现支持存取谓词的用户权限定义。</p>
<h3 id="审计"><a href="#审计" class="headerlink" title="审计"></a>审计</h3><p>审计功能把用户对数据库的所有操作自动记录下来，放入审计日志中。审计员可以利用审计日志监控数据库中的各种行为，重现导致数据库现有状况的一系列事件，找出非法存取数据的人、时间和内容等。</p>
<ol>
<li><p>审计事件</p>
<p>审计事件一般有多个类别</p>
<p>服务器事件:审计数据库服务器发生的事件，包含数据库服务器的启动、停止、数据库服务器配置文件的重新加载。</p>
<p>系统权限：对系统拥有的结构或模式对象进行操作的审计，要求该操作的权限是通过系统权限获得的。</p>
<p>语句事件：对SQL语句，如DDL、DML、DQL及DCL语句的审计</p>
<p>模式对象事件：对特定模式对象上进行的select 或dml操作的审计。模式对象包括表、视图、存储过程、函数等。模式对象不包括依附于表的索引、约束、触发器、分区表等。</p>
</li>
<li><p>审计功能</p>
<p>审计功能主要包括以下几个方面：</p>
<ul>
<li>基本功能，提供多种审计查阅方式：基本的、可选的、有限的，等等。</li>
<li>提供多套审计规则，审计规则一般在数据库初始化时设定，以方便审计员管理。</li>
<li>提供审计分析和报表功能</li>
<li>审计日志管理功能</li>
<li>系统提供查询审计设置及审计记录信息的专门视图。</li>
</ul>
</li>
<li><p>audit语句和noaudit语句</p>
<p>audit语句用来设置审计功能，noaudit语句则取消审计功能。</p>
<p>审计一般可以分为用户级审计和系统级审计。</p>
<p>例：audit alter，update on SC和noaudit alter，update on SC</p>
<p>审计设置以及审计日志一般都存储在数据字典中。必须把审计开关打开，才可以在系统表SYS_AUDITTRAIL中查看到审计信息。</p>
<p>数据库安全审计系统提供了一种事后检查的安全机制。</p>
</li>
</ol>
<h3 id="数据加密"><a href="#数据加密" class="headerlink" title="数据加密"></a>数据加密</h3><p>加密的基本思想是根据一定的算法将原始数据——明文变换为不可直接识别的格式——密文，从而使得不知道界面算法的人无法获知数据的内容.</p>
<ol>
<li><p>存储加密</p>
<p>对于存储加密，一般提供透明和非透明两种存储加密方式。透明存储加密是内核级加密保护方式，对用户完全透明；非透明存储加密则是通过多个加密函数实现的。</p>
</li>
<li><p>传输加密</p>
<p>常见的传输加密方式如链路加密和端到端加密</p>
<p>安全套接层协议SSL，端到端</p>
<p>实现思路包括：</p>
<ol>
<li><p>确认通信双方端点的可靠性</p>
</li>
<li><p>协商加密算法和密钥</p>
</li>
<li><p>可信数据传输</p>
</li>
</ol>
</li>
</ol>
<h3 id="其他安全性保护"><a href="#其他安全性保护" class="headerlink" title="其他安全性保护"></a>其他安全性保护</h3><p>在自主存取控制和强制存取控制之外，还有推理控制以及数据库应用中隐蔽信道和数据隐私保护等技术。</p>
<ul>
<li>推理控制除了的是强制存取控制为解决的问题。数据库推荐控制机制用来避免用户利用其能够访问的数据推知更高密级的数据。</li>
<li>隐蔽信道处理内容也是强制存取控制为解决的问题。</li>
<li>数据隐私成为数据库应用中新的数据保护模式。所谓数据隐私是控制不愿被他人知道或他人不便知道的个人数据的能力。</li>
</ul>
<hr>
<h2 id="第五章-数据库完整性"><a href="#第五章-数据库完整性" class="headerlink" title="第五章 数据库完整性"></a>第五章 数据库完整性</h2><p>数据库的完整性是指数据的正确性和相容性</p>
<p>为维护数据库的完整性，数据库管理系统必须能够实现以下功能：</p>
<ol>
<li>提供定义完整性约束条件的机制</li>
<li>提供完整性检查的方法</li>
<li>进行违约处理</li>
</ol>
<p>关系数据库管理系统使得完整性控制成为其核心支持的功能，从而能够为所有用户和应用提供一致的数据库完整性。</p>
<h3 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h3><ul>
<li><p>定义实体完整性</p>
<p>关系模型的实体完整性在create table中用primary key定义。对单属性构成的码有两种说明方法，一种是定义为劣迹约束条件，另一种是定义为标记约束条件。对于多个属性构成的码只有一种说明方法，即定义为表级约束条件。</p>
</li>
<li><p>实体完整性检查和违约处理</p>
<p>用primary key短语定义了关系的主码后，每当用户程序对级别表插入一条记录或对主码列进行更新操作时，关系数据库管理系统将按照实体完整性规则进行自动检查。</p>
<ol>
<li>检查主码值是否唯一，如果不唯一则拒绝插入或修改。</li>
<li>检查主码的各个属性是否为空，只要有一个为空就拒绝插入或修改。</li>
</ol>
<p>全表扫描是十分好事都。为了避免对基本表进行全表扫描，关系数据库管理系统一般都在主码上自动建立一个索引。</p>
</li>
</ul>
<h3 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h3><ul>
<li><p>定义参照完整性</p>
<p>关系模型的按照完整性在create table中用foreign key短语定义哪些列为外码，用references短语芝麻这些外码参照哪些表的主码。</p>
</li>
<li><p>参照完整性检查和违约处理</p>
<p>参照完整性将两个表中的相应元组联系起来了。因此，对被参照表和参照表进行增、删、改操作时有可能破坏参照完整性，必须进行检查以保证这两个表的相容性。</p>
<p><img src="/images/可能破坏参照完整性的情况及违约处理.jpg" alt="可能破坏参照完整性的情况及违约处理"></p>
<p>当上述的不一致发生时，系统可以采用以下策略加以处理</p>
<ol>
<li><p>拒绝(no action)执行：不允许该操作。该策略一般设置为默认策略。</p>
</li>
<li><p>级联(cascade)操作：当删除或修改被参照表中的一个元组导致与参照表的不一致时，删除或修改参照表中的所有不一致的元组。</p>
</li>
<li><p>设置为空值：当删除或修改被参照表的一个元组时造成了不一致，则将参照表中所有曹操不一致的元组的对应属性设置为空值。</p>
</li>
</ol>
</li>
</ul>
<h3 id="用户定义的完整性"><a href="#用户定义的完整性" class="headerlink" title="用户定义的完整性"></a>用户定义的完整性</h3><ul>
<li><p>属性上的约束条件</p>
<ol>
<li><p>属性上约束条件的定义</p>
<ul>
<li>列值非空(not null)</li>
<li>列值唯一(unique)</li>
<li>检查列值是否满足一个条件表达式(check短语)</li>
</ul>
</li>
<li><p>属性上约束条件的检查和违约处理</p>
<p>不满足条件拒绝执行</p>
</li>
</ol>
</li>
<li><p>元组上的约束条件</p>
<ol>
<li><p>元组上约束条件的定义</p>
<p>与属性上约束条件的定义类似，在create table语句中可以用check 短语定义元组上的约束条件，即元组级的限制。同属性值限制相比，元组级的限制可以设置不同的属性之间的取值的相互约束条件。</p>
</li>
<li><p>属性上约束条件的检查和违约处理</p>
<p>不满足条件拒绝执行</p>
</li>
</ol>
</li>
</ul>
<h3 id="完整性约束命名子句"><a href="#完整性约束命名子句" class="headerlink" title="完整性约束命名子句"></a>完整性约束命名子句</h3><ol>
<li><p>完整性约束命名子句</p>
<p>constraint &lt;完整性约束条件名&gt;&lt;完整性约束条件&gt;</p>
<p>&lt;完整性约束条件&gt;包括not null、unique、primary key、foreign key、check等</p>
</li>
<li><p>修改表中的完整性限制</p>
<p>可以使用alter table语句修改表中的完整性限制</p>
<p>alter table Student drop constraint C4</p>
</li>
</ol>
<h3 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h3><p>在SQL中可以使用数据定义语言中的create assertion语句，通过声明性断言来指定更具一般性的约束。可以定义设计多个表或聚集操作的笔记复制的完整性约束。任何断言不为真的都拒绝执行</p>
<ol>
<li><p>创建断言的语句格式</p>
<p>create assertion &lt;断言名&gt;<check 子句></check></p>
<p>每一断言都被赋予一个名字，<check 子句>中的约束条件与where子句的条件表达式类似。</check></p>
</li>
<li><p>删除断言的语句格式</p>
<p>drop assertion&lt;断言名&gt;</p>
</li>
</ol>
<h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><p>触发器是用户定义在关系表上的一类由事件驱动的特殊过程。</p>
<ul>
<li><p>定义触发器</p>
<p>触发器又叫做事件-条件-动作规则。其一般格式为</p>
<p>create trigger &lt;触发器名&gt;</p>
<p>{before|after} &lt;触发器事件&gt; on &lt;表名&gt;</p>
<p>referencing  new|old  row as &lt;变量&gt;</p>
<p>for each{row|statement}</p>
<p>[when&lt;触发条件&gt;]&lt;触发动作体&gt;</p>
<p>各部分详细说明</p>
<ul>
<li>只有表的拥有者，即创建表的用户才可以在表上创建触发器，并且一个表上只能创建一定数量的触发器。触发器的具体数量由具体的关系数据库管理系统在设计时确定。</li>
<li>触发器名：触发器名可以保护模式名，也可以不包含模式名。同以模式下，触发器名必须是唯一的，并且触发器名与表名必须在同一模式下。</li>
<li>表名：触发器只能定义在基本表上，不能定义在视图上。当基本表的数据发生变化时，将激活定义在改表上相应触发事件的触发器，因此该表也称为触发器表。</li>
<li>触发事件：出发时间可以是insert、delete或update，也可以是这几个事件的组合，如insert or delete等，还可以是update of&lt;触发列，…&gt;即进一步指名修改哪些列时激活触发器。after/before是触发的时机。after表示在触发事件的操作执行之后激活触发器；before表示在触发事件的操作执行之前激活触发器。</li>
<li>触发器类型：触发器按照所触发动作的间隔尺寸可以分为行级触发器和语句级触发器。</li>
<li>触发条件：触发器被激活时，只有当触发条件为真时触发动作体才执行，否则触发动作体不执行。如果省略when触发条件，则触发动作体在触发器激活后立即执行。</li>
<li>触发动作体：触发动作体既可以是一个匿名PL/SQL过程块，也可以是对已创建存储过程的调用。</li>
</ul>
</li>
<li><p>激活触发器</p>
<p>触发器的执行是由触发事件激活，并由数据库服务器自动执行的。一个数据表上可能定义了多个触发器，如多个before触发器、多个after触发器等，同一个表上的多个触发器激活时遵循如下的执行顺序：</p>
<ol>
<li><p>执行该表上的before触发器</p>
</li>
<li><p>激活触发器的SQL语句</p>
</li>
<li><p>执行该表上的after触发器</p>
<p>对于同一个表的多个before(after)触发器，遵循“谁先创建谁先执行”的原则。</p>
</li>
</ol>
</li>
<li><p>删除触发器</p>
<p>删除触发器的SQL语法如下：</p>
<p>drop trigger &lt;触发器名&gt; on &lt;表名&gt;</p>
<hr>
</li>
</ul>
<h2 id="第六章-关系数据理论"><a href="#第六章-关系数据理论" class="headerlink" title="第六章 关系数据理论"></a>第六章 关系数据理论</h2><h3 id="问题的提出"><a href="#问题的提出" class="headerlink" title="问题的提出"></a>问题的提出</h3><ul>
<li>由于关系模型有严格的数学理论基础，并且可以向别的数据模式转换，因此，人们就以关系模型为背景来讨论这个问题，形成了数据库逻辑设计的一个有力工具——关系数据库的规范化理论。</li>
<li>作为一个二维表，关系要符合一个最基本的条件：每一个分量必须是不可分的数据项。满足了这个条件的关系模式就属于<strong>第一范式(1NF)。</strong></li>
<li>数据依赖是一个关系内部属性于属性之间的一种约束关系。这种约束关系是通过属性间值的相等与否体现出来的数据间相关关系。</li>
<li>人们已经提出了多种类型的数据依赖，其中最重要的是<strong>函数依赖和多值依赖。</strong></li>
<li>一个好的模式应当不会发生插入异常、删除异常和更新异常，数据冗余尽可能少。</li>
</ul>
<h3 id="规范化"><a href="#规范化" class="headerlink" title="规范化"></a>规范化</h3><ul>
<li><p>函数依赖</p>
<p>定义：设R(U)是属性集U上的关系模式，X,Y是U的子集。若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等，则称X函数确定Y或Y函数依赖于X，记作X-&gt;Y.</p>
<p>函数依赖和别的数据依赖一样是语义范畴的概念，只能根据语义来确定一个函数依赖。</p>
<ul>
<li>X-&gt;Y,但Y不包含于X，则称X-&gt;Y是<strong>非平凡的函数依赖</strong></li>
<li>X-&gt;Y但Y包含于X，则称X-&gt;Y是平凡的函数依赖。对于任一关系模式，平凡函数依赖都是必然成立的，它不反应新的语义。若不特别声明，总是讨论非平凡的函数依赖。</li>
<li>若X-&gt;,则X称为这个函数依赖的决定属性组，也称为决定因素。</li>
<li>若X-&gt;Y,Y-&gt;X,则记作X<-->Y</--></li>
<li>若Y不函数依赖于X,则记作X!-&gt;Y</li>
<li>在R(U)中，如果X-&gt;Y，并且对于X的任何一个真子集X’，都有X’!-&gt;Y,则称Y对X<strong>完全函数依赖</strong>，记作X  F-&gt;Y</li>
<li>若X-&gt;,但Y不完全函数依赖于X，则称Y对X<strong>部分函数依赖</strong>，记作X P-&gt;Y</li>
<li>在R(U)中，如果X-&gt;Y(Y不包含于X),Y!-&gt;X,Y-&gt;Z,Z不包含于Y则称Z对X<strong>传递函数依赖</strong>。记作X 传递-&gt; Y</li>
</ul>
</li>
<li><p>码</p>
<ul>
<li>码是关系模式中的一个重要概念</li>
<li>设K为R&lt;U,F&gt;中的属性或属性组合，若K F-&gt;U,则K为R的<strong>候选码</strong>。</li>
<li>若候选码多于一个，则选定其中的一个为<strong>主码</strong></li>
<li>不包含在任何候选码中的属性称为<strong>非主属性或非码属性</strong>。最简单的情况，单个属性是码；最极端的情况，整个属性组是码，称为全码。</li>
<li>关系模式R中属性或属性组X并非R的码，但X是另一个关系模式的码，则称X是R的外部码，也称<strong>外码</strong>。</li>
</ul>
</li>
<li><p>范式</p>
<ul>
<li>关系数据库中的关系是要满足一定要求的，满足不同程度要求的为不同范式。</li>
<li>一个低一级范式的关系模式通过模式分解可以转换为若干个高一级范式的关系模式的集合，这种过程就叫规范化。</li>
</ul>
</li>
<li><p>2NF</p>
<ul>
<li><p>若R属于1NF，且每一个非主属性完全函数依赖于任何一个候选码，则R属于2NF。</p>
</li>
<li><p>一个关系模式R不属于2NF，就会产生以下几个问题：</p>
<ol>
<li>插入异常</li>
<li>删除异常</li>
<li>修改异常</li>
</ol>
</li>
</ul>
</li>
<li><p>3NF</p>
<ul>
<li>设关系模式R&lt;U,F&gt;属于1NF，若R中不存在这样的码X，属性组Y及非主属性Z使得X-&gt;Y,Y-&gt; 成立，Y!-&gt;,则称R&lt;U,F&gt;属于3NF</li>
<li>由定义可以证明，若R属于3NF,则每一个非主属性既不传递依赖于码，也不部分依赖于码。也就是说，可以证明如果R属于3NF，则必有R属于2NF</li>
</ul>
</li>
<li><p>BCNF</p>
<ul>
<li>关系模式R&lt;U,F&gt;属于1NF，若X-&gt;Y且Y不包含于X时X必含有码，则R&lt;U,F&gt;属于BCNF</li>
<li>也就是说，关系模式R&lt;U,F&gt;中，若每一个决定因素都包含码，则R&lt;U,F&gt;属于BCNF</li>
<li>由BCNF的定义可以得到结论，一个满足BCNF的关系模式由<ol>
<li>所有非主属性对每一个码都是完全函数依赖。</li>
<li>所有主属性对每一个不包含它的码也是完全函数依赖</li>
<li>没有任何属性完全函数依赖于非码的任何一组属性。</li>
</ol>
</li>
</ul>
</li>
<li><p>规范化小结</p>
<ul>
<li>规范化的基本思想是逐步消除数据依赖中不合适的部分，使模式中的各个关系模式达到某种程度的“分离”，即“一事一地”的模式设计原则。让一个关系描述一个概念，一个实体或者实体间的一种联系。若多于一个概念就把它“分离”出去。因此所谓规范化实质上是概念的单一化。</li>
<li><img src="/images/规范化过程.jpg" alt="规范化过程"></li>
<li>关系模式的规范化过程是通过对关系模式的分解来实现的，即把低一级的关系模式分解为若干个高以级的关系模式。</li>
</ul>
</li>
</ul>
<h3 id="数据依赖的公理系统"><a href="#数据依赖的公理系统" class="headerlink" title="数据依赖的公理系统"></a>数据依赖的公理系统</h3><p>下面首先讨论函数依赖的一个有效而完备的公理系统——Armstrong公理系统。</p>
<ul>
<li>定义：对于满足一组函数依赖F的关系模式R&lt;U,F&gt;,其任何一个关系r，若函数依赖X-&gt;Y都成立(即r中任意两元组t、s，若t[X]=s[X],则t[Y]=s[Y]),则称F逻辑蕴含X-&gt;Y.</li>
<li><p>Armstrong公理系统   设U为属性集总体，F是U上的一组函数依赖，于是有关系模式R&lt;U,F&gt;,对R&lt;U,F&gt;来说有以下的推理规则：</p>
<ul>
<li><p>A1自反律：若Y包含于X包含于U，则X-&gt;Y为所蕴含。</p>
</li>
<li><p>A2增广律：若X-&gt;Y为F所蕴含，且Z包含于U,则XZ-&gt;YZ为F所蕴含。</p>
</li>
<li><p>A3传递律：若X-&gt;Y及Y-&gt;Z为F所蕴含，则X-&gt;Z为F所蕴含</p>
<p><em>注意：由自反律所得到的函数依赖均是平凡的函数依赖，自反律的使用并不依赖于F。</em></p>
</li>
<li><p>定理 6.1：Armstrong推理规则是正确的。</p>
<ul>
<li>根据A1,A2,A3这三条推理规则可以得到下面三条很有用的推理规则<ol>
<li>合并规则：由X-&gt;Y,X-&gt;Z,有X-&gt;YZ</li>
<li>伪传递规则：X-&gt;Y,WY-&gt;Z,有XW-&gt;Z</li>
<li>分解规则：由X-&gt;Y及Z包含于Y，有X-&gt;Z</li>
</ol>
</li>
<li>定义6.12 在关系模式R&lt;U,F&gt;中为F所逻辑蕴含的函数依赖的全体叫作F的闭包，记为F+.</li>
<li>人们把自反律、传递律和增广律称为Armstrong公理系统。Armstrong公理系统是有效的、完备的。Armstrong公理的有效性指的是：由F出发根据Armstrong公理推导出来的每一个函数依赖一定在F+中；完备性指的是F+中的每一个函数依赖，必定可以由F出发根据Armstrong公理推导出来。</li>
</ul>
</li>
<li><p>定义6.13 设F为属性集U上的一组函数依赖，X、Y包含于U，XF+ = {A|X-&gt;A能由F根据Armstrong公理导出}，XF+称为属性集X关于函数依赖集F的闭包。</p>
</li>
<li><p>引理 6.2：设F为属性集U上的一组函数依赖，X,Y包含于U，X-&gt;Y能由F根据Armstrong公理导出的充分必要条件是Y包含于XF+。</p>
</li>
<li><p>定理6.2 Armstrong公理系统是有效的、完备的。</p>
</li>
<li><p>如果函数依赖集F满足下列条件，则称F为一个极小函数依赖集，亦称为最小依赖集或最小覆盖。</p>
<ol>
<li>F中任一函数依赖右部仅含有一个属性。</li>
<li>F中不存在这样的函数依赖X-&gt;A,使得F与F-{X-&gt;A}等价</li>
<li>F中不存在这样的函数依赖X-&gt;A,X有真子集Z使得F-{X-&gt;A}并{Z-&gt;A}与F等价。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="模式的分解"><a href="#模式的分解" class="headerlink" title="模式的分解"></a>模式的分解</h3><ul>
<li><p>模式分解的三个定义</p>
<ul>
<li><p>分解具有<strong>无损连接性</strong></p>
</li>
<li><p>分解要<strong>保持函数依赖</strong></p>
</li>
<li><p>分解既要保持函数依赖，又要无损连接性</p>
<p>这三个定义是实行分解的三条不同的准则。按照不同的分解准则，模式所能达到的分离程度各不相同，各种范式就是对分离程度的测度。</p>
</li>
</ul>
</li>
<li><p>模式分解的算法</p>
<ul>
<li>关于模式分解保持函数依赖，那么模式分离总可以达到3NF，但不一定能达到BCNF</li>
<li>若要求分解既保持函数依赖，又具有无损连接性，可以达到3NF，但不一定能达到BCNF</li>
<li>若要求分解具有无损连接性，那么一定可达到4NF</li>
<li>算法6.3(合成法)转换为3NF的保持函数依赖的分解(课本P198 6.4.3)</li>
<li>算法6.4 转换为3NF既有无损连接性又保持函数依赖的分解(课本P198 6.4.3)</li>
<li>算法6.5(分解法)转换为BCNF的无损连接分解 (课本P198 6.4.3)</li>
</ul>
</li>
</ul>
<h2 id="第七章-数据库设计"><a href="#第七章-数据库设计" class="headerlink" title="第七章 数据库设计"></a>第七章 数据库设计</h2><h3 id="数据库设计概述"><a href="#数据库设计概述" class="headerlink" title="数据库设计概述"></a>数据库设计概述</h3><p>数据库设计，广义的讲，是数据库及其应用系统的设计，即设计整个数据库应用系统；狭义的讲，是设计数据库本身，即设计数据库的各级模式并建立数据库，这是数据库应用系统设计的一部分。</p>
<p>下面给出数据库设计的一般定义.</p>
<p>数据库设计是指对于一个给定的应用环境，构造(设计)优化的数据库逻辑模式和物理结构，并据此建立数据库及其应用系统，使之能够有效的存储和管理数据，满足各种用户的应用需求，包括信息管理要求和数据操作要求。</p>
<ul>
<li><p>数据库设计的特点</p>
<ol>
<li><p>数据库减少的基本规律</p>
<p>“三分技术，七分管理，十二分基础数据”是数据库设计的特点之一。</p>
<p>“十二分基础数据”则强调了数据的手机、整理、组织和不断更新是数据库建设中的重要环节。</p>
</li>
<li><p>结构(数据)设计和行为(处理)设计相结合</p>
<p>数据库设计应该和应用系统设计相结合。也就是说，整个设计过程中要把数据库结构设计和对数据的处理设计密切结合起来。这是数据库设计的特点之二。</p>
</li>
</ol>
</li>
<li><p>数据库设计犯法</p>
<p>它要求从事数据库设计的专业人员具备多方面的知识和技术。主要包括：</p>
<ul>
<li>计算机的基础知识</li>
<li>程序设计的方法和技巧</li>
<li>数据库的基本知识</li>
<li>数据库设计技术</li>
<li>应用领域的知识</li>
</ul>
</li>
<li><p>数据库设计的基本步骤</p>
<ol>
<li><p>需求分析阶段</p>
</li>
<li><p>概念结构设计阶段</p>
</li>
<li><p>逻辑结构设计阶段</p>
</li>
<li><p>物理结构设计阶段</p>
</li>
<li><p>数据库实施阶段</p>
</li>
<li><p>数据库运行和维护阶段</p>
<p><img src="/images/数据库设计步骤.jpg" alt="数据库设计步骤"></p>
</li>
</ol>
</li>
<li><p>数据库设计过程中的各级模式</p>
<p><img src="/images/数据库的各级模式.jpg" alt="数据库的各级模式"></p>
</li>
</ul>
<h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><ul>
<li><p>需求分析的任务</p>
<p>调查的重点是“数据”和“处理”，通过调查、收集与分析，获得用户对数据库的如下要求：</p>
<ol>
<li>信息要求。指用户需要从数据库中获得信息的内容与性质。由信息要求可以导出数据要求，即在数据库中需要存储哪些数据。</li>
<li>处理要求。指用户要完成的数据处理功能，对处理性能的要求。</li>
<li>安全性与完整性要求。</li>
</ol>
</li>
<li><p>需求分析分析的方法</p>
<p>调查用户需求的具体步骤是：</p>
<ol>
<li>调查组织机构情况。</li>
<li>调查各部门的业务活动情况。</li>
<li>在熟悉业务活动的基础上，协助用户明确对新系统的各种要求，包括信息要求、处理要求、安全性与完整性要求，这是调查的又一个重点。</li>
<li>确定新系统的边界。</li>
</ol>
<p>调查常用的方法：</p>
<ol>
<li>跟班作业。</li>
<li>开调查会</li>
<li>请专人介绍。</li>
<li>询问。</li>
<li>设计调查表请用户填写</li>
<li>查阅记录</li>
</ol>
</li>
<li><p>数据字典</p>
<p>数据字典是进行详细的数据收集和数据分析所获得的主要成果。它是关于数据库中数据的描述，即元数据，而不是数据本身。数据字典是在需求分析阶段建立，在数据库设计过程中不断修改，充实，完善的。它在数据库设计中占有很重要的地位。</p>
<ol>
<li><p>数据项</p>
<p>数据项是不可再分的数据单位。对数据项的描述通常包括以下内容。</p>
<p>数据项描述 = {数据项名，数据项含义说明，别名，数据类型，长度，取值范围，取值含义，与其他数据项的逻辑关系，数据项之间的联系}</p>
<p>其中，“取值范围”、“与其他数据项的逻辑关系”(如该数据项等于其他几个数据项的和、该数据项值等于另一数据项的值等)定义了数据的完整性约束条件，是设计数据检验功能的依据。</p>
</li>
<li><p>数据结构</p>
<p>数据结构反映了数据之间的组合关系。一个数据结构可以由若干给数据项组成，也可以由若干个数据结构组成，或由若干个数据项和数据结构混合组成。对数据结构的描述通常包括以下内容：</p>
<p>数据结构描述 = {数据结构名，含义说明，组成：{数据项或数据结构}}</p>
</li>
<li><p>数据流</p>
<p>数据流是数据结构在系统内传输的路径。对数据流的描述通常包括以下内容：</p>
<p>数据流描述 = {数据流名，说明，数据流来源，数据流去向，组成：{数据结构}，平均流量，高峰期流量}</p>
<p>其中，“数据流来源”是说明该数据流来自哪个过程；“数据流去向”是说明该数据流将导哪个过程取；“平均流量”是指在单位时间(每天、每周、每月等)里的传输次数；“高峰期流量”则是指在高峰时期的数据流量。</p>
</li>
<li><p>数据存储</p>
<p>数据存储是数据结构停留或保存的地方，也是数据流的来源和去向之一。它可以是手工文档或手工凭单，也可以是计算机文档，对数据存储的描述通常包括以下内容：</p>
<p>数据存储描述 = {数据存储名，说明，编号，输入的数据流，输出的数据流，组成：{数据结构}，数据量，存储频率，存取方式}</p>
<p>其中，“存取频度”指每小时、每天或每周存取次数及每次存取的数据量等信息；</p>
</li>
<li><p>处理过程</p>
<p>处理过程的具体处理逻辑一般用判定表或判定树来描述。数据字典中只需要描述处理过程的说明信息即可，通常包括以下内容：</p>
<p>处理过程描述 = {处理过程名，说明，输入：{数据流}，输出：{数据流}，处理：{简要说明}}</p>
<p>最后要强调两点：</p>
<ol>
<li>需求分析阶段的一个重要而困难的任务是收集将来应用所涉及的数据，设计人员应充分考虑到可能的扩充和改变，使设计易于更改、系统易于扩充。</li>
<li>必须强调用户的参与，这是数据库应用系统设计的特点。</li>
</ol>
</li>
</ol>
</li>
</ul>
<h3 id="概念结构设计"><a href="#概念结构设计" class="headerlink" title="概念结构设计"></a>概念结构设计</h3><ul>
<li><p>概念模型</p>
<p>概念模型的主要特点是：</p>
<ol>
<li>能真实、充分的反映现实世界，包括事物和事物之间的联系，能满足用户对数据的处理要求，是现实世界的一个真实模型。</li>
<li>易于理解，可以用它和不熟悉计算机多用户交换意见。用户的积极参与是数据库设计成功的关键。</li>
<li>易于更改，当应用环境和应用要求改变时容易对概念模型修改和扩充。</li>
<li>易于向关系、网状、层次等各种数据模型转换。</li>
</ol>
</li>
<li><p>E-R模型</p>
<ol>
<li><p>实体之间的联系</p>
<ul>
<li>两个实体型之间的联系：一对一联系(1:1)、一对多联系(1:n)、多对多联系(m:n)</li>
<li>两个以上的实体型之间的联系：两个以上的实体型之间也存在着一对一、一对多和多对多联系。</li>
<li>单个实体型内的联系：同一个实体集内的各实体之间也可以存在一对一、一对多和多对多的联系。</li>
</ul>
<p>一般的，把参与联系的实体型的数目称为联系的度。两个实体型之间的联系度为2，也称为二元联系；三个实体型之间的联系度为3，称为三元联系；N个实体型之间的联系度为N，也成为N元联系。</p>
</li>
<li><p>E-R图</p>
<p>E-R图提供了表示实体型、属性和联系的方法。</p>
<ol>
<li>实体型用矩形表示，矩形框内写明实体名。</li>
<li>属性用椭圆表示，并用无向边将其与相应的实体型连接起来</li>
<li>联系用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体型来南京起来，同时在无向边旁标上联系的类型(1：1、1：n、m:n)</li>
</ol>
</li>
<li><p>一个实例</p>
<p><img src="/images/工厂物资管理E-R图.jpg" alt="工厂物资管理E-R图"></p>
</li>
</ol>
</li>
<li><p>扩展的E-R模型</p>
<ol>
<li><p>ISA联系</p>
<p>用E-R方法构建一个项目的模型时，经常会遇到某些实体型的子类型。例如，研究生和本科生是学生的子类型，学生是父类型。这种父类-子类联系称为ISA联系，表示“is a”的语义。联系用三角形来表示。</p>
<ol>
<li><p>分类属性</p>
<p>根据分类属性的值把父实体型中的实体分派到子实体型中。</p>
<p><img src="/images/学生的两个子类型和分类属性.jpg" alt="学生的两个子类型和分类属性"></p>
</li>
<li><p>不相交约束与可重叠约束</p>
<p>不相交约束描述父类中的一个实体不能同时属于多个子类中的实体集，即一个父类中的实体最多属于一个子类实体集，用ISA联系三角形符号内加一个叉号“X“来表示。</p>
<p><img src="/images/子类不相交约束.jpg" alt="子类不相交约束"></p>
</li>
<li><p>完备性约束</p>
<p>完备性约束描述父类中的一个实体是否必须是某一个子类中的实体，如果是，则叫做完全特化，否则叫做部分特化。完全特化用父类到子类的双线连接来表示，单线连接则表示部分特化。</p>
</li>
</ol>
</li>
<li><p>基数约束</p>
<p>基数约束是对实体之间一对一，一对多和多对多来呢西的细化。参与联系的每个实体型用基数约束来说明实体型中的任何一个实体可以在联系中出现的最少次数和最多次数。</p>
<p>约束用一个数对min..max表示，0&lt;=min&lt;=max。例如，0..1、1..3、1..<em>(\</em>代表无穷大)。min=1的约束叫做强制参与约束，即被施加基数约束的实体型中的每个实体都要参与联系；min=0的约束叫做非强制参与约束，被世家基数约束的实体型中的实体可以出现在联系中，也可以不出现在联系中。</p>
<p><img src="/images/一对一、一对多、多对多的基数约束示例.jpg" alt="一对一、一对多、多对多的基数约束示例"></p>
</li>
</ol>
</li>
</ul>
<ol start="3">
<li><p>Part-of联系</p>
<p>Part-of联系即部分联系，它表明某个实体型是另外一个实体型的一部分。非独占的Part-of联系可以通过基数约束来表达(非强制参与联系)。与非独占联系相反，还有一种Part-of联系是独占联系。即整体实体如果被破坏，部分实体不能存在，在E-R图中用弱实体类型和识别联系来表示独占联系。<strong>如果一个实体型的存在依赖于其他实体型的存在，则这个实体型叫做弱实体型，否则叫做强实体型。</strong>如果不能从一个实体型的属性中找出可以作为码的属性，则这个实体型是弱实体型。在E-R图中用双矩形表示弱实体型，用双菱形表示识别联系。</p>
<p><img src="\images\弱实体型.jpg" alt="弱实体型"></p>
</li>
</ol>
<ul>
<li><p>概念结构设计</p>
<ol>
<li><p>实体与属性的划分原则</p>
<p>在调整中遵循的一条原则是：为了简化E-R图的处置，现实世界的事物能作为属性对待的尽量作为属性对待。</p>
<p>符合什么条件的事物可以作为属性对待，可以给出两条准则：</p>
<ol>
<li><strong>作为属性，不能再具有需要描述的性质</strong>，即属性必须是不可分的数据项，不能包含其他属性。</li>
<li><strong>属性不能与其他实体具有联系</strong>，即E-R图中所表示的联系是实体之间的联系。</li>
</ol>
</li>
<li><p>E-R图的集成</p>
<p>E-R图的集成一般需要两步走:</p>
<ul>
<li><p>合并。解决各分E-R图之间的冲突，将分E-R图合并起来生成初步E-R图。</p>
</li>
<li><p>修改和重构。消除不必要的冗余，生成基本E-R图。</p>
<ol>
<li><p>合并E-R图生成初步E-R图</p>
<p>合理消除各E-R图的冲突是合并E-R如的主要工作与关键所在。</p>
<ul>
<li><p>属性冲突</p>
<ul>
<li>属性域冲突，即属性值的类型、取值范围或取值集合不同</li>
<li>属性取值单位冲突</li>
</ul>
</li>
<li><p>命名冲突</p>
<ul>
<li>同名异义，即不同意义的对象在不同的局部应用中具有相同的名字</li>
<li>异名同义，即同一意义的对象在不同的局部应用中具有不同的名字</li>
</ul>
</li>
<li><p>结构冲突</p>
<p>结构冲突主要包含以下三类冲突：</p>
<ul>
<li>同一对象在不同应用中具有不同的抽象。</li>
<li>同一实体在不同子系统的E-R图中所包含的属性个数和数学排列次序不完全相同。</li>
<li>实体间的联系在不同的E-R图中为不同的类型。</li>
</ul>
</li>
</ul>
</li>
<li><p>消除不必要的冗余，设计基本E-R图</p>
<p>在初步E-R图中可能存在一些冗余的数据和实体间冗余的联系。</p>
<ul>
<li><p>消除冗余主要采用分析方法，即以数据字典和数据流图为依据，根据数据字典中关于数据项之间逻辑关系的说明来消除冗余。</p>
</li>
<li><p>除分析方法外，还可以用规范化理论来消除冗余。在规范化理论中，函数依赖的概念提供了消除冗余联系的形式化工具。具体方法如下：</p>
<ol>
<li><p>确定分E-R图实体之间的数据依赖。</p>
</li>
<li><p>求FL的最小覆盖GL，差集为D=FL-GL。</p>
<p>由于规范化理论受到泛关系假设的限制，应注意下面两个问题：</p>
<ul>
<li>冗余的联系一定在D中，而D中的联系不一定是冗余的。</li>
<li>当实体之间存在多种联系时，要将实体之间的联系在形式上加以区分。</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="逻辑结构设计"><a href="#逻辑结构设计" class="headerlink" title="逻辑结构设计"></a>逻辑结构设计</h3><p>逻辑结构设计的任务就是把概念呢结构设计阶段设计好的基本E-R图转换为与选用数据库管理系统产品所支持的数据模型相符合的逻辑结构。</p>
<ul>
<li><p>E-R图向关系模型的转换</p>
<p>下面介绍转换的一般原则。<strong>一个实体型转换为一个关系模式</strong>，关系的属性就是实体的属性，关系的码就是实体的码。对于实体型间的联系有以下不同的情况：</p>
<ol>
<li>一个1:1联系可以转换为一个独立的关系模式，也可以与任意一端对应的关系模式合并。</li>
<li>一个1:n 联系可以转换为一个独立的关系模式，也可以与n端对应的关系模式合并。</li>
<li>一个m:n联系转换为一个关系模式，与该联系相连的各实体的码以及联系本身的数据均转换为关系的属性，各实体的码组成关系的码或关系码的一部分。</li>
<li>三个或三个以上实体间的一个多元联系可以转换为一个关系模式。</li>
<li>具有相同码的关系模式可合并。</li>
</ol>
</li>
<li><p>数据模型的优化</p>
<p>数据库逻辑设计的结果不是唯一的。关系数据模型的优化通常以规范化理论为指导，方法为：</p>
<ol>
<li><p>确定数据依赖</p>
</li>
<li><p>对于各个关系模式之间的数据依赖进行极小化除了，消除冗余的联系</p>
</li>
<li><p>按照数据依赖的理论对关系模式逐一进行分析，考察是否存在部分函数依赖、传递函数依赖、多值依赖等，确定各关系模式分别属于第几范式。</p>
</li>
<li><p>根据需求分析阶段得到的处理要求分析对于这样的应用环境这些模式是否合适，确定是否要对某些模式进行合并或分解。</p>
<p>必须注意的是，并不是规范化程度越高的关系就越优。</p>
</li>
<li><p>对关系模式进行必要分解，提高数据操作效率和存储空间利用率。常用的两种分解方法是水平分解和垂直分解。</p>
</li>
</ol>
</li>
<li><p>设计用户子模式</p>
<p>由于用户外模式与模式是相对独立的，因此在定义用户外模式时可以注重考虑用户的习惯与方便。具体包括以下几个方面：</p>
<ol>
<li>使用更符合用户习惯的别名。</li>
<li>可以对不同级别的用户定义不同的视图，以保证系统的安全性。</li>
<li>简化用户对系统的使用。</li>
</ol>
</li>
</ul>
<h3 id="物理结构设计"><a href="#物理结构设计" class="headerlink" title="物理结构设计"></a>物理结构设计</h3><p>为一个给定的逻辑数据模型选取一个最适合应用要求的物理结构的过程，就是数据库的物理设计。</p>
<p>数据库的物理设计通常分为两步：</p>
<ol>
<li>确定数据库的物理结构，在关系数据库中主要指存取方法和存储结构。</li>
<li>对物理结构进行评价，评价的重点是时间和空间效率。</li>
</ol>
<ul>
<li><p>数据库物理设计的内容和方法</p>
<p>对于数据库查询事务，需要得到如下信息：</p>
<ul>
<li>查询的关系</li>
<li>查询条件所涉及的属性</li>
<li>连接条件所涉及的属性</li>
<li>查询的投影属性</li>
</ul>
<p>对于数据更新事务，需要得到如下信息：</p>
<ul>
<li>被更新的关系</li>
<li>每个关系上的更新操作条件所涉及的属性</li>
<li>修改操作要改变的属性值</li>
</ul>
<p>通常关系数据库物理涉及的内容主要包括为关系模式选择存取方法，以上设计关系、索引等数据库文件的物理存储结构。</p>
</li>
<li><p>关系模式存取方法选择</p>
<p>存取方法是快速存取数据库中数据的基数。数据库管理系统一般提供多种存取方法。常用的存取方法为索引方法和聚簇方法。</p>
<ol>
<li><p>B+树索引存取方法的选择</p>
</li>
<li><p>hash索引存取方法的选择</p>
</li>
<li><p>聚簇存取方法的选择</p>
<p>为了提高某个属性(或属性组)的查询速度，把这个或这些属性上具有相同值的元组集中存放在连续的物理块中称为聚簇。该属性(或属性组)称为聚簇码。</p>
</li>
</ol>
</li>
<li><p>确定数据库的存储结构</p>
<ol>
<li>确定数据的存放位置</li>
<li>确定系统配置</li>
</ol>
</li>
<li><p>评价物理结构</p>
</li>
</ul>
<h3 id="数据库的实施和维护"><a href="#数据库的实施和维护" class="headerlink" title="数据库的实施和维护"></a>数据库的实施和维护</h3><ul>
<li><p>数据的载入和应用程序的调试</p>
<p>数据库应用程序的设计应该与数据库设计同时进行，因此在组织数据入库的同时还要调试应用程序。</p>
</li>
<li><p>数据库的试运行</p>
<p>这里特别要强调两点。第一上面已经讲到组织数据入库是十分费时、费力的事，如果试运行后还要修改数据库的设计，还要重新组织数据入库。因此应分期分批的组织数据入库，先输入小批量数据做调试用，带试运行基本合格后再大批量输入数据，逐步增加数据量，组别完成评价。第二，再数据库试运行阶段，由于系统还不稳定，硬、软件故障随时都可能发生；而系统的操作人员对新系统还不熟悉，误操作也不可避免，因此要做好数据库的转储和恢复工作。</p>
</li>
<li><p>数据库的运行和维护</p>
<ol>
<li>数据库的转储和恢复</li>
<li>数据库的安全性、完整性控制</li>
<li>数据库性能的监督分析和改造</li>
<li>数据库的重组织与重构造</li>
</ol>
</li>
</ul>
<hr>
<h2 id="数据库编程"><a href="#数据库编程" class="headerlink" title="数据库编程"></a>数据库编程</h2><p>未完待续。。。</p>
<p>—&gt;                    </p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/04/06/杭电oj-1004/" rel="next" title="杭电oj-1004">
                <i class="fa fa-chevron-left"></i> 杭电oj-1004
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/08/22/hexo常用命令/" rel="prev" title="hexo常用命令">
                hexo常用命令 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">categories</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#数据库"><span class="nav-number">1.</span> <span class="nav-text">数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第一章-绪论"><span class="nav-number">1.1.</span> <span class="nav-text">第一章 绪论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库系统概述"><span class="nav-number">1.1.1.</span> <span class="nav-text">数据库系统概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据模型"><span class="nav-number">1.1.2.</span> <span class="nav-text">数据模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库系统的结构"><span class="nav-number">1.1.3.</span> <span class="nav-text">数据库系统的结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第二章-关系数据库"><span class="nav-number">1.2.</span> <span class="nav-text">第二章 关系数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关系数据结构及形式化定义"><span class="nav-number">1.2.1.</span> <span class="nav-text">关系数据结构及形式化定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关系操作"><span class="nav-number">1.2.2.</span> <span class="nav-text">关系操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关系的完整性"><span class="nav-number">1.2.3.</span> <span class="nav-text">关系的完整性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关系代数"><span class="nav-number">1.2.4.</span> <span class="nav-text">关系代数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第三章-关系数据库标准语言SQL"><span class="nav-number">1.3.</span> <span class="nav-text">第三章 关系数据库标准语言SQL</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SQL-概述"><span class="nav-number">1.3.1.</span> <span class="nav-text">SQL 概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据定义"><span class="nav-number">1.3.2.</span> <span class="nav-text">数据定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据查询"><span class="nav-number">1.3.3.</span> <span class="nav-text">数据查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据更新"><span class="nav-number">1.3.4.</span> <span class="nav-text">数据更新</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#空值的处理"><span class="nav-number">1.3.5.</span> <span class="nav-text">空值的处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#视图"><span class="nav-number">1.3.6.</span> <span class="nav-text">视图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第四章-数据库安全性"><span class="nav-number">1.4.</span> <span class="nav-text">第四章 数据库安全性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库安全性概述"><span class="nav-number">1.4.1.</span> <span class="nav-text">数据库安全性概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库安全性控制"><span class="nav-number">1.4.2.</span> <span class="nav-text">数据库安全性控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#视图机制"><span class="nav-number">1.4.3.</span> <span class="nav-text">视图机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#审计"><span class="nav-number">1.4.4.</span> <span class="nav-text">审计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据加密"><span class="nav-number">1.4.5.</span> <span class="nav-text">数据加密</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其他安全性保护"><span class="nav-number">1.4.6.</span> <span class="nav-text">其他安全性保护</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第五章-数据库完整性"><span class="nav-number">1.5.</span> <span class="nav-text">第五章 数据库完整性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实体完整性"><span class="nav-number">1.5.1.</span> <span class="nav-text">实体完整性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参照完整性"><span class="nav-number">1.5.2.</span> <span class="nav-text">参照完整性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用户定义的完整性"><span class="nav-number">1.5.3.</span> <span class="nav-text">用户定义的完整性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#完整性约束命名子句"><span class="nav-number">1.5.4.</span> <span class="nav-text">完整性约束命名子句</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#断言"><span class="nav-number">1.5.5.</span> <span class="nav-text">断言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#触发器"><span class="nav-number">1.5.6.</span> <span class="nav-text">触发器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第六章-关系数据理论"><span class="nav-number">1.6.</span> <span class="nav-text">第六章 关系数据理论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#问题的提出"><span class="nav-number">1.6.1.</span> <span class="nav-text">问题的提出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#规范化"><span class="nav-number">1.6.2.</span> <span class="nav-text">规范化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据依赖的公理系统"><span class="nav-number">1.6.3.</span> <span class="nav-text">数据依赖的公理系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#模式的分解"><span class="nav-number">1.6.4.</span> <span class="nav-text">模式的分解</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第七章-数据库设计"><span class="nav-number">1.7.</span> <span class="nav-text">第七章 数据库设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库设计概述"><span class="nav-number">1.7.1.</span> <span class="nav-text">数据库设计概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#需求分析"><span class="nav-number">1.7.2.</span> <span class="nav-text">需求分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#概念结构设计"><span class="nav-number">1.7.3.</span> <span class="nav-text">概念结构设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#逻辑结构设计"><span class="nav-number">1.7.4.</span> <span class="nav-text">逻辑结构设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#物理结构设计"><span class="nav-number">1.7.5.</span> <span class="nav-text">物理结构设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据库的实施和维护"><span class="nav-number">1.7.6.</span> <span class="nav-text">数据库的实施和维护</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据库编程"><span class="nav-number">1.8.</span> <span class="nav-text">数据库编程</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Muse</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  


  
    <script src="/js/cursor/cherry.js"></script>
  
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/assets/z16.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":true},"log":false});</script></body>
</html>



